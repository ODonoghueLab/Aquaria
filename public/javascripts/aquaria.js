(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//var idrViewer;
//var structure;

var idrViewer;
var structures = {};

var IDRPanel = function (attachToDiv, width, height) {
	this.attachToDiv = attachToDiv;
	this.initialised = false;
};

IDRPanel.prototype.display_cluster = function(cluster, width, height) {
	var that = this;
	if (!this.initialised) {
		var w = width > 0 ? width : 640;
		var h = height > 0 ? height: 480;

		idrViewer = pv.Viewer(attachToDiv, 
				{ quality : 'low', width: w, height : h,
			antialias : true, outline : false,
			slabMode : 'auto',
			near: 0.1,
			far: 10000,
			background: [0.8, 0.8, 0.8]
				});
		idrViewer.options('fog', false);
		this.initialised = true;
	}
	
	idrViewer.clear();
	structures = {};
	cluster.members.forEach(function(member) {
		$.ajax({ url : getPDBURL(member.pdb_id), success : function(data) {
			console.log("[IDRPanel]: loading " + member.pdb_id);
			structures[member.pdb_id] = io.pdb(data);

			//idrViewer.sline(member.pdb_id, structures[member.pdb_id],{ color : color.uniform('red'), showRelated : '1'});
			idrViewer.cartoon(member.pdb_id, structures[member.pdb_id], 
			{ color: that.colorBySSAndHomology(structures[member.pdb_id].conservations), strength: 1.0});
			idrViewer.autoZoom();
			//that.initialised = true;
		}});
	});

};

IDRPanel.prototype.load = function (attributes) {
	idrViewer = pv.Viewer($(this.attachToDiv)[0], 
			{ quality : 'high', width: attributes.width, height : attributes.height,
		antialias : true, outline : false,
		slabMode : 'fixed',
		near: 0.1,
		far: 10000,
		background: [0.8, 0.8, 0.8]
			});
	//var selector =  this.PVSelector(idrViewer);	
	idrViewer.options('fog', false);
	this.reload(attributes);
};

IDRPanel.prototype.reload =  function(attributes) {
	var that = this;
	idrViewer.resize(attributes.width, attributes.height);
	$.ajax({ url : attributes.url, success : function(data) {
		structure = io.pdb(data);
		idrViewer.clear();
		idrViewer.cartoon('structure.protein', 
				structure, 
				{ color: that.colorBySSAndHomology(attributes.conservations), strength: 1.0});
		//showRelated : '1', 
		idrViewer.autoZoom();
		this.blankApplet(false);
		that.initialised = true;
	}});
};

IDRPanel.prototype.blankApplet = function(isOn, message) {
//changeAppletSize();
if (isOn ) {
    var appletMessage = $('#waitingFrame').contents().find('#appletMessage');
    if (message) {
      appletMessage.text(message);
    }
    else {
      appletMessage.text("Please wait...");
    }
    if (!$('#waitingFrame').is(":visible")) {
      
      $('#waitingFrame').hide();
      $('#waitingFrame').fadeIn("fast");
    }
}
else {
  $('#waitingFrame').fadeOut("slow");
}
};


IDRPanel.prototype.mousePressed =  function(atom, e) {
	console.log('obj: ' + atom.residue().num() + ', e: ' + e);
};

var interpolateColour = function (base, other, amount) {
	var i;
	var ret = [];
	for (i = 0; i < base.length; i++) {
		ret[i] = base[i] * amount + other[i] * (1 - amount);
	}
	return ret;
}

var assignColour = function (out, index, colorArray) {
	out[index] = colorArray[0]; 
	out[index+1] = colorArray[1]; 
	out[index+2] = colorArray[2];
}


IDRPanel.prototype.colorBySSAndHomology = function(conservations) {
	var that = this;
	this.conservations = conservations;
	this.notConserved = [60/255, 60/255, 60/255];
	this.identicalColourMap = {
			'C': [99/255, 153/255, 65/255], //coil
			'H': [86/255, 138/255, 181/255],   	// helix 
			'E': [255/255, 201/255, 0/255]   	//sheet 
	};
	this.conservedColourMap = {};
	Object.keys(this.identicalColourMap).forEach (function (key) {
		that.conservedColourMap[key] = interpolateColour(that.identicalColourMap[key], that.notConserved, 0.55);
	});

	return new ColorOp(function(atom, out, index) {
		var residue = atom.residue();
		var colour = that.getColourForResidue(residue);
		assignColour(out, index, colour);
	}, null, null);
};

IDRPanel.prototype.getColourForResidue = function (residue) {
	var chain = residue.chain().name();
	var chainConservation = this.conservations[chain]; 

	var checkAgainst = this.identicalColourMap[residue.ss()];
	if (chainConservation && chainConservation.nonconserved.indexOf(residue.num()) > -1) {
		// non conserved residue
		checkAgainst = this.notConserved;
	}
	else if (chainConservation){
		var map = (chainConservation.conserved.indexOf(residue.num()) > -1) ? this.conservedColourMap : this.identicalColourMap;
		checkAgainst =  map[residue.ss()];
	}
	return checkAgainst;
};

IDRPanel.prototype.selectNew = function (oldResidue, newResidue) {
	var that = this;
	return new ColorOp(function(atom, out, index) {
		var residue = atom.residue();
		if (residue == oldResidue) {
			var colour = that.getColourForResidue(residue);
			assignColour(out, index, colour);
		}
		else if (residue == newResidue) {
			var colour = that.getColourForResidue(residue);
			assignColour(out, index, vec3.fromValues(1,1,1));
		}
	}, null, null);

}

IDRPanel.prototype.PVSelector = function (viewer) {
	var that = this;
	this.lastSelectedAtom = null;

	viewer._domElement.addEventListener("atompicked", function(e) {
		e.preventDefault();

		console.log(e.detail.atom.residue().num());
		var newAtom = e.detail.atom;
		var oldResidue  = null;
		if ( this.lastSelectedAtom != null) {
			oldResidue = this.lastSelectedAtom.residue();
		}
		if (newAtom != null) {
//			idrViewer.options('color', selectNew(oldResidue, newAtom.residue()));
			e.detail.geom.colorBy(that.selectNew(oldResidue, newAtom.residue()));
			selectionText(true, newAtom.residue().name() + ": " + newAtom.residue().num());
		}
		viewer.requestRedraw();
		this.lastSelectedAtom = newAtom;
	}, false);
};

IDRPanel.prototype.changeViewerSize = function(w, h) {

  $(this.attachToDiv).width(w);
  $(this.attachToDiv).height(h);
  pViewer.fitParent();
}


function getPDBURL(pdbID, biounit) {
	var url = "https://files.rcsb.org/download/" + pdbID + ".pdb";
	if (biounit > 0) {
//		url = "https://files.rcsb.org/download/" + pdbID + ".pdb" + biounit ;
	}
	return url;
}

IDRPanel.prototype.gestures = function () {
  var functions = ['triggerPan', 'triggerRotate', 'triggerZoom', 'point', 'reset', 'zoomToSelection', 'selectMouseCursor'];
  var ret = {};
  functions.forEach(function (funcName) {
    ret[funcName] = function () {
      var newArgs = [funcName];
      newArgs.push(Array.prototype.slice.call(arguments));
      if (funcName === 'triggerRotate') {
        console.log('about to call TODO for webgl: ' + newArgs);
      }
//      if (document.applets[0]) {
//        document.applets[0].molecularControlToolkit.apply(document.applets[0], newArgs);
//      }
    }
  })
  return ret;
}

module.exports = IDRPanel;

},{}],2:[function(require,module,exports){
var Applet3DPanel = function (attachToDiv) {

	this.initialised = false;
	this.load  =  function(attributes) {

		var parameters = {
				jnlp_href: '/jnlp/' + attributes['versionString'] + '/aquaria.jnlp',
				cache_option:"plugin", 
				cache_archive:"aquaria-bundle.jar",
				cache_version: attributes['versionString'], 
				codebase_lookup: false
		}; 
		if (attributes['interactive'] && attributes['interactive'] == 'leap') {
			parameters['jnlp_href'] = '/jnlp/' + attributes['versionString'] + '/aquaria-leap.jnlp'
		}
		activateApplet(attributes, parameters);
		AQUARIA.uniqueId = [attributes.instanceId, attributes.biounit].join('-');

		// dim background when applet has focus
		var existingOnFocus = document.applets[0].onfocus;
		// var frame = $("#threeDFrame")[0];
		var target = window;
		document.applets[0].onfocus = function() {
			$(".infocus").removeClass("infocus"); 
			$("#structureviewer").addClass("infocus");
			if (existingOnFocus) {
				existingOnFocus();
			}
			console.log('setup window keydown');
			$(target).keydown(function(e) {
				console.log("key down: " + e);
				// e.preventDefault();
			});
			$(target).keypress(function(e) {
				console.log("key press: " + e);
				// e.preventDefault();
			});
		};

		// brighten background when applet does not have focus
		document.applets[0].onblur = function() {
			$("#structureviewer").removeClass("infocus");
			console.log('clear window keydown');
			$(target).keydown(null);
			$(target).keypress(null);
		};
		
		//return focus to applet when header bar is clicked
		$("div#structureviewer.panel").click( function() { $("applet#AquariaApplet").focus(); });
		
		
		this.initialised = true;
	};

	this.reload =  function(attributes) {
	  var newUniqueId = [attributes.instanceId, attributes.biounit].join('-');
;
		if (AQUARIA.uniqueId !== newUniqueId) {

			if (attributes.annotations) {
				document.applets[0].loadNew(attributes.pdb_id, attributes.structures, attributes.instanceId, attributes.sequenceAlignments, attributes.annotations);
			}
			else {
				document.applets[0].loadNewPlain(attributes.pdb_id, attributes.structures, attributes.instanceId, attributes.sequenceAlignments);

			}
			AQUARIA.uniqueId = newUniqueId;
		}
		else {
		  this.blankApplet(false);

			console.log('redisplaying PDB: ' + AQUARIA.uniqueId);
		}
	};


	this.addAnnotation = function(id, annotationName, featureColours,		featureNames, featureDescriptions, featurePositions, featureURLs, featureURLTexts) {
		document.applets[0].addAnnotation(id, annotationName, featureColours,		featureNames, featureDescriptions, featurePositions, featureURLs, featureURLTexts);
	};

	this.removeAnnotation = function(id, annotationName) {
		document.applets[0].removeAnnotation(id, annotationName);
	};


	this.gestures = function () {
	  var functions = ['triggerPan', 'triggerRotate', 'triggerZoom', 'point', 'reset', 'zoomToSelection', 'selectMouseCursor'];
	  var ret = {};
	  functions.forEach(function (funcName) {
	    ret[funcName] = function () {
	      var newArgs = [funcName];
	      newArgs.push(Array.prototype.slice.call(arguments));
	      if (funcName === 'triggerRotate') {
	        console.log('about to call: ' + newArgs);
	      }
	      if (document.applets[0]) {
	        document.applets[0].molecularControlToolkit.apply(document.applets[0], newArgs);
	      }
	    }
	  })
	  return ret;
	}


	//see https://forums.oracle.com/message/5523095
	function activateApplet(attributes, parameters)
	{ 
		var intercepted = ''; 
		var got = document.write;
		document.write = function(arg){intercepted += arg;};
		deployJava.runApplet(attributes, parameters, '1.6');
		document.write = got;
		$(attachToDiv).html(intercepted);
	}


	AQUARIA.modelFinishedLoading = function() {
		console.log('model finished loading!');
		AQUARIA.panel3d.blankApplet(false);
		$("#wait").hide(); 
		// tweek for safari on mac. the sequence & annotation 3D hangs otherwise
		// setTimeout(function() {
		// 	AQUARIA.changeAppletSize();
		// }, 500);
	};

	AQUARIA.appletResiduesSelected = function() {
		console.log('residues selected');
	};

	this.blankApplet = function(isOn, message, clear) {
	  // AQUARIA.changeAppletSize();
		var name = "applet";
		var appletMessage = $('#waitingFrame').contents().find('#appletMessage');
		var clearMessage = typeof clear === 'undefined' ? true : clear;
		message = message || "Please wait...";
		
		if (isOn) {
			console.log("blanking " + name + " with message: " + message);
			if (clearMessage) {
				appletMessage.html(message);
			} else {
				appletMessage.html(appletMessage.html() + "<br>" + message);
			}
			if (!$('#waitingFrame').is(":visible")) {
				$('#waitingFrame').hide();
				$('#waitingFrame').fadeIn("fast");
			}
		}
		else {
			console.log("unblanking " + name);
			$('#waitingFrame').fadeOut("slow");
		}
	};
	

	this.generateAttributes = function(threeDWidth, threeDHeight, pdb_id, pdb_chain, biounit, source_primary_accession, sequences, common_names, pssh_alignment, links, transform, conservations, versionString) {

		var instanceIds = [];
		var sequencesText = [];
		var annotations = [];
		var accessionsUsed = {};
		$("#threeD").css("visibility", "visible");
		console.log('common_names: ' + common_names);
		for (var i in pdb_chain) {
			var primary_accession = sequences[i].primary_accession;
			var instanceId = primary_accession + '-' + pdb_id + '-' + pdb_chain[i];
			instanceIds.push(instanceId);
			if ( accessionsUsed[primary_accession]) {
				// already have annotations for this accession skip it!
			}
			else {
				accessionsUsed[primary_accession] = 1; 
				var sequenceText = primary_accession + ',' + common_names[i] + ',REFERENCE,' + sequences[i].sequence;
				sequencesText.push(sequenceText);

			}
		}
		var interactive = null;
		if (document.URL.indexOf('/leap') > -1) {
			interactive = 'leap';
		}
		var url = "https://files.rcsb.org/download/" + pdb_id + ".pdb.gz";
		if (biounit > 0) {
			url = "https://files.rcsb.org/download/" + pdb_id + ".pdb" + biounit + ".gz";
		}

		var attributes = {
				structures: 'structures{' + pdb_id + "," + url + ",," + transform + ";}", // NEED THIS
				width:threeDWidth, 
				height:threeDHeight,

				pdb_id: pdb_id,
				//      		source_primary_accession: source_primary_accession,
				interactive: 'leapjs',
				instanceId: instanceIds[0],
				sequenceAlignments: 'sequences{' + sequencesText.join(';') + '} matches{' + pssh_alignment +"}", // NEED THIS
				code:'Capture',  
				biounit: biounit,
				java_arguments: '-Dsun.java2d.noddraw=true',
				scriptable: 'false',
				cache_option:"plugin", 
				cache_archive:"aquaria-bundle.jar",
				cache_version:"0.1", 
				gl_swap_interval: '1',
				gl_debug: 'false',
				transform: transform,
				gl_trace: 'false',
				id: 'AquariaApplet',
				annotationView: 'on',
				toolbar: 'off',
				versionString: versionString,
				sequenceView: 'on',
				expertMode: 'on',
				defaultStyle: 'Homology', // NEED THIS
				// applet.links = 'SWISSPROT,SWS:http:wgetz?-id+PERMtest+-e+[swissprot-acc:###];PIR:http://pir.georgetown.edu:80/cgi-bin/nbrfget?xref=1&id=###';
		};
		if (annotations.length > 0) {
			attributes['annotations'] = annotations.join(' ');
		}

		console.log("ATTRIBUTES");
		for (var key in attributes) {
			console.log(key + '="' + attributes[key] +'"');
		}
		return attributes;
	};


	var oldWidth = $('#threeD').width();
	//changeAppletSize(oldWidth,570);



	function redrawSVG(wi) {
		if (wi != oldWidth) { 
			console.log("redrawing SVG to "+wi+ " wide");
			oldWidth = wi;  // keep track of width, so we don't redraw too often
			AQUARIA.refresh();


		}	
	}

	
	this.changeViewerSize = function(w, h) {

	  var threed = $("#threeDSpan");
	  var applet = $(threed).find("applet"); 
	  applet.css('width', w);
	  applet.css('height', h);
	  applet.attr('width', parseInt(w));
	  applet.attr('height', parseInt(h));
	  threed.css("width",  w);
	  threed.css("height",  h);
	}
};




module.exports = Applet3DPanel;

},{}],3:[function(require,module,exports){
//A collection of functions for Aquaria.ws - page initialisation functions are at the end of this file.
//These functions try to follow code conventions specified in http://javascript.crockford.com/code.html

window.AQUARIA = {};

var domready = require('domready');
var dnode = require('dnode');
var shoe = require('shoe');
var Applet3DPanel = require('./applet3DPanel');
var PV3DPanel = require('./pv3DPanel');
var JoleculePanel = require('./joleculePanel');
var IDRPanel = require('./IDRPanel');
var featurelist = require('./featurelist');
//var leapConnector = require('./leapConnector');
var molecularControlToolkitJS = require('molecular-control-toolkit-js');


//History 
var TopTen = require('./topten');
//var cache = require('../common/cache');
var ShowMatchingStructures = require('./show_matching_structures');
var fetch_das_annotations = require('./fetch_features');

var MAX_PROTEIN_HISTORY = 5;

//show_matching_structures.set(AQUARIA);
(function($) {
  // History

  var proteinSubmitListeners = [];
  var addProteinSubmitListener = function(listener) {
    proteinSubmitListeners.push(listener);
  };

  AQUARIA.fireProteinSubmitListeners = function(proteinName, primary_accession, pdb_id) {
    proteinSubmitListeners.forEach(function(listener) {
      listener.submitFired(proteinName, primary_accession, pdb_id);
      // if (proteinName !== "localhost") { listener.submitFired(proteinName, primary_accession); }
    });
  };

  var proteinTopTen = new TopTen("protein_top_ten", MAX_PROTEIN_HISTORY);
  addProteinSubmitListener(proteinTopTen);


  // Moved 2D structure rendering to separate file (show_matching_structures.js)
  // -- Christian
  //
  // Simple cache with automatic removal of oldest values.
  //
  // Authors: Sean O'Donoghue
  //
  var currentBiounit = 1;
  var initialised = false;
  var currentData = null;

  if (!window.console)
    console = {
      log: function() {}
    };
  try {
    function cache() {
      var cache = {};
      var last_access = {};
      var value;
      var size;
      var maximum_cache_size = 10;
      var oldest_key;
      var oldest_date;

      return function(key, callback) {
        last_access[key] = Date();

        if (key in cache && cache[key]) {
          // use cached value if available
          console.log('Read ' + key + ' from cache');
          return cache[key];
        } else {
          // get new value if not in cache
          value = callback(key);

          // store in cache
          cache[key] = value;
          console.log('AQUARIA.constructor stored ' + key + ' in cache (size = ' + size + ')');

          // if cache size is too large, remove oldest key
          size = Object.keys(cache).length;
          if (size > maximum_cache_size) {
            // find and delete oldest key
            oldest_date = last_access[key];
            for (key in cache) {
              console.log('AQUARIA.constructor checking key = ' + key);
              if (last_access[key] <= oldest_date) {
                console.log('AQUARIA.constructor key is older: ' + last_access[key]);
                oldest_key = key;
                oldest_date = last_access[key];
              }
            }
            console.log('AQUARIA.constructor final oldest key = ' + oldest_key);
            delete cache[oldest_key];
            delete last_access[oldest_key];
            console.log('AQUARIA.constructor deleted ' + oldest_key + ' from cache');
          }
          return value;
        }
      }
    }
  } catch (error) {
    alert('AQUARIA.constructor error with cache(): ' + error.message);
  }

  //
  // Display best structure (in 3D) and matching structures (in 2D)
  //
  // Authors: Sean O'Donoghue, Kenny Sabir
  //
  try {
    // Display 3D structure
    window.aquariaReady = function() {};

    var switcherText = '';
    if (window.threedViewer === 'applet') {
      switcherText = 'simple';
    } else if (window.threedViewer === 'webgl' || window.threedViewer === 'jolecule') {
      switcherText = 'detailed';
    }
    $("span#threedSwitcher a").attr('title', switcherText);
    $("span#threedSwitcher").click(function() {
      if (window.threedViewer === 'applet') {
        //window.threedViewer = 'webgl';
        window.threedViewer = 'jolecule';
      } else if (window.threedViewer === 'webgl' || window.threedViewer === 'jolecule') {
        window.threedViewer = 'applet';
      }
      localStorage.setItem("3DViewer", window.threedViewer);
      location.reload();
    });



    $('#biounitLeft').click(function() {
      currentBiounit = currentBiounit - 1;
      AQUARIA.display_3D_structure(currentData);
    });

    $('#biounitRight').click(function() {
      currentBiounit = currentBiounit + 1;
      AQUARIA.display_3D_structure(currentData);
    });

    /**
     * Asserts the transform to be a right-handed coordinate system.
     * @param transform	The transform as a string of the format "1:0:0:0:0:1:0:0:0:0:1:0"
     * @returns	A transform as a string of the format "1:0:0:0:0:1:0:0:0:0:1:0"
     */
    function assert_orientation(transform) {
      m = transform.split(":").map(function(c) {
        return parseFloat(c);
      });
      det = (m[0] * m[5] * m[10] + m[1] * m[6] * m[8] + m[2] * m[4] * m[9]) - (m[2] * m[5] * m[8] + m[1] * m[4] * m[10] + m[0] * m[6] * m[9]);
      if (det < 0) {
        // flip any one axis
        m[0] = -m[0];
        m[4] = -m[4];
        m[8] = -m[8];
      }

      return m.join(":");
    }

    AQUARIA.display_3D_structure = function(data, member) {
      currentData = data;
      AQUARIA.currentChain = data.pdb_chain; // might change in chainSelected!
      var alignment = data.alignment; // alignment of UniProt to 1 pdb chain
      // var features = data.uniprot_features; // features of the UniProt
      // sequence (SNPs etc)
      var pdb_chain = data.pdb_chain; // chain ID of displayed 3D structure
      var pdb_id = data.pdb_id; // ID of displayed 3D structure
      var sequences = data.sequences;
      var transform = assert_orientation(data.transforms[0]);
      var common_names = data.common_names;
      var biounits = data.biounits;
      var source_primary_accession = data.source_primary_accession;
      var conservations = data.conservations;
      if (pdb_id.match(/^\d\w\w\w$/)) {
        var threeDWidth = $("#threeD").width();
        var threeDHeight = threeDWidth;
        threeDHeight = $("#threeDSpan").innerHeight();
        if (threeDHeight < 570) {
          threeDHeight = 570;
        }
        // $("#threeD").html('');
        if (biounits == 0) {
          currentBiounit = 0;
        }
        var attributes = AQUARIA.panel3d.generateAttributes(threeDWidth, threeDHeight,
          pdb_id, pdb_chain, currentBiounit, source_primary_accession,
          sequences, common_names, alignment, '', transform, conservations, AQUARIA.structures2match.version_string);

        console.log('AQUARIA.display_3D_structure', AQUARIA.structures2match.Selected_PDB, pdb_id, pdb_chain[0], attributes)

        AQUARIA.remote.getPubMedForPDB(pdb_id, pdb_chain[0], function(pdbData) {
          if (biounits > 0 && typeof pdbData.Experimental_Method !== 'undefined' && pdbData.Experimental_Method !== null && pdbData.Experimental_Method.toLowerCase().indexOf('x-ray') > -1) {
            if (currentBiounit > biounits) {
              currentBiounit = 0;
            } else if (currentBiounit < 0) {
              currentBiounit = biounits;
            }
            if (currentBiounit === 0) {
              $('#biounitType').text('Asymmetric Unit');
              $('#biounitCount').hide();
            } else {
              $('#biounitType').text('Biological Assembly');
              if (biounits > 1) {
                $('#biounitCount').show();
              } else {
                $('#biounitCount').hide();
              }
            }
            $("#biounitDisplay").show();
            $("#biounitCount").text(currentBiounit + "/" + biounits);

            if (currentBiounit !== biounits) {
              $('#biounitRight').show();
            } else {
              $('#biounitRight').hide();
            }

            if (currentBiounit > 0) {
              $('#biounitLeft').show();
            } else {
              $('#biounitLeft').hide();
            }

          } else {
            $("#biounitDisplay").hide();
            currentBiounit = 0;
          }
          AQUARIA.pdb_data = pdbData;
          updatePDBPanel(pdbData, common_names[0], member.alignment_identity_score);

          //deselect feature tracks that may still be active
          d3.selectAll("svg.loaded rect.feature").attr("fill", "#a4abdf");
          d3.selectAll("svg.loaded").classed("loaded", false);

        });
        $("#jnlp_app_attributes").val(JSON.stringify(attributes));

        // $("#launchJalviewLink").click(function () {
        // console.log("Jalview on click executed: " +
        // top.frames['jalViewFrame'].loadJalviewApplet);
        // top.frames['jalViewFrame'].loadJalviewApplet(primary_accession,
        // attributes.pdb_id, uniprot_sequence, attributes.instanceId);
        // });
        if (window.hide3DViewer) {
          AQUARIA.panel3d.blankApplet(true, "Applet is not enabled for this browser. Launch Application instead.");
          AQUARIA.remote.createAppJNLP(attributes, function(jnlpLink) {
            $(".launchApplicationLink").attr('href', jnlpLink);
            $("#waitingFrame").contents().find(".launchApplicationLink").attr('href', jnlpLink);
          });

        } else {
          AQUARIA.remote.createAppJNLP(attributes, function(jnlpLink) {
            $(".launchApplicationLink").attr('href', jnlpLink);
          });

          var interactive = attributes['interactive'] ? '/' +
            attributes['interactive'] : '';
          var urlParams = window.location.search;
          history.pushState(null, sequences[0].primary_accession,
            window.location.protocol + '//' + window.location.host +
            "/" + sequences[0].primary_accession + "/" +
            pdb_id + "/" + pdb_chain[0] + urlParams);
          if (AQUARIA.panel3d.initialised) {
            AQUARIA.panel3d.reload(attributes);
          } else if (AQUARIA) {
            // first time
            AQUARIA.panel3d.load(attributes);
            // DISABLED: Connection to Leap Connector
            // if (AQUARIA.gesture) {
            //   AQUARIA.gesture.start();
            // }

          } else {
            console.log("AQUARIA.display_3D_structure Error: Cannot load the applet!");
            alert('Cannot load the Applet!');
          }
          // setup the leap motion link
          //					attributes['interactive'] = 'leap';
          //					AQUARIA.remote.createToolkitAppJNLP(attributes, function(jnlpLink) {
          //						$("#launchToolkitApplicationLink").attr('href', jnlpLink);
          //					});
          //					delete attributes['interactive'];
        }

      } else {
        console.log("AQUARIA.display_3D_structure Error: Invalid PDB identifier");
      }

    };

    AQUARIA.display_features = function(sequences) {

      var primary_accession = [];
      var uniprot_sequence_MD5_hash = [];

      sequences.forEach(function(sequence) {
        primary_accession.push(sequence.primary_accession);
        uniprot_sequence_MD5_hash.push(sequence.uniprot_hash);
      });
      console.log("AQUARIA.display_features new features", primary_accession);

      if (typeof(fetch_das_annotations) !== "undefined") {
        AQUARIA.blankPanel("#featurelist", true);
        startSpin();
        fetch_das_annotations(primary_accession,
          function(featureInfo) {
            featurelist.updateFeatureUI(featureInfo);
            AQUARIA.blankPanel("#featurelist", false);
            //console.log('the feature info is: ' + featureInfo);
          },
          function(sequenceInfo) {
            //					console.log('the sequence info is: ' + sequenceInfo);
          });
      } else {
        alert('Could not find fetch_das_annotations.');
      }

    };

    var startSpin = function() {

      //$("#featureExplanation").text(" for " + AQUARIA.preferred_protein_name);

      $("#featureCounter").show();
      $("#waitForFeatures").show();

    };

    AQUARIA.updateDocumentTitle = function(protein_name, score, pdbid, chain) {
      document.title = "Aquaria: " +
        protein_name + ", " + score +
        "% Sequence Identity to PDB " + pdbid + ", chain " + chain;
      featurelist.updateFeatureTabTitle(protein_name);
    };

    //updates the 3D viewer title
    // this is a hack and requires the function to be called once before the proper HTML code is being generated.
    //TODO move html code to home_page.ejs?
    AQUARIA.update3DTitle = function(accession, pdbId, chainId, molecule_name, score) {

      if (chainId && molecule_name) {

        var short_name = molecule_name;
        if (short_name.indexOf("(") != -1) {
          short_name = molecule_name.substring(0, molecule_name.indexOf("(")).trim();
        }

        AQUARIA.short_molecule_name = short_name;

        // if (accession && pdbId && score) {
        //   $("#structureviewerexplanation").html("<a id='accession_link' href='https://www.uniprot.org/uniprot/" + AQUARIA.protein_primary_accession + "' title='Go to UniProt'>" + AQUARIA.preferred_protein_name +
        //     "</a> sequence aligned onto <a href='/" + accession + "' title='View the structure for " + short_name + " in Aquaria'>" + short_name +
        //     "</a> structure from <a href='http://www.rcsb.org/pdb/explore.do?structureId=" + pdbId + "' title='Go to PDB'>PDB " + pdbId + "-" + chainId + "</a> (" + score +
        //     "% sequence identity)&nbsp;&nbsp;<a href='javascript:;'  data-intro='Model Quality' data-position='top'><span id='help3D' class='help roundButton'>&nbsp;</span></a>");

        //   var evalue = AQUARIA.currentMember.E_value; // e-value from pssh2
        //   $("#help3D").show().parent().attr("onmouseenter", "AQUARIA.explainTitle('" + accession + "','" + AQUARIA.preferred_protein_name + "','" + short_name + "','" + pdbId + "','" + chainId +
        //     "','" + score + "','" + evalue + "');");
        // } else { // DNA or RNA (no accession)
        //   $("#structureviewerexplanation").html(short_name + "</a> structure from <a href='http://www.rcsb.org/pdb/explore.do?structureId=" + pdbId + "' title='Go to PDB'>PDB " + pdbId + "-" +
        //     chainId + "</a> (" + score + "% sequence identity)");
        // }

        //NEBLINA's Scripts
        if (accession && pdbId && score) {
          $("#structureviewerexplanation").html("<a id='accession_link' title='About Uniprot ID'>" + AQUARIA.preferred_protein_name +
            "</a> sequence aligned onto <a href='/" + accession + "' title='View the structure for " + short_name + " in Aquaria'>" + short_name +
            "</a> structure from <a id='pdb_link' title='About PDB ID'>PDB " + pdbId + "-" + chainId + "</a> (" + score +
            "% sequence identity)&nbsp;&nbsp;<a href='javascript:;'  data-intro='Model Quality' data-position='top'><span id='help3D' class='help roundButton'>&nbsp;</span></a>");

          var evalue = AQUARIA.currentMember.E_value; // e-value from pssh2
          $("#help3D").show().parent().attr("onmouseenter", "AQUARIA.explainTitle('" + accession + "','" + AQUARIA.preferred_protein_name + "','" + short_name + "','" + pdbId + "','" + chainId +
            "','" + score + "','" + evalue + "');");

            if ($('#title3D').is(':visible')) {
              $('#accession_link').on('click', function () {
                if ($('#gallery').is(':visible')) {
                  $('#gallery').hide()
                  $('#searchByName').hide()
                  $('#uniprot').show()
                } else if ($('#uniprot').is(':visible')) {
                  $('#searchByName').show()
                  $('#uniprot').hide()
                } else {
                  $('#uniprot').show()
                  $('#searchByName').hide()
                }
              })
              $('#about_pdb').on('click', function () {
                if ($('#uniprot').is(':visible')) {
                  $('#uniprot').hide()
                  $('#searchByName').hide()
                  $('#gallery').show()
                } else if ($('#gallery').is(':visible')) {
                  $('#searchByName').show()
                  $('#gallery').hide()
                } else {
                  $('#gallery').show()
                  $('#searchByName').hide()
                }
              })
            }

        } else { // DNA or RNA (no accession)
          $("#structureviewerexplanation").html(short_name + "</a> structure from <a title='About PDB ID'>PDB " + pdbId + "-" +
            chainId + "</a> (" + score + "% sequence identity)");
        }

      } else {

        $("#accession_link").text(AQUARIA.preferred_protein_name);
        //$("#help3D").hide();

      }


    };

    AQUARIA.explainTitle = function(accession, uniprotName, pdbName, pdbId, chainId, score, evalue) {
      var precisiontxt, quality, qualClass, Log10E, evalueString;
      Log10E = -Math.log(evalue) / Math.LN10;
      var precision = (BioScience_PlantDisease_Weibull_model(Log10E) * 100);
      precision = Math.round(precision);
      console.log("AQUARIA.explainTitle -Log10e: " + Log10E + " precision: " + precision);
      evalueString = evalue.replace(/e(.*)$/, " &times <nobr>10<sup>$1</sup></nobr>");
      if (evalue == 0 && precision == 1) {
        precisiontxt = "close to 100";
      } else {
        precisiontxt = "&#8805; " + precision;
      }
      if (evalue > 10E-72) {
        quality = "in the twilight zone";
        qualClass = "twilight";
      } else {
        quality = "high quality";
        qualClass = "high";
      }
      var msgTxt = "<p>What you see in the 3D viewer is the experimentally-determined structure of " + pdbName + " from <a href='http://www.rcsb.org/pdb/explore.do?structureId=" + pdbId +
        "' target='_blank'>PDB entry " + pdbId + "</a>, chain " + chainId + ".</p>";
      msgTxt += "<p>The full-length sequence of the protein you specified (" + uniprotName + ") has been aligned onto the sequence used to determine this PDB structure.</p>";
      msgTxt += "Overall, the two sequences align with " + score + "% identity; any amino acid substitutions are indicated using dark coloring (see legend).</p>";
      msgTxt += "<p class='quality " + qualClass + "'>This alignment has an HHblits E-value of " + evalueString + ", which is considered to be " + quality +
        ". Based on cross-validation, the likelihood that your specified protein (" + uniprotName + ") adopts a structure similar to that shown is estimated to be " + precisiontxt + "%.</p>";
      msgTxt += "<p>Note that the structure shown is taken directly from the PDB; it has not been derived by ab-initio or comparative modeling.</p>";
      showBubble(msgTxt);
    };

    // To the best of my knowledge this code is correct.
    // If you find any errors or problems please contact
    // me directly using zunzun@zunzun.com.
    //
    //		      James

    function BioScience_PlantDisease_Weibull_model(x_in) {
      var temp;
      temp = 0.0;

      // coefficients
      var a = -2.9039350989124828E+00;
      var b = 7.9846661459228132E+00;
      var c = 4.4780238831200248E-01;

      temp = 1.0 - Math.exp(-1.0 * Math.pow((x_in - a) / b, c));
      return temp;
    }


    function showBubble(msgHtml) {

      $('body').append('<div class="dimmer" style="opacity: 0.08; -moz-opacity: 0.08;"></div>');
      $("span#help3D.roundButton").css("background-position", "0 -21px");
      $("div.dimmer").on("click", function() {
        $("div.popup, div.dimmer").fadeOut().remove();
        $("span#help3D.roundButton").css("background-position", "0 0");
      });

      var balloon = "<div class='balloon'><h3>3D View Explained<span class='x'>&nbsp;</span></h3>";

      balloon = balloon + msgHtml + "</div>";
      d3.select("body")
        .append("div")
        .attr("class", "popup top")
        .html(balloon);

      var popheight = $("div.popup").innerHeight();

      var fpos = $("#help3D").offset();

      var bleft = parseInt(fpos.left - 230);
      var btop = parseInt(fpos.top + 30);

      $("div.popup").css({
        "left": bleft + "px",
        "top": btop + "px"
      }).draggable().fadeIn(600);


      $("span.x").click(function() {
        $("div.popup, div.dimmer").fadeOut().remove();
        $("span#help3D.roundButton").css("background-position", "0 0");
      });
      /*
      $("div.popup").hover(function() {
      	clearTimeout(s);
      }, function() {
      	s = setTimeout(function() {
      		$("div.popup").fadeOut();
      	}, 500);
      });
      */
    }

    AQUARIA.refresh = function() {
      if (typeof AQUARIA.showMatchingStructures !== 'undefined') {
        AQUARIA.showMatchingStructures.refresh();
        featurelist.updateFeatureUI();
      }

    };

    AQUARIA.load3DAlignment = function(member, sequence) {
      //AQUARIA.e_value = member.E_value;
      AQUARIA.currentMember = member;
      AQUARIA.updateDocumentTitle(AQUARIA.preferred_protein_name,
        member.alignment_identity_score, member.pdb_id,
        member.pdb_chain[0]);

      startLogoSpin();

      //      History
      AQUARIA.fireProteinSubmitListeners(AQUARIA.preferred_protein_name, sequence.primary_accession, member.pdb_id);
      // if (AQUARIA.uniqueId !== [sequence.primary_accession, member.pdb_id, member.pdb_chain[0], currentBiounit].join('-')) {
      //   AQUARIA.panel3d.blankApplet(true, "Waiting for PDB...");
      //   AQUARIA.blankPanel("#vis", true);
      // }
      AQUARIA.panel3d.blankApplet(true, "Waiting for PDB...");
      AQUARIA.blankPanel("#featurelist", true);
      AQUARIA.blankPanel("#aboutPDB", true);
      //AQUARIA.blankPanel("#uniProtDesc", true);
      AQUARIA.remote.get_3D_alignment(member, sequence, function(newData) {
        currentBiounit = this.currentBiounit;
        console.log('AQUARIA.remote.get_3D_alignment', newData)
        AQUARIA.display_3D_structure(newData, member);

        AQUARIA.blankPanel("#vis", false);
        AQUARIA.blankPanel("#aboutPDB", false);
        AQUARIA.blankPanel("#uniProtDesc", false);
        AQUARIA.blankPanel("#featurelist", false);
        stopLogoSpin();
      });
    };

    
    // Retrieve matching structures from server or local cache
    var cache_matching_structures = cache();

    AQUARIA.display_member = function(selectedMember) {
      var data = AQUARIA.structures2match;
      // matching structures finished
      if (data.clusters && data.clusters.length > 0) {
        if (typeof selectedMember === 'undefined') {
          selectedMember = data.clusters[data.Selected_PDB.cluster_number].members[data.Selected_PDB.member_number];
        }
        AQUARIA.member = selectedMember;

        AQUARIA.load3DAlignment(selectedMember, data.sequences[0]);
      } else {
        if (typeof data.pdb_id === 'undefined') {
          AQUARIA.blankAll(true);
          //					AQUARIA.blankPanel("#aboutPDB", true);
          updateUniprotInfo(null);
          //					AQUARIA.blankPanel("#uniProtDesc", true);
          AQUARIA.showMatchingStructures.removeAll();
          //					AQUARIA.blankPanel("#vis", true);
        } else {
          AQUARIA.blankAll(true, "Cannot find protein.");
          //					AQUARIA.blankPanel("#aboutPDB", false);
          updateUniprotInfo(null);
          //					AQUARIA.blankPanel("#uniProtDesc", true);
          AQUARIA.showMatchingStructures.removeAll();
          //					AQUARIA.blankPanel("#vis", true, "Cannot find matching structures.");
        }
        console.log("AQUARIA.display_member error: cannot find matching structures.");
      }

    };
    var sequenceCallback = function(loadRequest, sequences) {
      // matching structures added found the sequence! This is the first
      // callback
      //			console.log('got sequences:' + sequences);
      if (loadRequest.primary_accession === AQUARIA.structures2match.initialLoadRequest.primary_accession) {
        AQUARIA.structures2match.sequences = sequences;
        // Somewhere here, we inappropriately clear the
        // matching structures before they are loaded
        console.log('AQUARIA.sequenceCallback initialise matching structures')
        AQUARIA.showMatchingStructures.initialise(sequences[0]);
        AQUARIA.blankPanel('#vis', true, 'Loading clusters...')
        console.log('AQUARIA.sequenceCallback update Uniprot')
        updateUniprotInfo(sequences[0]);
        console.log('AQUARIA.sequenceCallback display features')
        AQUARIA.display_features(sequences);
      } else {
        console.log('AQUARIA.sequenceCallback error: received old data for sequence callback: ' + loadRequest.primary_accession + ', which does not match requested: ' + AQUARIA.structures2match.initialLoadRequest.primary_accession);
      }
    };

    var clusterCallback = function(loadRequest, newClusters) {
      AQUARIA.structures2match.clusters = AQUARIA.structures2match.clusters.concat(newClusters);
      //			console.log('got newcluster:' + newCluster);
      // matching structures added a new cluster, lets draw it!
      // for each doesn't work on these wierd dnode arrays
      var i;
      if (loadRequest.primary_accession === AQUARIA.structures2match.initialLoadRequest.primary_accession) {

        for (i = 0; i < newClusters.length; i++) {
          AQUARIA.showMatchingStructures.addCluster(newClusters[i]);
        }
      } else {
        console.log('AQUARIA.clusterCallback error: received old data for cluster callback: ' + loadRequest.primary_accession + ', which does not match requested: ' + AQUARIA.structures2match.initialLoadRequest.primary_accession);
      }
    };


    var isLoadRequestsEqual = function(primary_accession) {
      var isEqual = false;

      if (typeof AQUARIA.structures2match !== 'undefined' && typeof AQUARIA.structures2match.initialLoadRequest !== 'undefined') {

        if (primary_accession instanceof Array && AQUARIA.structures2match.initialLoadRequest.selector instanceof Array) {
          if (primary_accession.length === AQUARIA.structures2match.initialLoadRequest.selector.length) {
            var i;
            isEqual = true;
            for (i = 0; i < primary_accession.length; i++) {
              if (primary_accession[i] !== AQUARIA.structures2match.initialLoadRequest.selector[i]) {
                isEqual = false;
                break;
              }
            }
          }
        }
      }
      return isEqual;

    };

    var onTextClick = function(d, cluster) {
      return expand_cluster(d, cluster, AQUARIA.structures2match.sequences[0]);
    };

    var loadAndUpdateHistory = function() {
      uniprot_accession = [];
      uniprot_accession.push(accessionObject.Accession);

      AQUARIA.loadAccession(uniprot_accession, null, null, false, uniprot_accession);

    }

    AQUARIA.loadAccession = function(primary_accession, autoSelectPDB,
      autoSelectChain, skip3DView, preferredProteinName) {
      preferredProteinName = preferredProteinName || "unknown";
      skip3DView = skip3DView || false;

      if (primary_accession === null) {
        //TODO here we want to revert to the initial state, e.g. no structure in the viewer
        AQUARIA.blankAll(true);
        AQUARIA.structures2match = {};
        AQUARIA.blankCount = {};
        delete AQUARIA.preferred_protein_name;
        return;
      }

      if (isLoadRequestsEqual(primary_accession)) {
        AQUARIA.blankAll(false);
        console.log('AQUARIA.loadAccession skipping: already loaded', primary_accession)
        return;
      }
      console.log('AQUARIA.loadAccession load', primary_accession)

      pdbParam = autoSelectPDB ? "/" + autoSelectPDB : "";
      var urlParams = window.location.search;
      history.pushState(primary_accession, document.title, '/' +
        primary_accession + pdbParam + urlParams);


      AQUARIA.blankPanel("#vis", true);
      AQUARIA.blankPanel("#uniProtDesc", true);

      AQUARIA.preferred_protein_name = preferredProteinName;
      AQUARIA.protein_primary_accession = primary_accession;

      //TODO this is currently being called again once the
      // structures come back (in updateUniprotInfo), but
      // is required to be called now in order to make sure
      // that AQUARIA.preferred_protein_name is being set.
      fetchSynonyms(primary_accession);

      AQUARIA.showMatchingStructures = new ShowMatchingStructures(onTextClick);

      var loadRequest = {
        selector: primary_accession,
        selectPDB: autoSelectPDB,
        selectChain: autoSelectChain
      };
      AQUARIA.structures2match = {
        initialLoadRequest: loadRequest,
        clusters: [],
        sequences: [],
        source_primary_accession: primary_accession
      };

      cache_matching_structures(primary_accession, function(primary_accession) {
        AQUARIA.remote.get_matching_structures(loadRequest, sequenceCallback, clusterCallback, function(err, loadRequest, Selected_PDB, finalClusters, cachedHit, version_string) {
          if (loadRequest.primary_accession === AQUARIA.structures2match.initialLoadRequest.primary_accession) {
            //					  AQUARIA.updateIssueEnvironment();

            if (typeof err !== undefined && err !== null) {
              if (skip3DView && err.name === "MatchingStructuresError") {
                AQUARIA.blankPanel("#vis", true, err.message);
              } else {
                AQUARIA.blankAll(true, err.message, false);
              }
            } else {
              if (finalClusters) {
                if (cachedHit) {
                  // cached hit doesn't call the callback (to avoid packet out of order), so call it manually
                  clusterCallback(loadRequest, finalClusters);
                } else {
                  AQUARIA.structures2match.clusters = finalClusters;
                }
              }

              AQUARIA.showMatchingStructures.updateSizes(AQUARIA.structures2match.clusters);
              AQUARIA.blankPanel("#vis", false);

              AQUARIA.structures2match.Selected_PDB = Selected_PDB;
              console.log('AQUARIA.cache_matching_structures applet version: ' + version_string, Selected_PDB
                );
              AQUARIA.structures2match.version_string = version_string;
              var clusterNumber = Selected_PDB.cluster_number;
              var cluster = AQUARIA.structures2match.clusters[clusterNumber];
              AQUARIA.showMatchingStructures.selectCluster(cluster,
                clusterNumber);

              if (!skip3DView) {
                if (window.threedView === 'IDR') {
                  var threeDWidth = $("#threeD").width();
                  var threeDHeight = threeDWidth;
                  threeDHeight = $("#threeDSpan").innerHeight();
                  if (threeDHeight < 570) {
                    threeDHeight = 570;
                  }
                  AQUARIA.panel3d.display_cluster(cluster, threeDWidth, threeDHeight);
                }
                AQUARIA.display_member();
              }

            }
          } else {
            console.log('AQUARIA.loadAccession error: received old data for Best PDB: ' + loadRequest.primary_accession + ', which does not match requested: ' + AQUARIA.structures2match.initialLoadRequest.primary_accession);
          }

        });
      });
    };

  } catch (error) {
    alert('Error with displaying structures: ' + error.message);
  }

  //
  // Functions to run immediately after home page DOM first finishes loading.
  //
  // Authors: Sean O'Donoghue, Kenny Sabir, Christian Stolte, Nelson Pereira, Julian Heinrich
  //

  AQUARIA.initialisePanels = function(hasUrl) {

    hasUrl = (typeof hasUrl === 'undefined') ? false : hasUrl;

    // expand and collapse UI panels
    $("div.panel.collapsible h3").click(function() {
      $(this).next("span").slideToggle(300);
      $(this).parent().toggleClass("closed");
    });
    // search tabs
    $("#tabs").tabs({
      active: 0
    }).buttonset();

    // structures/interactions/features
    $("h3.sub").click(function() {
      var panel = $(this).attr("rel"); // console.log("turning on
      // "+panel);
      $("h3.sub").addClass("inactive");
      $(this).toggleClass("inactive");
      $(".toggled").hide();
      $("#" + panel + ".toggled").toggle();
    });
    // highlight percentage sequence identity when hovering over
    // matching structure
    $(".outer_container").hover(function() {
      $(this).next("text").attr("fill", "#333");
    }, function() {
      $(this).next("text").attr("fill", "#777");
    });

    // // expand and collapse UI panels
    // $("div.panel.collapsible h3").click(function() {
    //   $(this).next("span").slideToggle(300);
    //   $(this).parent().toggleClass("closed");
    // });
    // // search tabs
    // $("#tabs").tabs({
    //   active: 0
    // }).buttonset();
    //
    // // structures/interactions/features
    // $("h3.sub").click(function() {
    //   var panel = $(this).attr("rel"); // console.log("turning on
    //   // "+panel);
    //   $("h3.sub").addClass("inactive");
    //   $(this).toggleClass("inactive");
    //   $(".toggled").hide();
    //   $("#" + panel + ".toggled").toggle();
    // });
    // // highlight percentage sequence identity when hovering over
    // // matching structure
    // $(".outer_container").hover(function() {
    //   $(this).next("text").attr("fill", "#333");
    // }, function() {
    //   $(this).next("text").attr("fill", "#777");
    // });

    $(".resizable").resizable({
      handles: "s",
      distance: 30
    });
    //$("div#psyns").html("<p>(example: <a href=\"javascript:fillin('BLK');\">BLK</a> or <a href=\"javascript:fillin('P51451');\">P51451</a>)</p>");

    // set preferred organism and synonyms, default to human (9606)
    // organism_id is used to get synonyms, preferred name is what the user
    // typed in the search field (e.g. human vs. homo sapiens)

    if (localStorage.organism_id == undefined) {
      localStorage.organism_id = 9606; // default
    }

    if (localStorage.preferred_organism_name == undefined) {
      localStorage.preferred_organism_name = "Human"; // default
    }

    if (!hasUrl) {
      AQUARIA.remote.getOrganismSynonyms([{
        "organism_id": localStorage.organism_id
      }], displayOrgSynonyms);
    }

    // set up autocomplete for organism names
    var cache_organism_synonyms = {};
    $("#organism_syn_input").autocomplete({
      source: function(request, response) {
        var labelValues;
        var term = request.term;
        if (term in cache_organism_synonyms) {
          response(cache_organism_synonyms[term]);
          return;
        };
        startLogoSpin();
        AQUARIA.remote.queryOrganism(term, function(data) {
          stopLogoSpin();
          if (data.length > 0) {

            labelValues = $.map(data, function(item) {
              return {
                label: item.Synonym,
                value: item.Synonym,
                id: item.Organism_ID
              };
            });

            cache_organism_synonyms[term] = labelValues;
          } else {
            labelValues = {
              label: "No organisms for: " + term,
              value: 0
            };
          }
          response(labelValues);
        });
      },
      //focus : function() {
      //AQUARIA.blankAll(true);
      //},
      close: function(event, ui) {
        if (event.handleObj.type === 'menuselect') { // user selected an item
          // handled in select()
        } else if (event.handleObj.type === 'keydown' && event.keyCode === $.ui.keyCode.ESCAPE) { // user escaped
          $(this).val("");
          AQUARIA.blankAll(false);
        }
      },
      minLength: 1,
      delay: 100,
      mustMatch: true,
      autoFocus: true,
      // still to add: an 'autoFill function - See
      // http://www.pengoworks.com/workshop/jquery/autocomplete.htm
      // focus: function autoFill(event, ui){
      // if the last user key pressed was backspace, don't
      // autofill
      // if( lastKeyPressCode != 8 ){
      // // fill in the value (keep the case the user has typed)
      // $input.val($input.val() + sValue.substring(prev.length));
      // // select the portion of the value not typed by the user
      // (so the next character will erase)
      // createSelection(prev.length, ui.item.value.length);
      // }
      // };
      // should use syntax like below
      // focus: function(event, ui) {
      // var:
      // $('#organism_syn_input').val(ui.item.value);
      // },
      select: function(event, ui) {
        if (ui.item.value &&
          ui.item.value.indexOf("No organisms for: ") !== 0) {
          if (ui.item.id !== localStorage.organism_id) {
            AQUARIA.remote.getOrganismSynonyms([{
              "organism_id": ui.item.id
            }], function(orgNames) {
              localStorage.organism_id = ui.item.id;
              localStorage.preferred_organism_name = ui.item.value;
              displayOrgSynonyms(orgNames);
            });

            AQUARIA.loadAccession(null);
            $("#protein_syn_input").focus();
          }
        } else {
          event.preventDefault();
        }
      }
    }).on('focus', function() {
      $("#organism_syn_input").val(localStorage.preferred_organism_name);
      AQUARIA.blankAll(true, "Please specify an organism.");
      //					$(this).autocomplete("search");
      $(this).select();
    }).on('input', function() {
      AQUARIA.blankAll(true, "Please specify an organism.");
    });

    //		$("#organism_syn_input").autocomplete();
    // set up autocomplete for protein names
    var cache_protein_synonyms = {};

    /*
     * //History // get last input from localStorage $(
     * "#protein_syn_input" ).focus( function(){
     * $(this).autocomplete({ source: proteinTopTen.getTop(),
     * minLength:0, delay:0 }) });
     */

    $.widget("custom.catcomplete", $.ui.autocomplete, {
      _create: function() {
        this._super();
        this.widget().menu("option", "items", "> :not(.ui-autocomplete-category)");
      },
      _renderMenu: function(ul, items) {
        var that = this,
          currentCategory = "";
        $.each(items, function(index, item) {
          var li;
          if (item.category && item.category != currentCategory) {
            ul.append("<li class='ui-autocomplete-category'>" + item.category + "</li>");
            currentCategory = item.category;
          }
          li = that._renderItemData(ul, item);
          if (item.category) {
            li.attr("aria-label", item.category + " : " + item.label);
          }
        });
      },
      _renderItem: function(ul, item) {
        var label = item.label;
        if (item.suffix) {
          label += ' <span class="auto_complete_identifier">(' + item.suffix + ")</span>";
        }
        return $("<li>")
          .append("<a>" + label + "</a>")
          .appendTo(ul)
      }
    });
    var proteinAutocomplete = $("#protein_syn_input");
    proteinAutocomplete.catcomplete({
      source: function(request, response) {
        var term = request.term;

        var getLRU = function() {
          return proteinTopTen.getAll().map(function(item) {
            return {
              label: item.name,
              suffix: item.primary_accession + ", " + item.pdb_id,
              value: item.name,
              type: 'LRU',
              category: 'Recent',
              id: item.primary_accession + "/" + item.pdb_id
            }
          })
        }

        var callbackData = {
          names: [],
          ids: [],
          pdbIDs: [],
          LRU: getLRU()
        }

        var collectResponse = function() {
          var lruMatches = callbackData.LRU;
          if (lruMatches.length > 0 && term && term.length > 0) {
            lruMatches = lruMatches.filter(function(val) {
              return val.label.toLowerCase().startsWith(term.toLowerCase());
            });
          }
          var showPopup = true;
          var allValues = lruMatches.concat(callbackData.names).concat(callbackData.ids).concat(callbackData.pdbIDs);
          if (allValues.length === 0) {
            if (term && term.length > 0) {

              allValues = [{
                label: "No structures for: " + term,
                value: 0
              }];
            } else {
              showPopup = false;
            }
          }
          console.log('AQUARIA.proteinAutocomplete received', allValues)
          cache_protein_synonyms[protein_synonym_plus_organism_id] = allValues;
          if (showPopup) {
            response(allValues);
          }

        }

        console.log('AQUARIA.proteinAutocomplete searching "' + term + '"')

        if (term == "") {
          collectResponse();
          // History
          /*
          		 console.log("focussed: "+proteinTopTen.getTop());
          		 labelValues = $.map(proteinTopTen.getTop(),
          		 function (item) { return { label: item.name,
          		 value: item.name, id: item.primary_accession };
          		 }); response(labelValues);
           */
          //AQUARIA.blankAll(true);
        } else {
          var protein_synonym_plus_organism_id = term + '%' +
            localStorage.organism_id;
          if (protein_synonym_plus_organism_id in cache_protein_synonyms) {
            response(cache_protein_synonyms[protein_synonym_plus_organism_id]);
            return;
          };
          startLogoSpin();


          AQUARIA.remote
            .queryProtein(
              term,
              localStorage.organism_id,
              function(nameData) {
                var labelValues;
                stopLogoSpin();
                labelValues = $.map(nameData,
                  function(item) {
                    return {
                      label: item.Synonym,
                      suffix: null,
                      value: item.Synonym,
                      type: 'Synonym',
                      category: "Names",
                      id: item.Primary_Accession
                    };
                  });
                labelValues.sort(function(a, b) {
                  return a.label > b.label ? 1 : -1;
                });
                labelValues.reduce(function(previous, current) {
                  var a = previous;
                  var b = current;
                  if (a && a.value === b.value) {
                    if (a.dup) {} else {
                      a.suffix = a.id,

                        a.dup = true;
                    }
                    if (b.dup) {} else {
                      b.suffix = b.id,
                        b.dup = true;
                    }
                  }
                  return current;
                }, null);
                callbackData.names = labelValues;
                collectResponse();
              },
              function(idData) {
                var labelValues;
                stopLogoSpin();
                labelValues = $.map(idData,
                  function(item) {
                    var suffix = item.Source_Field;
                    if (suffix === 'AC' || suffix === 'ID') {
                      suffix = 'UniProt';
                    }
                    return {
                      label: item.Synonym,
                      suffix: suffix,
                      value: item.Synonym,
                      type: suffix,
                      category: "Identifiers",
                      id: item.Primary_Accession
                    };
                  });
                labelValues.sort(function(a, b) {
                  return a.label > b.label ? 1 : -1;
                });
                //                    labelValues.reduce(function (previous, current) {
                //                      var a = previous;
                //                      var b = current;
                //                      if (a && a.value === b.value) {
                //                        if (a.dup) {} else {
                //                          a.suffix = a.id,
                //
                //                          a.dup = true;
                //                        }
                //                        if (b.dup) {} else {
                //                          b.suffix = b.id,
                //                          b.dup = true;
                //                        }
                //                      }
                //                      return current;
                //                    }, null);
                callbackData.ids = labelValues;
                collectResponse();
              },
              function(pdbData) {
                var labelValues;
                stopLogoSpin();
                labelValues = $.map(pdbData,
                  function(item) {
                    return {
                      label: item.Synonym,
                      suffix: 'PDB',
                      type: 'PDB',
                      value: item.Synonym,
                      category: item.Category,
                      id: item.Synonym
                    };
                  });
                callbackData.pdbIDs = labelValues;
                collectResponse();
              });

        }
      },

      close: function(event, ui) {
        if (event.handleObj.type === 'menuselect') { // user selected an item
          // handled in select()
        } else if (event.handleObj.type === 'keydown' && event.keyCode === $.ui.keyCode.ESCAPE) { // user escaped
          $("#organism_syn_input").val("");
          if (typeof AQUARIA.structures2match.Selected_PDB === 'undefined') { // no structure loaded yet, keep panels blanked
            AQUARIA.blankAll(true);
          } else {
            AQUARIA.blankAll(false);
          }
        }
        $(this).val("");
      },
      //focus : function() {
      //AQUARIA.blankAll(true);
      //},
      /*
      		search : function(event, ui) {
      			if ($(this).val().length > 0) {
      				AQUARIA.blankAll(true);
      			} else {
      				AQUARIA.blankAll(false);
      			}
      		},
       */
      minLength: 0,
      autoFocus: true,
      delay: 300,
      // user has selected an item from the autocomplete list
      select: function(event, ui) {
        if (ui.item.value &&
          ui.item.value.indexOf("No structures for: ") !== 0) {
          var primaryAccession = ui.item.id;
          var pdb_id = null;
          if (primaryAccession.indexOf('/') > -1) {
            var parts = primaryAccession.split('/');
            primaryAccession = parts[0];
            pdb_id = parts[1];
          }
          if (ui.item.type === 'PDB') {
            console.log('AQUARIA.proteinAutocomplete.select pdb', ui.item.value);
            AQUARIA.blankAll(true, "Waiting for data...");
            var chain = null;
            AQUARIA.remote.getAccessionForPDB(ui.item.value, chain, function(accessionObject) {
              AQUARIA.loadAccession([accessionObject.Accession], ui.item.value, null, false, accessionObject.Accession);

            })
          } else if (ui.item.id == AQUARIA.protein_primary_accession) {

            if (ui.item.value == AQUARIA.preferred_protein_name) {
              AQUARIA.blankAll(false);
              // do nothing
              return;
            } else {
              console.log('AQUARIA.proteinAutocomplete.select same protein, different name', ui.item.value);

              AQUARIA.preferred_protein_name = ui.item.value;
              AQUARIA.remote.getProteinSynonyms(AQUARIA.protein_primary_accession, localStorage.organism_id, displayProtSynonyms, null);
              AQUARIA.update3DTitle(AQUARIA.structures2match.source_primary_accession,
                currentData.pdb_id, AQUARIA.currentChain, AQUARIA.molecule_name, AQUARIA.currentMember.alignment_identity_score);
              AQUARIA.updateDocumentTitle(AQUARIA.currentMember.alignment_identity_score, currentData.pdb_id, AQUARIA.currentChain);
              featurelist.updateFeatureTabTitle(AQUARIA.preferred_protein_name);
            }
          } else {
            console.log('AQUARIA.proteinAutocomplete.select new protein', ui.item.value);
            AQUARIA.blankAll(true, "Waiting for data...");
            AQUARIA.loadAccession([primaryAccession], pdb_id, null, false, ui.item.value);
          }


          $("#organism_syn_input").val("");
          $(this).val("");



        } else {
          event.preventDefault();
        }
      }
    }).on('input', function(event) {
      if ($(this).val().length > 0 || typeof AQUARIA.structures2match.Selected_PDB === 'undefined') {
        AQUARIA.blankAll(true);
        $("#organism_syn_input").val(localStorage.preferred_organism_name);
      } else {
        AQUARIA.blankAll(false);
      }

    }).on('focus', function() { // blank on initial focus
      if ($(this).val().length > 0 || typeof AQUARIA.structures2match.Selected_PDB === 'undefined') {
        AQUARIA.blankAll(true);
      }
      $(this).data('customCatcomplete').search('');
    });

    //		proteinAutocomplete.on('focus', );
    if (!hasUrl) {
      $("#protein_syn_input").focus();
    }

    // Aquaria page view model
    /* NOT USED ? 
    var ViewModel = function(protein_syn, organism_syn, organism) {
    	this.protein_synonym = ko.observable('', {
    		persist : 'protein_synonym'
    	});
    	this.organism_synonym = ko.observable('Human', {
    		persist : 'organism_synonym'
    	});
    	this.organism_id = ko.observable('9606', {
    		persist : 'organism_id'
    	});
    };
    // ko.applyBindings(new ViewModel()); // This makes Knockout get
    // to work
     */

  }; /* AQUARIA.initialisePanels() */


  //
  // Functions to run the first time the nowjs socket connection is ready.
  //
  //

  var remoteSuccess = function(remote) {
    AQUARIA.remote = remote;
    if (initialised) {
      console.debug("domready.ready called again!");
      return;
    }

    console.log("AQUARIA.remoteSuccess socket connection is ready");

    initialised = true;

    if (!window.console)
      console = {
        log: function() {}
      };
    var uniprot_accession;
    // when 'now' socket is ready, fetch structures if URL specifies
    // a Primary_Accession
    var pathname = document.URL.split('?')[0];
    if (typeof window.initialParams !== 'undefined') {
      AQUARIA.initialisePanels(true);
      uniprot_accession = [];
      uniprot_accession.push(window.initialParams.primary_accession);
      AQUARIA.loadAccession(uniprot_accession, window.initialParams.pdb_id, window.initialParams.pdb_chain);
    } else if (pathname
      .match(/\/(?:leap\/)?([A-Z][0-9][A-Z,0-9][A-Z,0-9][A-Z,0-9][0-9])\/?$/)) {
      uniprot_accession = [];
      uniprot_accession.push(RegExp.$1);
      AQUARIA.initialisePanels(true);
      AQUARIA.blankAll(true, "Waiting for data...")
      AQUARIA.loadAccession(uniprot_accession);
    } else if (pathname
      .match(/\/(?:leap\/)?([a-zA-Z0-9]{30,})\/?$/)) {
      uniprot_accession = RegExp.$1;
      AQUARIA.initialisePanels(true);
      AQUARIA.blankAll(true, "Waiting for data...")
      AQUARIA.loadAccession(uniprot_accession);
      // primary accession and pdb
    } else if (pathname
      .match(/\/(?:leap\/)?([A-Z][0-9][A-Z,0-9][A-Z,0-9][A-Z,0-9][0-9])\/([0-9]([a-z,0-9][a-z,0-9])[a-z,0-9])\/?$/)) {
      uniprot_accession = [];
      uniprot_accession.push(RegExp.$1);
      var pdb = RegExp.$2;
      AQUARIA.initialisePanels(true);
      AQUARIA.blankAll(true, "Waiting for data...")
      AQUARIA.loadAccession(uniprot_accession, pdb);
      // primary accession and pdb and chain
    } else if (pathname
      .match(/\/(?:leap\/)?([A-Z][0-9][A-Z,0-9][A-Z,0-9][A-Z,0-9][0-9])\/([0-9]([a-z,0-9][a-z,0-9])[a-z,0-9])\/([a-zA-Z,0-9])?$/)) {
      uniprot_accession = [];
      uniprot_accession.push(RegExp.$1);
      var pdb = RegExp.$2;
      var chain = RegExp.$4;
      console.log('AQUARIA.remoteSuccess inside chain selection');
      AQUARIA.initialisePanels(true);
      AQUARIA.blankAll(true, "Waiting for data...")
      AQUARIA
        .loadAccession(uniprot_accession, pdb, chain);
    } else if (pathname.match(/\/([A-Za-z]+)/)) {
      //uniprot_accession = RegExp.$1;
      // History: 
      // [JH] matches the URL and tries to load it as accession
      // not sure if we need this for the history in the search box?
      //AQUARIA.loadAccession(uniprot_accession);
      AQUARIA.initialisePanels(false);
    } else {
      AQUARIA.initialisePanels(false);
    }


  };

  var setupDNode = function() {
    var url = window.location.protocol + '//' + window.location.hostname + ':8010/dnode'
    var stream = shoe(url)
    try {
      var dnodeConnection = dnode();
      dnodeConnection.on('end', function(end) {
        console.log("AQUARIA.setupDNode dnodeConnection LOST!");
        setTimeout(setupDNode, 1000);
      });
      dnodeConnection.on('error', function(end) {
        console.log("AQUARIA.setupDNode dnodeConnection ERROR! Will retry in 1 second. " + end);
        setTimeout(setupDNode, 1000);
      });
      dnodeConnection
        .on(
          'remote', remoteSuccess
        );
      dnodeConnection.pipe(stream).pipe(dnodeConnection);
    } catch (error) {
      alert('AQUARIA.setupDNode error: setting up dnode.ready(). Will retry in 10 seconds: ' + error.message);
      setTimeout(setupDNode, 10000);
    }

  }

  domready(function() {
    if (window.threedViewer === 'applet') {
      AQUARIA.panel3d = new Applet3DPanel('#threeDSpan');
    } else if (window.threedViewer === 'jolecule') {
      AQUARIA.panel3d = new JoleculePanel('#threeDSpan', AQUARIA.chainSelected);
      console.log("THIS WORK: AQUARIA.JS 1", AQUARIA.panel3d);
    } else if (window.threedViewer === 'webgl') {
      AQUARIA.panel3d = new PV3DPanel('#threeDSpan');
    } else if (window.threedViewer === 'idr') {
      AQUARIA.panel3d = new IDRPanel('#threeDSpan');
    } else {
      console.log('AQUARIA.domready cannot find viewer: ' + window.threedViewer);
    }
    AQUARIA.gesture = new molecularControlToolkitJS.leap(AQUARIA.panel3d.gestures());

    setupDNode();
  });

})(jQuery);
AQUARIA.margin = {
  top: 10,
  right: 20,
  bottom: 20,
  left: 10
};

AQUARIA.launchURL = function(url) {
  window.open(url, '_blank');
};

AQUARIA.chainSelected = function(primaryAccession, pdbId, chainId) {
  console.log('AQUARIA.chainSelected ' + primaryAccession + ', for pdb chain: ' +
    pdbId + ":" + chainId);
  uniprot_accession = [];
  uniprot_accession.push(primaryAccession);
  AQUARIA.currentChain = chainId;

  // TODO THis shouldn't call load Accession because that loads everything as if it is the first time.
  // in this case, we just want to load matching structures and the protein, and leave the 3d context.
  AQUARIA.loadAccession(uniprot_accession, pdbId, chainId, true);

  if ("pdb_data" in AQUARIA) {
    updatePDBChain(pdbId, chainId, AQUARIA.currentMember.alignment_identity_score, AQUARIA.pdb_data.Organism[primaryAccession]);
  }
};

AQUARIA.structures2match = {};
AQUARIA.blankCount = {};
AQUARIA.currentMember = null;


AQUARIA.blankPanel = function(panel, isOn, message) {
  var name = panel + ' .blank';

  if (isOn) {
    if ($(name).length === 0) {
      console.log("AQUARIA.blankPanel " + panel + ": " + isOn);
      if (message) {
        $(panel).append(
          '<div class="blank hidden"><br><p class="centered">' + message +
          '</p></div>');

      } else {
        $(panel).append('<div class="blank hidden"></div>');
      }
      $(name).fadeIn("fast");
      $(name).css('height', $(panel).css('height'));
    }
  } else {
    console.log("AQUARIA.blankPanel " + panel + ": " + isOn);
    $(name).fadeOut("slow", function(obj) {
      $(name).remove();
    });
  }

};

AQUARIA.blankAll = function(isOn, message) {
  console.log("AQUARIA.blankAll", isOn, message);
  var messageDisplay = message || "Please specify a " + localStorage.preferred_organism_name + " protein.<br><br>Or, specify a new default organism.";
  AQUARIA.panel3d.blankApplet(isOn, messageDisplay);
  AQUARIA.blankPanel("#vis", isOn);
  AQUARIA.blankPanel("#aboutPDB", isOn);
  AQUARIA.blankPanel("#uniProtDesc", isOn);
  AQUARIA.blankPanel("#featurelist", isOn);
};

window.ATL_JQ_PAGE_PROPS = {
  //  window.ATL_JQ_PAGE_PROPS = $.extend(window.ATL_JQ_PAGE_PROPS, {
  '0add5080': {
    "triggerFunction": function(showCollectorDialog) {
      //Requries that jQuery is available! 
      jQuery("#issuesButton").click(function(e) {
        e.preventDefault();
        showCollectorDialog();
      });
    },
    environment: function() {
      var version = window.AQUARIA.structures2match ? window.AQUARIA.structures2match.version_string : 'unknown';
      return {
        'Applet Version': "" + version,
        'Location': window.location.href
      };
    }

  },
  '5ee9f010': {
    "triggerFunction": function(showCollectorDialog) {
      //Requries that jQuery is available! 
      jQuery("#feedbackButton").click(function(e) {
        e.preventDefault();
        showCollectorDialog();
      });
    }
  }
};
//};
},{"./IDRPanel":1,"./applet3DPanel":2,"./featurelist":5,"./fetch_features":7,"./joleculePanel":11,"./pv3DPanel":14,"./show_matching_structures":15,"./topten":16,"dnode":93,"domready":95,"molecular-control-toolkit-js":126,"shoe":139}],4:[function(require,module,exports){
var Cluster = require('../shared/cluster');

var ClusterRenderer = function(cluster, rank, xScale, width, height, onTextClick, onClusterItemClick) {

	this.width = width;
	this.height = height;
	this.xScale = xScale;
	this.onTextClick = onTextClick;
	this.clustSize = 0;
	this.onClusterItemClick = onClusterItemClick;
	this.rank = rank;
	this.cluster = cluster;
	var container = this.drawClusterContainer(cluster, rank);
	if (typeof container !== 'undefined') {
		this.drawCluster(cluster, rank);
	}
//	return outerDiv;

};

ClusterRenderer.prototype.updateCluster = function (clusterToUpdate) {
	var that = this;
	this.cluster = clusterToUpdate;
	this.clustSize = clusterToUpdate.cluster_size;
	var id = this.cluster.pdb_id.toLowerCase() + "_" + this.rank;
	if (typeof this.nusvg !== 'undefined') {
		this.nusvg.select("g#structure_" + id + " text")
		.text(function() {
		return that.clustSize;
	});
		
	}

}

ClusterRenderer.prototype.drawClusterContainer = function(cluster, s) {
	// scale start and end coordinates
	var that = this;
	var member = cluster.members[0];
	var pdb_chain = cluster.pdb_chain[0];
	// //var repeat_domain = data.Repeat_domains[0];
	
	if (cluster.secondary_structure.length === 0 || cluster.secondary_structure[0].length === 0) {
		console.log('ClusterRenderer.drawClusterContainer error: cannot draw cluster as it has no secondary structure: ', cluster);
		return;
	}

	structStart = this.xScale(cluster.secondary_structure[0][0].start);
	structEnd = this.xScale(cluster.secondary_structure[0][cluster.secondary_structure[0].length - 1].end);
	// console.log ("structStart: " + structStart + ", structEnd: " +
	// structEnd);
	var id = cluster.pdb_id.toLowerCase() + "_" + s;
	this.clustSize = cluster.cluster_size;
	// ///var cluster_nbr = s;
	var identity_score = cluster.alignment_identity_score;
	// set padding for labels
	pad = 0;
	if (this.clustSize > 99) {
		pad = 8;
	}
	if (this.clustSize > 999) {
		pad = 18;
	}
	if (this.clustSize < 10) {
		pad = -6;
	}

	//NEBLINA's SCRIPT
	this.w = document.getElementById("structureviewer").offsetWidth
				- AQUARIA.margin.right - AQUARIA.margin.left;

	var outerdiv = d3.select("#allclusters").append("div").attr("id", "out_" + id).attr(
			"class", "outer_container");
	outerdiv.append("svg").attr("width", 40).attr("height", 40).attr("viewBox",
			"0 0 40 40").attr("preserveAspectRatio", "none")
	// add identity percentage
	.append("text").attr("text-anchor", "end").attr("class", "percentage").attr(
			"x", 28).attr("y", 26).text(identity_score + "%");

	// draw outline of the whole chain
	this.nusvg = outerdiv.append("div").attr("id", "c_" + id).attr("class",
			"container").append("svg").attr("width", this.w - 30).attr("height",
			this.height + 30)
			.attr("viewBox", "0 0 " + (this.width + 200) + " " + (this.height + 30)).attr(
					"preserveAspectRatio", "none");

	this.nusvg.append("g").attr("id", "structure_" + id).attr("transform",
			"translate(" + (AQUARIA.margin.left + structStart + 100) + ",20)").on(
			"mouseover", function() {
				return d3.select(this).call(that.mouseover, that);
			}).on("mouseout", function() {
		return d3.select(this).call(that.mouseout, that);
	}).append("rect") // background shape for cluster size label
	.attr("transform", "translate(" + (structEnd - structStart - 5) + ",5)")
			.attr("class", "handle").attr("width", 32 + pad).attr("height", 16).attr(
					"rx", 6);

	this.nusvg.select("g#structure_" + id).append("g").attr("class", "cluster").attr(
			"title",
			"Click to load " + id.substr(0, 4) + ", chain " + pdb_chain
					+ " into structure view. Compared to the specified protein, this structure has "+identity_score+"% sequence identity. ").attr("width", structEnd - structStart + 2)
			.attr("height", 26).on("click", function() {
				return d3.select(this.parentNode).call(function (d) {
					console.log('ClusterRenderer.nusvg.select clicked! ' + d);
					that.onClusterItemClick(d);
				});
			});

	this.nusvg.select("g#structure_" + id + " g.cluster").append("rect").attr("class",
			"cluster").attr("width", structEnd - structStart + 3).attr("height", 26)
			.attr("rx", 6);

	// add center line
	this.nusvg.select("g#structure_" + id + " g.cluster").append("rect").attr("width",
			structEnd - structStart).attr("height", 1).attr("transform",
			"translate(0,13)").attr("class", "insertion");

	// add thumbnail images
	this.addThumbnails(id, structStart, structEnd, pad);

	
	this.nusvg.select("g#structure_" + id).append("text") // label for cluster size
	.attr("text-anchor", "end").attr("fill", "white").attr("x",
			(structEnd - structStart + 24 + pad)).attr("y", 13).attr("dx", -3) // padding-right
	.attr("dy", ".35em"); // vertical-align: middle)
	

	var clickTitle = "Click to see " + that.clustSize + " structures in this cluster"; 
	this.nusvg.select("g#structure_" + id + " text, g#structure_" + id).attr("class",
			"expandable").attr("title",
			clickTitle);
	
//	var clickClusterEvent = new CustomEvent(
//			"clusterExpanded", 
//			{
//				detail: {
//					message: clickTitle,
//					time: new Date(),
//				},
//				bubbles: true,
//				cancelable: true
//			}
//		);

	this.nusvg.select("g#structure_" + id + " text").on(
			"click", function () {
				that.onTextClick(d3.select(this.parentNode), that.cluster);
			});

	return outerdiv;

};

ClusterRenderer.prototype.drawCluster = function(cluster, rank) {
	var that = this;
	cluster.secondary_structure[0].forEach(function(d, index) {
		// convert strings to numbers
		d.start = +d.start;
		d.end = +d.end; // console.log(d.type +" "+index+", from "+d.start+" to
		// "+d.end);

		// draw the secondary structure, etc.
		that.drawResidues(cluster, rank, d);
	});
	this.setConservation(rank, cluster);
};

ClusterRenderer.prototype.drawResidues = function(cluster, rank, el) {
	// for each residue, draw one rectangle with a unique position id, so we can
	// assign a class/status later
	var offset = cluster.secondary_structure[0][0].start;

	var thickness = 0;

	for ( var n = el.start; n <= el.end; n++) {
		var conservation = cluster.conservationArray[0][n];
		if (n != el.end && conservation === cluster.conservationArray[0][n + 1]) {
			thickness++;
			continue;
		}
		var rect = this.nusvg.select(
				"g#structure_" + cluster.pdb_id.toLowerCase() + "_" + rank
						+ " g.cluster").append("g").attr("class", "residue " + el.type)
				.attr("id", "r_" + rank + "_" + n).attr("transform",
						"translate(" + (n - offset - thickness) * AQUARIA.srw + ",8)")
				.append("rect").attr("class", conservation).attr("width",
						AQUARIA.srw * (thickness + 1)).attr("height", 10);

		// if (data.conservationArray[n] === 'conserved') {
		// rect.attr("class", "conserved");
		// }
		if (el.type == "SHEET") {
		  rect.attr("height", 14).attr("transform", "translate(0,-2)");
      if (n == el.end) {
        rect.attr("width", AQUARIA.srw * (thickness));
//      }
//			if (n == el.end) {
				this.nusvg.select("g.residue#r_" + rank + "_" + n).append("svg:polygon")
						.attr("class", conservation).attr("transform",
								"translate(" + (AQUARIA.srw * thickness) + ",0)").attr(
								"points", AQUARIA.srw + ",0 0,-6 0,16 " + AQUARIA.srw + ",10");
				// this.nusvg.select("g.residue#r_"+rank+"_"+n+" rect").remove();
			} else {
				// console.log(' not at the end:' + n);
			}
		}
		if (el.type == "HELIX") {
			this.nusvg.select("g.residue#r_" + rank + "_" + n + " rect")
					.attr("height", 16).attr("class", conservation).attr("transform",
							"translate(0,-3)");
		}
		thickness = 0;
	}

};
ClusterRenderer.prototype.setConservation = function(index, data) { // console.log("setting conservation
	// for cluster "+index);

	// TO DO: account for gaps=insertions ( .clusters[n].seq_end[m]+1 ,
	// .clusters[n].seq_start[m+1]-1 )
	// draw rect height=2
	var insertions = [];
	var that = this;
	for ( var i = 0; i < data.seq_end.length - 1; i++) {
		var gap = [];
		gap[0] = data.seq_end[i] + 1;
		gap[1] = data.seq_start[i + 1] - 1;
		insertions.push(gap); // console.log("insertion: " + gap.toString());
	}
	
	var subst3 = this.nusvg.selectAll("g.residue").data(insertions).each(
			function(d) { // console.log("d.length: "+d.length);
				for ( var k = d[0]; k <= d[1]; k++) { // console.log("insertion at: " +
					// k);
					that.nusvg.select("g.residue#r_" + index + "_" + k + " rect").attr(
							"height", 1).attr("transform", "translate(0,5)").attr("class",
							"insertion");
				}
			});

};
ClusterRenderer.prototype.addThumbnails = function(protein, offset, end, pad) {
	var imgName = protein.substring(0, 4).toUpperCase();

	d3.select("g#structure_" + protein + " g.cluster").append("line").attr("x1",
			(end - offset + 6 + pad)).attr("y1", 13)
			.attr("x2", (this.width - offset + 60)).attr("y2", 13).attr("class",
					"connector").attr("stroke-width", 1);

	d3.select("g#structure_" + protein).append("g").attr("class", "thumbnail")
			.attr("transform", "translate(" + (this.width - offset + 28) + ",-18)")
			.append("circle").attr("cx", 30).attr("cy", 30).attr("r", 16).attr(
					"fill", "#FFF").attr("stroke", "#797979").attr("stroke-width", 2);

	d3.select("g#structure_" + protein + " g.thumbnail").append("clipPath").attr(
			"id", "path_" + protein).append("circle").attr("cx", 30).attr("cy", 30)
			.attr("r", 15).attr("clip-rule", "evenodd");

	var thumb = d3.select("g#structure_" + protein + " g.thumbnail").append(
			"image").attr("width", "30px").attr("height", "30px").attr("x", 15).attr(
			"y", 15).attr("xlink:href",
			"https://www.rcsb.org/pdb/images/" + imgName + "_bio_r_65.jpg").attr(
			"clip-path", "url(#path_" + protein + ")");
};

ClusterRenderer.prototype.mouseover = function(d, that) {
	that.origin = d3.select("#" + d.attr("id") + " g.thumbnail").attr("transform"); // //////console.log(origin);
	var over = parseFloat(that.origin.substring((that.origin.indexOf("(")) + 1, that.origin
			.indexOf(",")));// //////console.log("over:
	// "+over);
	var shortId = d.attr("id").substr(9); // //////console.log("shortId:
	// "+shortId);
	d3.select("#" + d.attr("id") + " g.cluster, #" + d.attr("id")).classed(
			"active", true);
	d3.select("#" + d.attr("id") + " g.thumbnail").attr("transform",
			"translate(" + (over + 32) + ", -18)");
	d3.select("#" + d.attr("id") + " g.thumbnail circle").attr("r", 30);
	d3.select("#" + d.attr("id") + " g.thumbnail #path" + shortId + " circle")
			.attr("r", 29);
	d3.select("#" + d.attr("id") + " g.thumbnail image").attr("width", "60px")
			.attr("height", "60px").attr("x", 0).attr("y", 0);
};
ClusterRenderer.prototype.mouseout = function(d, that) {
	var shortId = d.attr("id").substr(9); // //////console.log("shortId:
	// "+shortId);
	d3.select("#" + d.attr("id") + " g.cluster, #" + d.attr("id")).classed(
			"active", false);
	d3.select("#" + d.attr("id") + " g.thumbnail").attr("transform", that.origin);
	d3.select("#" + d.attr("id") + " g.thumbnail circle").attr("r", 16);
	d3.select("#" + d.attr("id") + " g.thumbnail #path" + shortId + " circle")
			.attr("r", 15);
	d3.select("#" + d.attr("id") + " g.thumbnail image").attr("width", "30px")
			.attr("height", "30px").attr("x", 15).attr("y", 15);
};

module.exports = ClusterRenderer;
},{"../shared/cluster":149}],5:[function(require,module,exports){
var featureSet;
var width;
var height;
var featureCount;
var groupCount;

function createFeatureUI() {
	width = document.getElementById("structureviewer").offsetWidth
			- AQUARIA.margin.right - AQUARIA.margin.left; // console.log("width:
	// "+width);
	height = 40 - AQUARIA.margin.top - AQUARIA.margin.bottom + 35; // height
	// for one
	// structure

};

function updateFeatureTabTitle(preferredProteinName) {
	if (preferredProteinName !== "unknown") {
		// $("#featureExplanation").text(" for " + preferredProteinName);
	}
};

var updateFeatureUI = function(featureList) {
	featureSet = featureList || featureSet;
	console.log("featurelist.updateFeatureUI");

	$("#featurelist div").remove(); // remove old contents
//	$("#featureExplanation").text(" Loading...");
//	$("#featureCounter").html("<img src='/images/89.GIF'/>").show();

	// draw axis ruler
	AQUARIA.showMatchingStructures.drawAxisRuler("featurelist");

	createFeatureUI();
	featureCount = 0;
	groupCount = 0;
	var clusters = [];
	var orderedFeatures = [];
	//Group by feature source
	  var groupedFeatures = _.groupBy(featureSet, function(feature) {
		return feature.Server;
	  });
	
	//Store as an object 
	  groupedFeatures = Object.keys(groupedFeatures).map(function(key) {
		return [String(key), groupedFeatures[key]];
	  });
	
	  for ( var key in featureSet) {
			clusters.push(featureSet[key]);
	  }
	
	//Reorder grouped features
	if((window.localStorage.getItem("featureOrder")) && (window.localStorage.getItem("featureOrder").split(",").length >= groupedFeatures.length)){
	  var featureOrder = window.localStorage.getItem("featureOrder").split(",")
	  for ( var key in featureOrder){
		for(var k = 0; k < groupedFeatures.length; k++){
		  if(groupedFeatures[k][0] == featureOrder[key]){
			orderedFeatures[key] = groupedFeatures[k]
		  }
		}
	  }
	  groupedFeatures = orderedFeatures
	}
	
	
	  var featureDiv = d3.select("#featurelist").append("div").attr("id", "featureContainer").append("div").attr("id", "groupedFeatures")
  
	  for ( var key in groupedFeatures) {
	  //Feature Collection Header
	  var featureHeader = featureDiv.append("div").attr("id", groupedFeatures[key][0]).attr("class", "featureCollection")
	  if(groupedFeatures[key][0] == "UniProt" || groupedFeatures[key][0] == "CATH" || groupedFeatures[key][0] == "SNAP2" || groupedFeatures[key][0] == "PredictProtein"){
		featureHeader = featureHeader.html("<div class='featureHeader'><p class='expand'></p><p class='featureName'>" + groupedFeatures[key][0] + "</p><div class='info'>?</div></div><span class='tooltiptext'>" + groupedFeatures[key][1][0]["About"] + "</span>")
	  }
	  else{
		featureHeader = featureHeader.html("<div class='featureHeader'><p class='expand'></p><p class='featureName'>" + groupedFeatures[key][0] + "</p><div class='info'>?</div><button id='remove' class='featureButtons'>Remove</button></div><span class='tooltiptext'>" + groupedFeatures[key][1][0]["About"] +"</span>")
	  }
		//Feature tracks
		featureHeader.append("div").attr("class", "featureTrack")
				.selectAll("div")
				.data(groupedFeatures[key][1])
				.enter()
				.append("div")
				.attr("class", "track")
				.html(
						function(d) {
							if (d.Type != ''){
							  if(d.Server == "UniProt" || d.Server == "PredictProtein" || d.Server == "CATH" || d.Server == "SNAP2"){
								  var source = "Curated Features"
				  }
				  else{
					source = d.Server
				  }
								return "<p style='font-size: calc(9px + 0.1vw);'><b>"
									+ d.Category
									+ "</b> ("
									+ d.Type.replace(/_/g, " ")
									+ ") <span class='source'>"
									+ source
									+ "</span></p>";
							} else {
								if(d.Server == "UniProt" || d.Server == "PredictProtein" || d.Server == "CATH" || d.Server == "SNAP2"){
									source = "Curated Features"
				  }
				  else{
					source = d.Server
				  }
								return "<p><b>"
									+ d.Category
									+ "</b> <span class='source'>"
									+ source
									+ "</span></p>";
							}
			  }).each(drawTrack);
			  
	//	if (AQUARIA.preferred_protein_name !== "unknown") {
	//		updateFeatureTabTitle(AQUARIA.preferred_protein_name);
	  }
	  $("#featureCounter").show();
			if (featureCount > 0) {
				$("#featureCounter").text(featureCount);
				$("#featureCounter").digits();
	//			$("#waitForFeatures").hide();
				var scrollToggle = "<p id='scrollToggle'><a href='javascript:$(\"#featureContainer\").toggleClass(\"noscroll\");'>Toggle scrolling</a></p>";
				$("#featureContainer").append(scrollToggle);
			}
			else{
				$("#featureCounter").text(featureCount);
			}
	//		else { $("#featureCounter").html("<img src='/images/89.GIF'/>"); }
	//	}
	
	//Following scripts displays the external URL features on structure
  
	//Style featureHeader elements
	d3.selectAll('.expand').attr("style", "font-size: calc(9px + 0.2vw);color: #848484;margin: 10px -7px 0px 0px;")
	d3.selectAll("#remove")
	.on("click", function(){
	  $(this).parent().parent().remove()
	  })
	$("#groupedFeatures").sortable({axis: 'y'})
	$(".featureTrack").sortable({axis: 'y'}).css({"cursor": "move"})
	$("#groupedFeatures").disableSelection()
	$(".featureHeader").on("click", function () {
		var content = $(this).parent().children().eq(2)
		var notThis = $('div[class*="active"]').not(this)
		notThis.removeClass("active")
		notThis.children().eq(0).text("")
		notThis.next("div").slideUp("slow");
		notThis.children("button").css({"visibility": "hidden"})
	
		content.slideToggle('slow')
		if(content.is(":visible")){
		  $(this).addClass("active")
		}
			if ($(this).children().eq(0).text() == '') {
			$(this).children().eq(0).text("")
			$(this).children("button").css({"visibility": "visible"})
		  } else {
			$(this).children().eq(0).text("")
			$(this).children("button").css({"visibility": "hidden"})
		  }
		});
	var timer;
	$(".featureHeader").on({
	  mouseenter: function () {
		$(this).css({"background-color":"#BEBEBE", "cursor": "pointer"})
	  },
	  mouseleave: function () {
		$(this).css({"background-color":"#cccccc"})
	  },
	  mousedown: function(){
		var that = this
		timer = setTimeout(function(){
		  $(that).css({"cursor": "move"})
		}, 500);
	  },
	  mouseup: function(){
		$(this).css({"cursor": "pointer"})
	  }
	})
	$('.info').find('span:contains("undefined")').parent().remove()
	d3.selectAll(".info").on({
		mouseenter: function () {
      $(this).css({"background-color":"orange", "color": "white"})
      $(this).parent().parent().children("span.tooltiptext").css({"visibility" : "visible"})
		},
		mouseleave: function () {
      $(this).css({"background-color":"white", "color": "black"})
      $(this).parent().parent().children("span.tooltiptext").css({"visibility" : "hidden"})
	  }
	});

	$(".tooltiptext").on({
		mouseenter: function () {
      $(this).css({"visibility" : "visible"})
    },
    mouseleave: function () {
      $(this).css({"visibility" : "hidden"})
	  }
  })
	
	//Store ordering of feature source
	var featureOrder = new MutationObserver( function (mutations) {
	  var sources = $('#groupedFeatures .featureCollection').map(function(){
		return $(this).attr('id');
		}).get();
		localStorage.setItem("featureOrder", sources);
	})
	featureOrder.observe(document.getElementById("groupedFeatures"), {
	  attributes:    true,
	  childList: true
	  });
  
	// d3.selectAll("#share").on("click", function() {
	// 	var dummy = document.createElement('input'),
	//   text = window.location.href;
	//   document.body.appendChild(dummy);
	//   dummy.value = text;
	//   dummy.select();
	//   document.execCommand('copy');
	//   document.body.removeChild(dummy);
	// })

  //On external features scripts show features
// 	if($("svg#s_0_0").parent().parent().parent().attr("id") === "Added Features"){
//       	var custom_feature = $("svg#s_0_0")
// 		var oid = custom_feature.attr("id").split("_")[2];
// 		passFeature(clusters[0], oid);
// 		d3.selectAll("svg.loaded rect.feature").attr("fill", "#a4abdf");
// 		d3.select("svg.loaded").classed("loaded", false);
// 		custom_feature.attr("class", "loaded");
//   }


  var document_observer = new MutationObserver( function (mutations) {
	  // `mutations` is an array of mutations that occurred
	  // `me` is the MutationObserver instance
	  if($(location).attr('href').includes("json")){
		mutations.forEach(function(mutation) {
		  if (mutation.attributeName !== 'style') {
			return none;
		  }
		  else{
			var currentValue = mutation.target.style.display;
			if (currentValue == "none") {
			  ///console.log("THIS IS CHANGED")
			  pdb_chain_observer.observe(document.getElementById("waitingFrame"), {
				attributes:    true,
				attributeFilter: ["style"]
			  })
			}
		  }
		  })
		}
	  });

	var pdb_chain_observer = new MutationObserver(function (m, me) {
	  m.forEach( function(mut) {
		if (mut.attributeName !== 'style') return;
		var currentValue = mut.target.style.display;
		if (currentValue == "none") {
		  var custom_feature = $("svg#s_0_0")
		  var oid = custom_feature.attr("id").split("_")[2];
		  // AQUARIA.panel3d.blankApplet(true, "Loading feature...")
		  // AQUARIA.panel3d.blankApplet(false)
		  passFeature(clusters[0], oid);
		  d3.selectAll("svg.loaded rect.feature").attr("fill", "#a4abdf");
		  d3.select("svg.loaded").classed("loaded", false);
		  custom_feature.attr("class", "loaded");

		  me.disconnect();     // stop observing

		}
	  })
	})


//   start observing structure change
  document_observer.observe(document.getElementById("loading-message"), {
	attributes:    true,
	attributeFilter: ["style"],
	characterDataOldValue: true
  });
};

function drawTrack(datum, i) {
	var features = datum.Tracks;

	for ( var o in features) {

		d3
				.select(this)
				.append("svg")
				.attr("width", width + AQUARIA.margin.left)
				.attr("height", 25)
				.attr("viewBox", "0 0 " + (width + AQUARIA.margin.left) + " 25")
				.attr("preserveAspectRatio", "none")
				.attr("id", "s_" + groupCount + "_" + o)
				.attr("title",
						"Click to load feature into 3D view; hover over features to see detailed info.")

				.on("click", function() {
					if(d3.select(this).attr("class") == "loaded") { // deselect feature (it's already displayed)
						d3.select("svg.loaded").classed("loaded", false);
						AQUARIA.panel3d.blankApplet(true, "Removing feature...")
						AQUARIA.panel3d.blankApplet(false)
						removeCurrentAnnotationFrom3DViewer();
					}
					else { //console.log("clicked to display feature");
						var oid = d3.select(this).attr("id").split("_")[2];
						AQUARIA.panel3d.blankApplet(true, "Loading feature...")
						AQUARIA.panel3d.blankApplet(false)
						passFeature(datum, oid, this);
						d3.selectAll("svg.loaded rect.feature").attr("fill", "#a4abdf");
						d3.select("svg.loaded").classed("loaded", false);
						d3.select(this).attr("class", "loaded");	//console.log("it's " + d3.select(this).attr("class"));
						}
					})
				.on("mouseover", function() {
							d3.select(this).selectAll("rect.feature").attr(
									"fill", function() {
										return d3.select(this).attr("color");
									});
						})
				.on("mouseout", function() {
							if(d3.select(this).attr("class") != "loaded"){
								d3.select(this).selectAll("rect.feature")
								.attr("fill", "#a4abdf");
							}
						})
					// add background for highlighting
				.append("rect")
					.attr("width", width + AQUARIA.margin.left)
					.attr("height", 25)
					.attr("class", "bg")
					.attr("fill", "none");

			d3.select("svg#s_" + groupCount + "_" + o)
				.append("g")
					.attr("transform", "translate(" + AQUARIA.margin.left + ",0)")
					// add center line
				.append("rect")
					.attr("width", width)
					.attr("height", 1)
					.attr("transform", "translate(0,13)")
					.attr("class", "insertion");
					// add features
		for ( var p in features[o]) {
			featureCount++;
			d3
					.select("#s_" + groupCount + "_" + o + " g")
					.append("rect")
					.attr(
							"width",
							function() {
								return (/*parseInt*/((features[o][p].size + 1)
										* AQUARIA.srw) > 2) ? /*parseInt*/((features[o][p].size + 1)
										* AQUARIA.srw)
										: 2;
							}).attr("height", 14).attr("id",
							"r_" + groupCount + "_" + o + "_" + p).attr(
							"transform",
							"translate("
									+ /*parseInt*/(features[o][p].start
											* AQUARIA.srw) + ",6)").attr(
							"color", features[o][p].color).attr("fill",
							"#a4abdf").attr("fill-opacity", function() {
						return (datum.Class == "single_track") ? 0.3 : 1;
					}).attr("class", "feature").on("mouseover",
							createMouseOverCallback(features[o][p])).on(
							"mouseout",
							function() {
								var ID = d3.select(this).attr("id");
								return d3.select(this)
										.call(mouseoutFeature, ID);
							});
		}
	}
	groupCount++;
}

function createMouseOverCallback(feature) {
	return function() {
		var ID = d3.select(this).attr("id");
		d3.select(this).call(mouseoverFeature, feature, ID);
	};
}

function passFeature(trk, nr, elmt) {

		//console.log("featurelist.passFeature " + trk.Category + " " + trk.Type + ", Track " + nr, trk); //console.log(elmt);

		sentAnnotationTo3DViewer(trk, parseInt(nr));

}

var t, s;
function mouseoverFeature(el, f, eid) {
	t = setTimeout(function() {
		showAnnotation(f, eid);
	}, 500);
	d3.select("#" + eid).attr("stroke-width", "2px").attr("stroke", "white");

}

function mouseoutFeature(el, eid) {
	clearTimeout(t);
	d3.select("#" + eid).attr("stroke-width", "0px");
	s = setTimeout(function() {
		$("div.popup").fadeOut();
	}, 500);
}

function showAnnotation(f, eid) {
	// console.log("Hovered "+f.name+" "+f.start+"-"+f.end+": "+f.desc);
	var urlhtml = "";
	if (f.urls.length > 0) {
		// var lnx = f.urls.split(";");
		urlhtml = "<p>";
		for ( var i = 0; i < f.urls.length; i++) {
			urlhtml += "<a href='" + f.urls[i].href + "' target='_blank'>"
					+ f.urls[i].text + "</a><br>";
		}
		urlhtml += "</p>";
	}
	$("div.popup").remove();
	var balloon = "<div class='balloon'><span class='x'>&nbsp;</span><p>"
			+ f.label + " (";
	if (f.start == f.end){
		balloon = balloon + "Residue "+f.start;
	} else {
		balloon = balloon + "Residues "+f.start+"-"+f.end;
	}

	balloon = balloon + ")<br/>"
			+ f.desc + "</p>"
			+ urlhtml + "</div>";
	d3.select("body")
		.append("div")
			.attr("class", "popup")
			.html(balloon);

	var popheight = $("div.popup").innerHeight();

	var fpos = $("#" + eid).offset();
	var fwidth = $("#" + eid).attr("width");

	var bleft = parseInt(fpos.left + fwidth / 2 - 160);
	var btop = parseInt(fpos.top - popheight);

	$("div.popup").css({
		"left" : bleft + "px",
		"top" : btop + "px"
	}).fadeIn(600);

	$("span.x").click(function() {
		$("div.popup").fadeOut();
	});

	$("div.popup").hover(function() {
		clearTimeout(s);
	}, function() {
		s = setTimeout(function() {
			$("div.popup").fadeOut();
		}, 500);
	});

}

// DAS annotation handling

var currentAnnotationsIn3DViewer = new Array();

/**
 * removes the current annotation track from the 3D viewer
 */
function removeCurrentAnnotationFrom3DViewer() {
	// remove existing Annotation

	if (currentAnnotationsIn3DViewer !== undefined) {
		for ( var i in currentAnnotationsIn3DViewer) {
			// API call
			AQUARIA.panel3d.removeAnnotation(currentAnnotationsIn3DViewer[i].id,
					currentAnnotationsIn3DViewer[i].annotationName);
		}
		currentAnnotationsIn3DViewer.length = 0;
	}
}

/**
 * send the annotation track to the 3D viewer
 */
function sentAnnotationTo3DViewer(annotations, trackNumber) {

	// default is to send of all track lines unless trackNumber has been
	// specified
	trackNumber = typeof trackNumber !== 'undefined' ? trackNumber : -1;

	// remove existing Annotation
	removeCurrentAnnotationFrom3DViewer();

	// send specific track if requested
	if (trackNumber >= 0) {
		reformatAndAddFeatureTo3DViewer(annotations, trackNumber);
	} else {
		// send all tracks
		for (trackNumber in annotations.Tracks) {
			reformatAndAddFeatureTo3DViewer(annotations, trackNumber);
		}
	}
}

/**
 * reformat an annotation track into the format required by the API
 */
function reformatAndAddFeatureTo3DViewer(annotations, trackNumber) {
	var featureColours = new Array();
	var featureNames = new Array();
	var featureDescriptions = new Array();
	var featurePositions = new Array();
	var featureURLs = new Array();
	var featureURLtexts = new Array();
	var featureCategories = {};
	var lastColour = '#ffffff';
	if (annotations.featureColours && annotations.featureColours.length > 0) {
	  lastColour = annotations.featureColours[0];
	}
	// send specified track only
	for ( var j in annotations.Tracks[trackNumber]) {
		// only transfer features flagged as visible
		if (annotations.Tracks[trackNumber][j].show) {
			if (annotations.Class.color !== 'multi_color') {
				// 0.3 o
				var alphaColor = "#4d"
						+ annotations.Tracks[trackNumber][j].color.substring(1);
			}
		  if (annotations.Tracks[trackNumber][j].color) {
//		    lastColour = annotations.Tracks[trackNumber][j].color;
	        featureColours.push(annotations.Tracks[trackNumber][j].color);
			}
	    else {
        featureColours.push(lastColour);

	    }

//				else {
//	        featureColours.push(annotations.Tracks[trackNumber][j].color);
//
//				}

			featureNames.push(annotations.Tracks[trackNumber][j].label);
			featureDescriptions.push(annotations.Tracks[trackNumber][j].desc);
			featurePositions.push(annotations.Tracks[trackNumber][j].start
					+ ":" + annotations.Tracks[trackNumber][j].end);

			fURLs = new Array();
			fURLtxts = new Array();

			for ( var k in annotations.Tracks[trackNumber][j].urls) {
				fURLs.push(annotations.Tracks[trackNumber][j].urls[k].href);
				fURLtxts.push(annotations.Tracks[trackNumber][j].urls[k].text);
			}
			featureURLs.push(fURLs);
			featureURLtexts.push(fURLtxts);

		}
		;
	}

	var annotationToAdd = {
		"id" : annotations.ProteinID,
		"annotationName" : annotations.Category
	};

	currentAnnotationsIn3DViewer.push(annotationToAdd);
	// API call
	AQUARIA.panel3d.addAnnotation(annotationToAdd.id[0],
					annotationToAdd.annotationName, featureColours,
					featureNames, featureDescriptions, featurePositions,
					featureURLs, featureURLtexts);
}

module.exports.updateFeatureUI = updateFeatureUI;
module.exports.updateFeatureTabTitle = updateFeatureTabTitle;
},{}],6:[function(require,module,exports){
var cache = require('../common/cache')();

var das_servers = [
		{
			"Server" : 'External Features (JSON)',
			"URL" : '',
			"Categories" : {
				"default" : {
					"track" : "multi_track",
					"color" : "single_color"
				}
			}
		},
		{
			"Server" : 'InterPro',
			"URL" : 'http://www.ebi.ac.uk/das-srv/interpro/das/InterPro-matches-overview/',
			"Categories" : {
				"Inferred from InterPro motif similarity" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"default" : {
					"track" : "multi_track",
					"color" : "multi_color"
				}
			}
		},
		{
			"Server" : 'Uniprot',
			"URL" : 'http://www.ebi.ac.uk/das-srv/uniprot/das/uniprot/',
			"Categories" : {
				"Region" : {
					"track" : "multi_track", // possible values:
												// "single_track","multi_track"
					"color" : "multi_color" // possible values:
											// "#RGBcolor","single_color","multi_color"
				},
				"Site" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"Amino acid modification" : {
					"track" : "multi_track",
					"color" : "single_color"
				},
				"Amino acid modification;post translational modification" : {
					"track" : "multi_track",
					"color" : "#993404"
				},
				"Sequence variation" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"Sequence variation;natural variant site" : {
					"track" : "multi_track",
					"color" : "#FFD64F"
				},
				"Sequence variation;mutated variant site" : {
					"track" : "multi_track",
					"color" : "#E34C94"
				},
				"Experimental information" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"Molecule processing" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"default" : {
					"track" : "multi_track",
					"color" : "multi_color"
				}
			}

		// }, {
		// "Server" : 'SignalP',
		// "URL" : 'http://das.cbs.dtu.dk:9000/das/cbs_sort/',
		// "Categories" : {
		// "Inferred from electronic annotation" : { "track":"multi_track",
		// "color":"multi_color"}
		// }
		// }, {
		// "Server" : 'Pride',
		// "URL" : 'http://www.ebi.ac.uk/pride-das/das/PrideDataSource/',
		// "Categories" : {
		// "coverage" : { "track":"multi_track", "color":"multi_color"}
		// }
		}
		];

// available set of colors
var feature_colors = [ "#253494", "#1162dc", "#7B87C2", "#8AAAD9", "#5BC48F",
		"#00AE95", "#76B043", "#AED477", "#E4C8A7", "#FFD64F", "#E6B222",
		"#818C43", "#D77D2A", "#F8AD7C", "#E39FC6", "#E34C94", "#993404" ];
// indicates if currently accessing remote servers
var isFetchingData = false;
// indicates which server is accessed
var isFetchingFromServer = "";
// current server index
var currentServer = -1;
// contains current records of all annotations
var aggregatedAnnotations;

// color handling
/**
 * This function hashes a string into the color range adapted from
 * http://erlycoder.com/49/javascript-hash-functions-to-convert-string-into-integer-hash-
 */
var djb2Code = function(str, bins) {
	var hash = 5381;
	for ( var i = 0; i < str.length; i++) {
		char = str.charCodeAt(i);
		hash = ((hash << 5) + hash) + char; /* hash * 33 + c */
	}
	return Math.abs(hash % bins);
};

function capitaliseFirstLetter(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
}

if (typeof String.prototype.startsWith != 'function') {
	// see below for better implementation!
	String.prototype.startsWith = function(str) {
		return this.indexOf(str) == 0;
	};
}

// http://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression
function stripScripts(s) {
  var div = document.createElement('div');
  div.innerHTML = s;
  var scripts = div.getElementsByTagName('script');
  var i = scripts.length;
  while (i--) {
    scripts[i].parentNode.removeChild(scripts[i]);
  }
  return div.innerHTML;
}

/**
 * This helper function to annotations to the json object - one at a time
 */
var add_external_annotation = function(primary_accession, json_object, ann, das_server,
		category) {
	var ann_key;
	var categorytype = category.trim().replace(")","").split("(");
	// add emtpy category
	if (categorytype.length == 1){
		categorytype.push("");
	}
	var ann_key = das_server + "|:|" + categorytype[0] + "|:|" + categorytype[1];

	for ( var i = 0; i < ann.Features.length; i++) {
		var f = ann.Features[i];

		var feat_name = f.Name;
		var feat_label = f.Name.replace(/_/g, ' ');
		var feat_desc = stripScripts(f.Description);
		var feat_start;
		var feat_end;
		var feat_color;

		if (f.Color){
			// if the JSON file specifies a color for this individual feature, then use it
			feat_color = f.Color;
		} else if (ann.Color){
			// if the JSON file specifies a feature set color, then use it for all features
			feat_color = ann.Color;
		} else {
			feat_color = feature_colors[djb2Code(feat_label, feature_colors.length)];
		}

		if (typeof f.Residues == "object"){
			// assume array
			feat_start = parseInt( f.Residues[0]);
			feat_end = parseInt( f.Residues[1]);
		} else if (typeof f.Residue !== 'undefined'){
      feat_start = parseInt( f.Residue);
      feat_end = parseInt( f.Residue);
    } else {
			feat_start = parseInt( f.Residues);
			feat_end = parseInt( f.Residues);
		}

		var feat_url = [];
		if (ann.Source) {
			feat_url.push({
				"href" : ann.URL,
				"text" : ann.Source
			});
		}

		var new_region = {
				"color" : feat_color,
				"name" : feat_name,
				"label" : feat_label,
				"desc" : feat_desc,
				"start" : feat_start,
				"end" : feat_end,
				"size" : feat_end - feat_start,
				"urls" : feat_url,
				"show" : true
			};

		if (!(ann_key in json_object)) {
			// add new annotation type
			json_object[ann_key] = {
				"ProteinID" : primary_accession,
				"Server" : das_server,
				"Category" : categorytype[0],
				"Type" : categorytype[1],
				"Method" : "",
				"Tracks" : [ new_region ]
			};
		} else {
			// add new region to existing annotation category
			cur_ann_type = json_object[ann_key];
			cur_ann_type["Tracks"].push(new_region);
		}
	}
}

/**
 * This helper function to annotations to the json object - one at a time
 */
var add_annotation = function(primary_accession, json_object, ann, das_server,
		categories) {
	var filter_key;

	if (ann.TYPE.category !== undefined){
		var categorytype = capitaliseFirstLetter(ann.TYPE.category.replace(
				/ *\(.*?\) */g, ""));
		var categorytext = ann.TYPE.textContent.replace(/_/g, " ");
	} else {
		// category not defined
		return
	}

	if (hasOwnProperty(categories, categorytype + ";" + categorytext)) {
		filter_key = categorytype + ";" + categorytext;
	} else if (hasOwnProperty(categories, categorytype)) {
		filter_key = categorytype;
	} else if (hasOwnProperty(categories, categorytext)) {
		filter_key = categorytext;
	} else {
		// no match
		return;
	}
	// console.log(categorytype + " found in " + categories);

	var ann_key = das_server + "|:|" + categorytype + "|:|"
			+ ann.TYPE.textContent;

	var feat_name = ann.id;
	var feat_label = ann.label.replace(/_/g, ' ');

	var feat_desc = [];
	if (ann.NOTE) {
		for ( var i = 0; i < ann.NOTE.length; i++) {
			// replace non-informative labels with non-empty note entry
			if (feat_label.toUpperCase().startsWith("UNIPROTKB")
					&& ann.NOTE[i].textContent != "") {
				feat_label = ann.NOTE[i].textContent;
			// skip redundant information in the notes
			} else if (ann.NOTE[i].textContent != feat_label){
				feat_desc.push(ann.NOTE[i].textContent);
			}
		}
	}

	var feat_color;
	if (categories.hasOwnProperty(filter_key)
			&& categories[filter_key]["color"] == "multi_color") {
		// multi-color features have a color per feature
		feat_color = feature_colors[djb2Code(feat_label, feature_colors.length)];

	} else if (categories.hasOwnProperty(filter_key)
			&& categories[filter_key]["color"] == "single_color") {
		// single-color features based on category text key hash
		feat_color = feature_colors[djb2Code(categorytext,
				feature_colors.length)];
	} else {
		// single-color features based on given color
		feat_color = categories[filter_key]["color"];
	}

	var feat_start = (ann.START) ? parseInt(ann.START.textContent) : 0;
	var feat_end = (ann.END) ? parseInt(ann.END.textContent) : 0;

	var feat_url = [];
	if (ann.LINK) {
		for ( var i = 0; i < ann.LINK.length; i++) {
			feat_url.push({
				"href" : ann.LINK[i].href,
				"text" : ann.LINK[i].textContent
			});
		}
	}

	var new_region = {
		"color" : feat_color,
		"name" : feat_name,
		"label" : feat_label,
		"desc" : feat_desc.join('\n'),
		"start" : feat_start,
		"end" : feat_end,
		"size" : feat_end - feat_start,
		"urls" : feat_url,
		"show" : true
	};

	if (!(ann_key in json_object)) {
		// add new annotation type
		json_object[ann_key] = {
			"ProteinID" : primary_accession,
			"Server" : das_server,
			"Category" : categorytype,
			"Type" : ann.TYPE.textContent.replace(/_/g, ' '),
			"Method" : ann.METHOD.textContent,
			"Tracks" : [ new_region ]
		};
	} else {
		// add new region to existing annotation category
		cur_ann_type = json_object[ann_key];
		cur_ann_type["Tracks"].push(new_region);
	}
};

/**
 * optimize color handling for multi-track features
 *
 * @param category
 * @param multitracks
 */
function optimizeColors(category, multitracks) {
	// catalog all labels
	var labels = {};
	for ( var track_num = 0; track_num < multitracks.length; ++track_num) {
		for ( var j = 0; j < multitracks[track_num].length; j++) {
			if (hasOwnProperty(labels, multitracks[track_num][j]["label"])) {
				labels[labels, multitracks[track_num][j]["label"]] += 1
			} else {
				labels[labels, multitracks[track_num][j]["label"]] = 1
			}
		}
	}

	var num_terms = Object.size(labels);
	var term_arr = Object.keys(labels);
	// get color set offset from feature category to allow diverse color sets
	var offset = djb2Code(category, feature_colors.length);

	// calculate color
	for ( var track_num = 0; track_num < multitracks.length; ++track_num) {
		for ( var j = 0; j < multitracks[track_num].length; j++) {
			i = term_arr.indexOf(multitracks[track_num][j]["label"]);
			multitracks[track_num][j]["color"] = feature_colors[(offset + Math
					.round(i * feature_colors.length / num_terms))
					% feature_colors.length];
		}
	}
}

/**
 * cluster region features into tracks with non-overlapping features
 */
function clusterRegions(sequence_annotations, categories) {
	var clusters = new Array();

	for (var annotation in sequence_annotations) {
		var filter_key;
		if (hasOwnProperty(categories,
				sequence_annotations[annotation]["Category"] + ";" + sequence_annotations[annotation]["Type"])) {
			filter_key = sequence_annotations[annotation]["Category"] + ";"
					+ sequence_annotations[annotation]["Type"];
		} else if (hasOwnProperty(categories,
				sequence_annotations[annotation]["Category"])) {
			filter_key = sequence_annotations[annotation]["Category"];
		} else if (hasOwnProperty(categories,
				sequence_annotations[annotation]["Type"])) {
			filter_key = sequence_annotations[annotation]["Type"];
		} else if (hasOwnProperty(categories, "default")) {
			filter_key="default";

		} else {
			// no match
			console.log("ERROR: Feature class not known");
			return clusters;
		}

		var feat_class = categories[filter_key]["track"];
		if (feat_class == "multi_track") {
			// multi-line features

			var new_tracks = new Array();
			var tracks = sequence_annotations[annotation]["Tracks"];

			// sort tracks by size of the region spanned
			tracks.sort(compareAnnotationRegions);

			// detect collisions
			while (tracks.length > 0) {
				var region = tracks.pop();

				var found_spot = false;
				var track_num = 0;
				var collision = false;

				while (track_num < new_tracks.length & !found_spot) {
					for ( var j = 0; j < new_tracks[track_num].length; j++) {
						if ((new_tracks[track_num][j].start <= region.start && region.start <= new_tracks[track_num][j].end)
								|| (new_tracks[track_num][j].start <= region.end && region.end <= new_tracks[track_num][j].end)) {
							// collision found in this track, stop and start
							// checking next track
							track_num += 1;
							collision = true;
							break;
						}
					}
					if (!collision) {
						found_spot = true;
						break;
					}
					collision = false;
				}

				if (found_spot) {
					new_tracks[track_num].push(region);
				} else {
					new_tracks.push(new Array(region));
				}
			}

			if (categories[filter_key]["color"] == "multi_color") {
				optimizeColors(sequence_annotations[annotation]["Category"],
						new_tracks);
			}

			clusters.push({
				"ProteinID" : sequence_annotations[annotation]["ProteinID"],
				"Server" : sequence_annotations[annotation]["Server"],
				"Class" : {
					track : categories[filter_key]["track"],
					color : categories[filter_key]["color"]
				},
				"Category" : sequence_annotations[annotation]["Category"],
				"Method" : sequence_annotations[annotation]["Method"],
				"Type" : sequence_annotations[annotation]["Type"],
				"Tracks" : new_tracks
			});

		} else if (feat_class == "single_track") {
			// single-line features
			clusters.push({
				"ProteinID" : sequence_annotations[annotation]["ProteinID"],
				"Server" : sequence_annotations[annotation]["Server"],
				"Class" : feat_class,
				"Category" : sequence_annotations[annotation]["Category"],
				"Method" : sequence_annotations[annotation]["Method"],
				"Type" : sequence_annotations[annotation]["Type"],
				"Tracks" : [ sequence_annotations[annotation]["Tracks"] ]
			});

		} else {
			console.log("ERROR: Feature class not known");
		}
	}
	return clusters;
}

/**
 * This function compares two regions based of their size
 *
 * @param a
 *            region 1
 * @param b
 *            region 2
 * @returns {Number}
 */
function compareAnnotationRegions(a, b) {
	if (a.size < b.size)
		return -1;
	if (a.size > b.size)
		return 1;
	return 0;
}

/**
 *
 * This function calculates the size of an object
 *
 * @param obj
 * @returns {Number}
 */
Object.size = function(obj) {
	var size = 0;
	for ( var key in obj) {
		if (obj.hasOwnProperty(key))
			size++;
	}
	return size;
};

/**
 * This function checks if an object has a given property
 *
 * @param obj
 *            object
 * @param prop
 *            property
 * @returns {Boolean} true if object has property, false otherwise
 */
function hasOwnProperty(obj, prop) {
	var proto = obj.__proto__ || obj.constructor.prototype;
	return (prop in obj) && (!(prop in proto) || proto[prop] !== obj[prop]);
}

/**
 * reset current DAS annotation set
 */
function resetDASAnnotations() {

	isFetchingData = false;
	isFetchingFromServer = "";
	currentServer = -1;
	aggregatedAnnotations = new Array();
}

module.exports = function(primary_accession, uniprot_sequence_MD5_hash,
		featureCallback, sequenceCallback) {
	// reset annotations

	// blah blah HANDLE CACHE HERE
	var key = "FEATURE_" + primary_accession + getUrlParameter("features");
	var cacheValue = cache.read(key);

	if (cacheValue) {
		// return cache result for immediate display
		featureCallback(cacheValue);
	}
	// get fresh set of annotations as well
	console.log("Reset DAS annotations");
	resetDASAnnotations();

	processNextServer(primary_accession, uniprot_sequence_MD5_hash,
			featureCallback, sequenceCallback);
};

/**
 * Process the next annotation resource and add their annotations
 */
var processNextServer = function(primary_accession, uniprot_sequence_MD5_hash,
		featureCallback) {

	currentServer += 1;
	isFetchingData = true;
	// get DAS servers first
	if (currentServer < das_servers.length) {
		isFetchingFromServer = das_servers[currentServer]['Server'];

		console.log("************* isFetchingFromServer");
		if (isFetchingFromServer == "External Features (JSON)"){
			// check URL for json url
			checkURLForFeatures(primary_accession, uniprot_sequence_MD5_hash, das_servers[currentServer], featureCallback);

		} else {
			console.log("process " + isFetchingFromServer);

			fetch_das_annotation_from_servers(primary_accession,
					uniprot_sequence_MD5_hash, das_servers[currentServer],
					featureCallback);
		}
	}
	else {
		console.log("finish DAS");
		var key = "FEATURE_" + primary_accession + getUrlParameter("features");
		cache.write(key, aggregatedAnnotations);
		featureCallback(aggregatedAnnotations);
	}
};

var finishServer = function(clustered_annotations, primary_accession,
		uniprot_sequence_MD5_hash, featureCallback) {

	// add to existing annotation record
	aggregatedAnnotations.push.apply(aggregatedAnnotations,
			clustered_annotations);

	// get next server
	processNextServer(primary_accession, uniprot_sequence_MD5_hash,
			featureCallback);
};

// cross Domain access to obtain additional features
function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();
  if ("withCredentials" in xhr) {
    // Check if the XMLHttpRequest object has a "withCredentials" property.
    // "withCredentials" only exists on XMLHTTPRequest2 objects.
    xhr.open(method, url, true);
  } else if (typeof XDomainRequest != "undefined") {
    // Otherwise, check if XDomainRequest.
    // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
    xhr = new XDomainRequest();
    xhr.open(method, url);
  } else {
    // Otherwise, CORS is not supported by the browser.
    xhr = null;
  }
  return xhr;
}

function parseExternalFeatures(primary_accession, uniprot_sequence_MD5_hash, das_server, featureCallback, data){
	var sequence_annotations = {};
	for (var category in data) {
		  if (data.hasOwnProperty(category)) {
			add_external_annotation(primary_accession, sequence_annotations, data[category], "External Features (JSON)", category);
		  }
	}
	var clustered_annotations = clusterRegions(sequence_annotations, das_server['Categories']);

	finishServer(clustered_annotations, primary_accession,
			uniprot_sequence_MD5_hash, featureCallback);
}

function checkURLForFeatures(primary_accession, uniprot_sequence_MD5_hash, das_server, featureCallback){
	var url = getUrlParameter("features");
	if (url){
	  $.getJSON( url, function (responseJSON) { //After load, parse data returned by xhr.responseText
			parseExternalFeatures(primary_accession, uniprot_sequence_MD5_hash, das_server, featureCallback, responseJSON);
	    });
	} else {
		finishServer(new Array(), primary_accession, uniprot_sequence_MD5_hash,
			featureCallback);
	}
}

/**
 * This function collects all annotations for a given protein id from a
 * specified server
 */
fetch_das_annotation_from_servers = function(primary_accession,
		uniprot_sequence_MD5_hash, das_server, featureCallback) {

	console.log("DAS server:" + das_server['Server'] + ' url '
			+ das_server['URL'] + ' primary id ' + primary_accession);

	var das_client = JSDAS.Simple.getClient(das_server['URL']);
	// Asking the das_client to retrieve the annotations for the requested
	// protein
	das_client.features({
		segment : primary_accession
	}, function(res) {
		// getting all the sequence specific annotations
		if (hasOwnProperty(res, "GFF") && hasOwnProperty(res.GFF, "SEGMENT")){
			var annotations = res.GFF.SEGMENT[0].FEATURE;
			var clustered_annotations = new Array();
			sequence_annotations = {};
			protein_annotations = {};

			if (typeof annotations !== 'undefined' && annotations !== null){

				for ( var i = 0; i < annotations.length; i++) {
					var ann = annotations[i];
					if (!ann.START || !ann.END) {
						add_annotation(primary_accession, protein_annotations, ann,
								das_server['Server'], das_server['Categories']);
					} else {
						add_annotation(primary_accession, sequence_annotations, ann,
								das_server['Server'], das_server['Categories']);
					}
				}

				// console.log("DAS:" + Object.size(protein_annotations)
				// + ' protein annotation and '
				// + Object.size(sequence_annotations)
				// + ' position specific annotations fetched');

				clustered_annotations = clusterRegions(sequence_annotations,
						das_server['Categories']);
			}
		}
		finishServer(clustered_annotations, primary_accession,
				uniprot_sequence_MD5_hash, featureCallback);

	}, function() {
		console.log('DAS: bad response, Could not retrieve data from '
				+ das_server['URL'] + '.');
		finishServer(new Array(), primary_accession, uniprot_sequence_MD5_hash,
				featureCallback);
	});

	// das_client.sequence({
	// segment : primary_accession
	// }, function(res) {
	// seq = res.SEQUENCE[0].textContent;
	//
	// sequenceCallback(seq);
	// }, function() {
	// console.log('DAS: bad response, Could not retrieve data from '
	// + das_server['URL'] + '.');
	// });
};

},{"../common/cache":18}],7:[function(require,module,exports){
var cache = require('../common/cache')();

var handlePredictProtein = require('./handlePredictProtein')
var handleSnap2 = require('./handleSnap2')
var handleCath = require('./handleCath')

var servers = [
		{
			"id": 'features',
			"Server" : 'Added Features',
			"URL" : '',
			"Categories" : {
				"default" : {
					"track" : "multi_track",
					"color" : "single_color"
				}
			}
		},
		{
			"id": 'PredictProtein',
			"Server": 'PredictProtein',
			"URL": 'https://api.predictprotein.org/v1/results/molart/',
		},
		{
			"id": 'SNAP2',
			"Server": 'SNAP2',
			"URL": 'https://rostlab.org/services/aquaria/snap4aquaria/json.php?uniprotAcc=',
		},
		{
			"id": 'CATH',
			"Server": 'CATH',
			"URL": 'http://www.cathdb.info/version/v4_2_0/api/rest/uniprot_to_funfam/',
			// ?content-type=application/json
		},
//		{
//			"Server" : 'InterPro',
//			"URL" : 'http://www.ebi.ac.uk/das-srv/interpro/das/InterPro-matches-overview/',
//			"Categories" : {
//				"Inferred from InterPro motif similarity" : {
//					"track" : "multi_track",
//					"color" : "multi_color"
//				},
//				"default" : {
//					"track" : "multi_track",
//					"color" : "multi_color"
//				}
//			}
//		},
		{
			"id": "UniprotFeatures",
			"Server" : 'UniProt',
			"URL" : 'http://uniprot.org/uniprot',
			"Categories" : {
				"Region" : {
					"track" : "multi_track", // possible values:
												// "single_track","multi_track"
					"color" : "multi_color" // possible values:
											// "#RGBcolor","single_color","multi_color"
				},
				"Site" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"Amino acid modification" : {
					"track" : "multi_track",
					"color" : "single_color"
				},
				"Amino acid modification;post translational modification" : {
					"track" : "multi_track",
					"color" : "#993404"
				},
				"sequence variant" : {
					"track" : "multi_track",
					"color" : "single_color"
				},
				"Sequence variation;natural variant site" : {
					"track" : "multi_track",
					"color" : "#FFD64F"
				},
				"Sequence variation;mutated variant site" : {
					"track" : "multi_track",
					"color" : "#E34C94"
				},
				"Experimental information" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"Molecule processing" : {
					"track" : "multi_track",
					"color" : "multi_color"
				},
				"default" : {
					"track" : "multi_track",
					"color" : "multi_color"
				}
			}

		// }, {
		// "Server" : 'SignalP',
		// "URL" : 'http://das.cbs.dtu.dk:9000/das/cbs_sort/',
		// "Categories" : {
		// "Inferred from electronic annotation" : { "track":"multi_track",
		// "color":"multi_color"}
		// }
		// }, {
		// "Server" : 'Pride',
		// "URL" : 'http://www.ebi.ac.uk/pride-das/das/PrideDataSource/',
		// "Categories" : {
		// "coverage" : { "track":"multi_track", "color":"multi_color"}
		// }
		}
		];

// available set of colors
var feature_colors = [ "#253494", "#1162dc", "#7B87C2", "#8AAAD9", "#5BC48F",
		"#00AE95", "#76B043", "#AED477", "#E4C8A7", "#FFD64F", "#E6B222",
		"#818C43", "#D77D2A", "#F8AD7C", "#E39FC6", "#E34C94", "#993404" ];
// indicates if currently accessing remote servers
var isFetchingData = false;
// indicates which server is accessed
var isFetchingFromServer = "";
// current server index
var currentServer = -1;
// contains current records of all annotations
var aggregatedAnnotations;

// color handling
/**
 * This function hashes a string into the color range adapted from
 * http://erlycoder.com/49/javascript-hash-functions-to-convert-string-into-integer-hash-
 */
var djb2Code = function(str, bins) {
	var hash = 5381;
	for ( var i = 0; i < str.length; i++) {
		char = str.charCodeAt(i);
		hash = ((hash << 5) + hash) + char; /* hash * 33 + c */
	}
	return Math.abs(hash % bins);
};

function capitaliseFirstLetter(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
}

if (typeof String.prototype.startsWith != 'function') {
	// see below for better implementation!
	String.prototype.startsWith = function(str) {
		return this.indexOf(str) == 0;
	};
}

// http://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression
function stripScripts(s) {
  var div = document.createElement('div');
  div.innerHTML = s;
  var scripts = div.getElementsByTagName('script');
  var i = scripts.length;
  while (i--) {
    scripts[i].parentNode.removeChild(scripts[i]);
  }
  return div.innerHTML;
}

/**
 * This helper function to annotations to the json object - one at a time
 */
var add_external_annotation = function(primary_accession, json_object, ann, das_server,
		category) {
	var ann_key;
	var categorytype = category.trim().replace(")","").split("(");
	// add emtpy category
	if (categorytype.length == 1){
		categorytype.push("");
	}
	var ann_key = das_server + "|:|" + categorytype[0] + "|:|" + categorytype[1];
	var ann_track = ann["track"] || "multi_track";
	var ann_color = ann["color"] || "single_color";

	for ( var i = 0; i < ann.Features.length; i++) {
		var f = ann.Features[i];

		var feat_name = f.Name;
		var feat_label = f.Name.replace(/_/g, ' ');
		var feat_desc = stripScripts(f.Description);
		var feat_start;
		var feat_end;
		var feat_color;

		if (f.Color){
			// if the JSON file specifies a color for this individual feature, then use it
			feat_color = f.Color;
		} else if (ann.Color){
			// if the JSON file specifies a feature set color, then use it for all features
			feat_color = ann.Color;
		} else {
			feat_color = feature_colors[djb2Code(feat_label, feature_colors.length)];
		}

		var setResidueRange = function(resRange){
			var res = resRange.toString().split("-")
			if (res.length > 1){
			  feat_start = parseInt( res[0]);
			  feat_end = parseInt( res[1]);
			}
			else{
			  feat_start = parseInt( res[0]);
			  feat_end = parseInt( res[0]);
			}
		  }
	  
		  var apiConvert = function(Residues){
			if(Residues.length < 1){
			  setResidueRange(Residues[0])
			}
			else{
			  Residues.forEach(function(r){
			  setResidueRange(r)
				})
			}
		}
	  
		if (typeof f.Residues === "object"){
      if(das_server === "PredictProtein"){
        apiConvert(f.Residues)
      }
      else{
        feat_start = parseInt( f.Residues[0]);
			  feat_end = parseInt( f.Residues[1]);
      }
		} else if (typeof f.Residue !== 'undefined'){
			feat_start = parseInt( f.Residue);
			feat_end = parseInt( f.Residue);
		} else {
			feat_start = parseInt( f.Residues);
			feat_end = parseInt( f.Residues);
		}

		var feat_url = [];
		if (ann.Source) {
			feat_url.push({
				"href" : ann.URL,
				"text" : ann.Source
			});
		}

		var new_region = {
				"color" : feat_color,
				"name" : feat_name,
				"label" : feat_label,
				"desc" : feat_desc,
				"start" : feat_start,
				"end" : feat_end,
				"size" : feat_end - feat_start,
				"urls" : feat_url,
				"show" : true
			};

		if (!(ann_key in json_object)) {
			// add new annotation type
			json_object[ann_key] = {
				"ProteinID" : primary_accession,
				"Server" : das_server,
				"Category" : categorytype[0],
				"Type" : categorytype[1],
				"Method" : "",
				"Tracks" : [ new_region ],
				"track" : ann_track,
				"color" : ann_color
			};
		} else {
			// add new region to existing annotation category
			cur_ann_type = json_object[ann_key];
			cur_ann_type["Tracks"].push(new_region);
		}
	}
}

/**
 * This helper function to annotations to the json object - one at a time
 */
var add_annotation = function(primary_accession, json_object, ann, das_server,
		categories) {
	var filter_key;

	if (ann.TYPE.category !== undefined){
		var categorytype = capitaliseFirstLetter(ann.TYPE.category.replace(
				/ *\(.*?\) */g, ""));
		var categorytext = ann.TYPE.textContent.replace(/_/g, " ");
	} else {
		// category not defined
		return
	}

	if (hasOwnProperty(categories, categorytype + ";" + categorytext)) {
		filter_key = categorytype + ";" + categorytext;
	} else if (hasOwnProperty(categories, categorytype)) {
		filter_key = categorytype;
	} else if (hasOwnProperty(categories, categorytext)) {
		filter_key = categorytext;
	} else {
		// no match
		return;
	}
	// console.log(categorytype + " found in " + categories);

	var ann_key = das_server + "|:|" + categorytype + "|:|"
			+ ann.TYPE.textContent;

	var feat_name = ann.id;
	var feat_label = ann.label.replace(/_/g, ' ');

	var feat_desc = [];
	if (ann.NOTE) {
		for ( var i = 0; i < ann.NOTE.length; i++) {
			// replace non-informative labels with non-empty note entry
			if (feat_label.toUpperCase().startsWith("UNIPROTKB")
					&& ann.NOTE[i].textContent != "") {
				feat_label = ann.NOTE[i].textContent;
			// skip redundant information in the notes
			} else if (ann.NOTE[i].textContent != feat_label){
				feat_desc.push(ann.NOTE[i].textContent);
			}
		}
	}

	var feat_color;
	if (categories.hasOwnProperty(filter_key)
			&& categories[filter_key]["color"] == "multi_color") {
		// multi-color features have a color per feature
		feat_color = feature_colors[djb2Code(feat_label, feature_colors.length)];

	} else if (categories.hasOwnProperty(filter_key)
			&& categories[filter_key]["color"] == "single_color") {
		// single-color features based on category text key hash
		feat_color = feature_colors[djb2Code(categorytext,
				feature_colors.length)];
	} else {
		// single-color features based on given color
		feat_color = categories[filter_key]["color"];
	}

	var feat_start = (ann.START) ? parseInt(ann.START.textContent) : 0;
	var feat_end = (ann.END) ? parseInt(ann.END.textContent) : 0;

	var feat_url = [];
	if (ann.LINK) {
		for ( var i = 0; i < ann.LINK.length; i++) {
			feat_url.push({
				"href" : ann.LINK[i].href,
				"text" : ann.LINK[i].textContent
			});
		}
	}

	var new_region = {
		"color" : feat_color,
		"name" : feat_name,
		"label" : feat_label,
		"desc" : feat_desc.join('\n'),
		"start" : feat_start,
		"end" : feat_end,
		"size" : feat_end - feat_start,
		"urls" : feat_url,
		"show" : true
	};

	if (!(ann_key in json_object)) {
		// add new annotation type
		json_object[ann_key] = {
			"ProteinID" : primary_accession,
			"Server" : das_server,
			"Category" : categorytype,
			"Type" : ann.TYPE.textContent.replace(/_/g, ' '),
			"Method" : ann.METHOD.textContent,
			"Tracks" : [ new_region ]
		};
	} else {
		// add new region to existing annotation category
		cur_ann_type = json_object[ann_key];
		cur_ann_type["Tracks"].push(new_region);
	}
};

/**
 * optimize color handling for multi-track features
 *
 * @param category
 * @param multitracks
 */
function optimizeColors(category, multitracks) {
	// catalog all labels
	var labels = {};
	for ( var track_num = 0; track_num < multitracks.length; ++track_num) {
		for ( var j = 0; j < multitracks[track_num].length; j++) {
			if (hasOwnProperty(labels, multitracks[track_num][j]["label"])) {
				labels[labels, multitracks[track_num][j]["label"]] += 1
			} else {
				labels[labels, multitracks[track_num][j]["label"]] = 1
			}
		}
	}

	var num_terms = Object.size(labels);
	var term_arr = Object.keys(labels);
	// get color set offset from feature category to allow diverse color sets
	var offset = djb2Code(category, feature_colors.length);

	// calculate color
	for ( var track_num = 0; track_num < multitracks.length; ++track_num) {
		for ( var j = 0; j < multitracks[track_num].length; j++) {
			i = term_arr.indexOf(multitracks[track_num][j]["label"]);
			multitracks[track_num][j]["color"] = feature_colors[(offset + Math
					.round(i * feature_colors.length / num_terms))
					% feature_colors.length];
		}
	}
}

/**
 * cluster region features into tracks with non-overlapping features
 */
function clusterRegions(sequence_annotations, categories, aboutFeaturesource) {
	var clusters = new Array();

	for (var annotation in sequence_annotations) {

		var feat_class = sequence_annotations[annotation]["track"];//categories[filter_key]["track"];
		if (feat_class == "multi_track") {
			// multi-line features

			var new_tracks = new Array();
			var tracks = sequence_annotations[annotation]["Tracks"];

			// sort tracks by size of the region spanned
			tracks.sort(compareAnnotationRegions);

			// detect collisions
			while (tracks.length > 0) {
				var region = tracks.pop();

				var found_spot = false;
				var track_num = 0;
				var collision = false;

				while (track_num < new_tracks.length & !found_spot) {
					for ( var j = 0; j < new_tracks[track_num].length; j++) {
						if ((new_tracks[track_num][j].start <= region.start && region.start <= new_tracks[track_num][j].end)
								|| (new_tracks[track_num][j].start <= region.end && region.end <= new_tracks[track_num][j].end)) {
							// collision found in this track, stop and start
							// checking next track
							track_num += 1;
							collision = true;
							break;
						}
					}
					if (!collision) {
						found_spot = true;
						break;
					}
					collision = false;
				}

				if (found_spot) {
					new_tracks[track_num].push(region);
				} else {
					new_tracks.push(new Array(region));
				}
			}

			if (sequence_annotations[annotation]["color"] == "multi_color") {
				optimizeColors(sequence_annotations[annotation]["Category"],
						new_tracks);
			}

			clusters.push({
				"ProteinID" : sequence_annotations[annotation]["ProteinID"],
				"About"	: aboutFeaturesource,
				"Server" : sequence_annotations[annotation]["Server"],
				"Class" : {
					track : sequence_annotations[annotation]["track"],
					color : sequence_annotations[annotation]["color"]
				},
				"Category" : sequence_annotations[annotation]["Category"],
				"Method" : sequence_annotations[annotation]["Method"],
				"Type" : sequence_annotations[annotation]["Type"],
				"Tracks" : new_tracks
			});

		} else if (feat_class == "single_track") {
			// single-line features
			clusters.push({
				"ProteinID" : sequence_annotations[annotation]["ProteinID"],
				"About"	: aboutFeaturesource,
				"Server" : sequence_annotations[annotation]["Server"],
				"Class" : sequence_annotations[annotation]["track"],
				"Category" : sequence_annotations[annotation]["Category"],
				"Method" : sequence_annotations[annotation]["Method"],
				"Type" : sequence_annotations[annotation]["Type"],
				"Tracks" : [ sequence_annotations[annotation]["Tracks"] ]
			});

		} else {
			console.log("ERROR: Feature class not known");
		}
	}
	return clusters;
}

/**
 * This function compares two regions based of their size
 *
 * @param a
 *            region 1
 * @param b
 *            region 2
 * @returns {Number}
 */
function compareAnnotationRegions(a, b) {
	if (a.size < b.size)
		return -1;
	if (a.size > b.size)
		return 1;
	return 0;
}

/**
 *
 * This function calculates the size of an object
 *
 * @param obj
 * @returns {Number}
 */
Object.size = function(obj) {
	var size = 0;
	for ( var key in obj) {
		if (obj.hasOwnProperty(key))
			size++;
	}
	return size;
};

/**
 * This function checks if an object has a given property
 *
 * @param obj
 *            object
 * @param prop
 *            property
 * @returns {Boolean} true if object has property, false otherwise
 */
function hasOwnProperty(obj, prop) {
	var proto = obj.__proto__ || obj.constructor.prototype;
	return (prop in obj) && (!(prop in proto) || proto[prop] !== obj[prop]);
}

/**
 * reset current DAS annotation set
 */
function resetDASAnnotations() {

	isFetchingData = false;
	isFetchingFromServer = "";
	currentServer = -1;
	aggregatedAnnotations = new Array();
}

function getAllFeatureNamesRequested(primary_accession){
	let features = []

	// URL
	if(getUrlParameter("features") != ''){
		features.push("features");
	};


	// Uniprot
	if(getUrlParameter("UniprotFeatures") != ''){
		features.push("UniprotFeatures");
	};


	// PredictProtein
	if(getUrlParameter("PredictProtein") != ''){
		features.push("PredictProtein");
	};

	// Snap2
	if(getUrlParameter("SNAP2") != ''){
		features.push("SNAP2");
	};


	features.push('CATH')


	// Cath

	// BindPredict


	return (features)
}

function fetch_annotations(primary_accession,
		featureCallback) {

	// reset annotations

	// HANDLE CACHE HERE

	// let keys = getAllFeatureParameterKeys(primary_accession)
	/*
	var key = "FEATURE_" + primary_accession + getUrlParameter("features");

	var cacheValue = cache.read(key);

	if (cacheValue) {
		// return cache result for immediate display
		featureCallback(cacheValue);
	}
	*/

	// get fresh set of annotations as well
	console.log("fetch_features.fetch_annotations: reset DAS annotations");
	resetDASAnnotations();

	processNextServer(primary_accession,
			featureCallback);
};

var axios = require('axios');

function getJsonFromUrl(requestedFeature, url, primary_accession, featureCallback){
	let featuresFromExtServer = {};

	axios({
		method: 'get',
		url: url,
	})
	.then(function (response) {
		// handle success
		// console.log("Success");
		// console.log(response.data);
		console.log("fetch_features.getJsonFromUrl data recieved successfully for " + primary_accession )
		// featuresFromExtServer['status'] = "success";
		// featuresFromExtServer['data'] = response.data;

		if (requestedFeature == 'PredictProtein'){
			// convert feature first
			handlePredictProtein(response.data, primary_accession, featureCallback, validateAquariaFeatureSet)
		}
		if (requestedFeature == 'SNAP2'){
			handleSnap2(response.data, primary_accession, featureCallback, validateAquariaFeatureSet)
		}
		if (requestedFeature == 'CATH'){
			// console.log("####################### Cath features obtained successfully! ")
			// console.log(response.data)
			handleCath(response.data, getJsonFromUrl, validateAquariaFeatureSet, primary_accession, featureCallback)
		}

		// return featuresFromExtServer
	})
	.catch(function (error) {
		// handle error
		console.log("###################### Error " + requestedFeature);
		console.log(error);


		finishServer(new Array(), primary_accession,
			featureCallback)

		// return featuresFromExtServer
	});


	return featuresFromExtServer
}



var StorageLRU = require('storage-lru').StorageLRU;
var asyncify = require('storage-lru').asyncify;
// var lru = new StorageLRU(asyncify(localStorage));

var lru = new StorageLRU(
    asyncify(localStorage),
    {
        revalidateFn: function(key, callback) {
            var newValue = someFunctionToRefetchFromSomewhere(key); // most likely be async
            callback(null, newValue); // make sure callback is invoked
        }
    });


/**
 * Process the next annotation resource and add their annotations
 */
var processNextServer = function(primary_accession,
		featureCallback) {

	currentServer += 1;
	isFetchingData = true;

	// get DAS servers first
	if (currentServer < servers.length) {

			// is feature requested by user

		console.log("fetch_features.processNextServer isFetchingFromServer = ", servers[currentServer]['Server']);

		if (servers[currentServer]['Server'] == "Added Features"){
			// check URL for json url
			try {
				checkURLForFeatures(primary_accession, servers[currentServer], featureCallback);
			} catch (error) {
				console.error(error);
			}
			finally {
				processNextServer(primary_accession,
					featureCallback);
			}
		}
		else if (servers[currentServer]['Server'] == "UniProt"){

			// fetch_uniprot(primary_accession, servers[currentServer], featureCallback);
			lru.getItem(primary_accession + '_' + servers[currentServer]['Server'], {json: false}, function (err, value) {

				if (err) {
					// something went wrong, for example, can't deserialize
					console.log('^^ Failed to fetch item: err=', err);
					fetch_uniprot(primary_accession, servers[currentServer], featureCallback);
					featureCallback(aggregatedAnnotations);
				}
				else{
					console.log('fetch_features.processNextServer Found in cache ', servers[currentServer]['Server'] )
					finishServer(JSON.parse(value), primary_accession, featureCallback)
					featureCallback(aggregatedAnnotations);
				}

			});

		}
		else if (servers[currentServer]['id'] == 'PredictProtein'){

			lru.getItem(primary_accession + '_' + servers[currentServer]['id'], {}, function (err, value) {

				if (err) {
				    // something went wrong, for example, can't deserialize
				    console.log('^^ Failed to fetch item: err=', err);
					getJsonFromUrl(servers[currentServer]['id'], servers[currentServer]['URL'] + primary_accession, primary_accession, featureCallback, validateAquariaFeatureSet)
					featureCallback(aggregatedAnnotations);
				}
				else{
					console.log('fetch_features.processNextServer Found in cache ', servers[currentServer]['id'] )
					console.log(typeof JSON.parse(value))
					finishServer(JSON.parse(value), primary_accession, featureCallback)
					featureCallback(aggregatedAnnotations);
				}

			});


		}
		else if (servers[currentServer]['id'] == 'SNAP2'){

			lru.getItem(primary_accession + '_' + servers[currentServer]['id'], {json: false}, function (err, value) {

				if (err) {
				    // something went wrong, for example, can't deserialize
				    console.log('^^ Failed to fetch item: err=', err);
					getJsonFromUrl(servers[currentServer]['id'], servers[currentServer]['URL'] + primary_accession, primary_accession, featureCallback, validateAquariaFeatureSet)
					featureCallback(aggregatedAnnotations);

				}
				else{
					console.log('fetch_features.processNextServer Found in cache ', servers[currentServer]['id'] )
					finishServer(JSON.parse(value), primary_accession, featureCallback)
					featureCallback(aggregatedAnnotations);
				}


			});

		}
		else if (servers[currentServer]['id'] == 'CATH'){
			console.log('############################ Requesting Cath features')

			lru.getItem(primary_accession + '_' + servers[currentServer]['id'], {json: false}, function (err, value) {

				if (err) {
					// something went wrong, for example, can't deserialize
					console.log('^^ Failed to fetch item: err=', err);
					getJsonFromUrl(servers[currentServer]['id'], servers[currentServer]['URL'] + primary_accession + "?content-type=application/json", primary_accession, featureCallback, validateAquariaFeatureSet)
					featureCallback(aggregatedAnnotations);
				}
				else{
					console.log('fetch_features.processNextServer Found in cache ', servers[currentServer]['id'] )
					finishServer(JSON.parse(value), primary_accession, featureCallback)
					featureCallback(aggregatedAnnotations);
				}


			});


		}


		/* isFetchingFromServer = servers[currentServer]['Server'];
		if (isFetchingFromServer == "External Features (JSON)"){
			// check URL for json url
			checkURLForFeatures(primary_accession, servers[currentServer], featureCallback);
		} else if (isFetchingFromServer == "Uniprot"){
			console.log("fetch_features.processNextServer process " + isFetchingFromServer);
			fetch_uniprot(primary_accession, servers[currentServer], featureCallback);
		} */
	}
	else {
		console.log("fetch_features.processNextServer finish DAS");
		var key = "FEATURE_" + primary_accession + getUrlParameter("features");
		cache.write(key, aggregatedAnnotations);
		featureCallback(aggregatedAnnotations);
	}
};

var finishServer = function(clustered_annotations, primary_accession,
		  featureCallback) {

	// add to existing annotation record
	try{
		aggregatedAnnotations.push.apply(aggregatedAnnotations,
				clustered_annotations);
	}
	catch(error){
		console.log("Error during pushing")
		console.log(error)
	}


	// get next server
	processNextServer(primary_accession,
			featureCallback);
};





const Ajv = require('ajv');
function validateAquariaFeatureSet(convertedFeatureSet, primary_accession, featureCallback, featureId){

	const ajv = new Ajv({
  		verbose: true
	});

	var schema = {
		"type": "object",
		"minProperties": 1,
		"properties":{
			"About": {
				"type": "object",
				"properties": {
					"Title": {"type": "string"},
					"DOI": {"type": "string"},
					"Description": {"type": "string"},
					"Sequence_hash": {"type": "string"},
				},
				additionalProperties: false,
			},
			additionalProperties: false,
		},
		"patternProperties": {
			"^.+$": {
				"type": "object",
				"properties": {
					"Features": {
						"type": "array",
						"items": {
							"type": "object",
							"properties": {
								"Name": {'type': "string"},
								'Residue': {
									'type': "integer",
									'minimum': 1,
								},
								'Residues': {
									'type': 'array',
									'items':{
										'type': ['integer',
										'string'],
										'minimum': 1,
									},
									"minItems": 1,
								},
								'Color': {'type': 'string'},
								'Description': {'type': 'string'},
								'Connected': {'type': ['boolean', 'array']}
							},
							additionalProperties: false,
							"required": ["Name"],
							'oneOf': [
								{'required': ['Residue']},
								{'required': ['Residues']},
							],

						},
						minProperties: 1,
					},
					"Source": {"type": "string"},
					"URL": {"type": "string"},
					"Description": {"type": "string"},
					additionalProperties: false,
				},
				"required": ['Features'],
				additionalProperties: false,
			},
		},
		additionalProperties: false
	}

	var isValid = ajv.validate(schema, convertedFeatureSet);

	if (isValid){
		// continue
		console.log("fetch_features.validateAquariaFeatureSet appending validated features " + 'PredictProtein')

		parseFeatures(primary_accession, '', featureId,featureCallback, convertedFeatureSet, '')
		// finishServer(convertedFeatureSet, primary_accession, featureCallback);
	}
	else {
		// cannot display these features
		console.log("fetch_features.validateAquariaFeatureSet " + ajv.errorsText())
		finishServer(new Array(), primary_accession,
			featureCallback);
	}

	// ajv.addMetaSchema(require());
	// console.log(ajv.validate(schema, convertedFeatureSet).errors)
	// console.log('ERRORS: ', this.ajv.errors)
	//return (isValid)
}




// cross Domain access to obtain additional features
function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();
  if ("withCredentials" in xhr) {
    // Check if the XMLHttpRequest object has a "withCredentials" property.
    // "withCredentials" only exists on XMLHTTPRequest2 objects.
    xhr.open(method, url, true);
  } else if (typeof XDomainRequest != "undefined") {
    // Otherwise, check if XDomainRequest.
    // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
    xhr = new XDomainRequest();
    xhr.open(method, url);
  } else {
    // Otherwise, CORS is not supported by the browser.
    xhr = null;
  }
  return xhr;
}

/**
 * Converts a uniprot xml document to the external JSON format for features, as described here:
 * https://docs.google.com/document/d/1wFJjdyl1OASnsBNkUzUx4ME8YhVybhIWCTr3Z1fBEWQ/pub
 */
function parseUniprot(xml) {

	var data = {};
	$(xml).find("feature").each(function() {
		var type = capitaliseFirstLetter($(this).attr("type"));
		var feature = {};

		switch(type) {
		case "Helix":
//			feature.Color = "#568AB5";
//			type = "Secondary Structure";
//			break;
		case "Strand":
//			feature.Color = "#FFC900";
//			type = "Secondary Structure";
//			break;
		case "Turn":
//			feature.Color = "#639941";
//			type = "Secondary Structure";
			return;
			break;

		}

		if (!hasOwnProperty(data, type)) {
			data[type] = {"Source" : "UniProt", "URL" : "https://www.uniprot.org", "Features" : []};
			if (type == "Sequence variant" ||
					type == "Mutagenesis site" ||
					type == "Modified residue" ||
					type == "Site") {
				data[type]["Color"] = feature_colors[djb2Code(type.replace(/_/g, ' '), feature_colors.length)];
			}
		}

		// feature description (optional)
		var description = $(this).attr("description") || "";

		// feature name (optional)
		var name = undefined;
		var original = $(this).find("original");
		if (original.length) {
			name = original.first().text();
			var variation = $(this).find("variation");
			if (variation.length) {
				name += " > " + variation.first().text();
			}
		};

		var residues = [];
		var loc = $(this).find("location");
		loc.each(function() {	// each location can be either a single position or a range
			// this returns an array of positions
			var pos = $(this).children().map(function() {
				return $(this).attr("position");
			}).get();

			residues = residues.concat(pos);
		});
		if (residues.length == 1) {
			feature["Residue"] = residues;
		} else {
			feature["Residues"] = residues;
		}

		feature["Name"] = name || description;
		feature["Description"] = name ? description : "";

		data[type]["Features"].push(feature);
	});

	return data;

}

function parseFeatures(primary_accession, categories, server, featureCallback, data, sourceURL){
	var sequence_annotations = {};
	var aboutSource = {};
	var description = "";
	if (server === "PredictProtein"){
		// console.log(" +++++++++++++++++++++++++ " + data)
	}
	for (var category in data) {
		  if (data.hasOwnProperty(category)) {
			if (category === "About"){
				var aboutSource = data[category];
				for (var attr in aboutSource) {
					if(attr === "Title"){
            			description = description.concat("<h3 class='infoHeader'><b>" + aboutSource[attr] + "</b></h3>")
					}
					else if (attr === "DOI"){
						description = "<a href=" + aboutSource[attr] + ">" + description + "</a>"
						description = description.concat("</br>")
					}
          			else if (attr === "Description"){
						description = description.concat("<p>" + aboutSource[attr] + "</p>")
					}
					else{
						description = description.concat("<p>" + aboutSource[attr] + "</p>")
          			}
				}
			}
			else if (server === "UniProt"){
				description = "For each protein, <a href='https://www.uniprot.org/'>UniProt</a> provides a comprehensive set of \
				carefully curated features, typically including domains, sequence variants, post-translational modifications (PTMs), \
				active sites, and binding sites."
			}
			else if (server === "PredictProtein"){
				description = "<a href='https://predictprotein.org/'>PredictProtein</a> provides computational predictions of \
				structural annotations, such as \
				<a href='https://rostlab.org/owiki/index.php/PredictProtein_-_Documentation#Secondary_structure_.28PROF.29'>\
				secondary structures</a>, \
				<a href='https://rostlab.org/owiki/index.php/NORSp_-_predictor_of_NOn-Regular_Secondary_Structure'> \
				non-regular secondary structures </a>, \
				<a href='https://rostlab.org/owiki/index.php/PredictProtein_-_Documentation#Solvent_accessibility_.28PHDacc.29'>\
				solvent accessibility</a>, <a href='https://rostlab.org/owiki/index.php/Metadisorder'> intrinsically disordered regions \
				</a>, <a href='https://rostlab.org/owiki/index.php/PROFbval'> residue mobility </a> and \
				<a href='https://github.com/Rostlab/ConSurf'> evolutionary conservation of amino acid positions </a>. \
				Additionally, predictions may also be included for \
				<a href='https://rostlab.org/owiki/index.php/PROFphd_-_Secondary_Structure,_Solvent_Accessibility_and_Transmembrane_Helices_Prediction'> \
				transmembrane helices </a>, trans-membrane beta barrel structures, disulphide bridges and \
				<a href='https://rostlab.org/owiki/index.php/PredictProtein_-_Documentation#Contact_Prediction_.28PROFcon.29'>\
				inter-residue contacts</a>."
			}
			else if (server === "SNAP2"){
				description = "<a href='https://www.rostlab.org/services/snap/'>SNAP2</a> provides computational predictions of the \
				effect of amino acid changes upon protein function."
			}
			else if (server === "CATH") {
				description = "<a href='http://www.cathdb.info/wiki'>CATH</a> provides domain information for proteins based on \
				functional similarity (FunFams), as well as domains based only on structural similarity (CATH superfamilies). \
				CATH provides extensive information for each domain, including functional annotations, species diversity, and enzyme \
				classifications."
			}
			else{
				description = description
			}

			if (category !== "About"){
				add_external_annotation(primary_accession, sequence_annotations, data[category], server , category);
			}
		  }
	}
	if(description === ""){
		description = description.concat("<p>This feature collection currently has no description. To add one, ask the author of the JSON file below to add an About property (described <a href='http://bit.ly/aquaria-features'>here</a>).</p>")
	}
	else{
		description = description.concat("<p><a href='" + sourceURL + "'>Source</a></p>")
	}
	var clustered_annotations = clusterRegions(sequence_annotations, categories, description);

	lru.setItem(
    primary_accession + '_' + server,    // key
    clustered_annotations, // obj value
    {             // options
        json: true,
        cacheControl:'max-age=300,stale-while-revalidate=86400'
    }, function (err) {
        if (err) {
            // something went wrong. Item not saved.
            console.log('^^^ Failed to save item: err=', err);
        }
		else{
			console.log("^^^ saved item ", primary_accession + '_' + server)
		}
		finishServer(clustered_annotations, primary_accession, featureCallback);
	}
	);

}

function checkURLForFeatures(primary_accession, server, featureCallback){
	var url = getUrlParameter("features");
	if (url){
		axios({
			method: 'get',
			url: url
		  })
		.then(function (responseJSON) {
			if(typeof(responseJSON["data"]) != "object"){
				processNextServer(primary_accession,
					featureCallback);
			}
			else{
				parseFeatures(primary_accession, server['Categories'], server['Server'], featureCallback, responseJSON["data"], url)
			}
		})
		//$.getJSON( url, function (responseJSON) { //After load, parse data returned by xhr.responseText
		// parseFeatures(primary_accession, server['Categories'], server['Server'], featureCallback, responseJSON, url);
		// });
	} else {
		// finishServer(new Array(), primary_accession,
		// 	featureCallback);
		processNextServer(primary_accession,
			featureCallback);
	}
}

/**
 * This function collects all annotations for a given protein id from a
 * specified server
 */
fetch_uniprot = function(primary_accession, server, featureCallback) {

	console.log("fetch_features.fetch_uniprot fetching features from uniprot...");
	url = "https://www.uniprot.org/uniprot/" + primary_accession + ".xml";
	$.ajax({url : url,
			type: "GET",
			dataType: "xml",
			error: function() {
				data = AQUARIA.remote.get_features(window.location.pathname.split('/')[1], function(orgNames) {
				  // console.log("features.displayOrgSynonyms: " + orgNames[0].Features)
				  parseFeatures(primary_accession, server['Categories'], server['Server'], featureCallback, JSON.parse(orgNames[0].Features), url)
				})
			  },
			success: function(xml) {
				data = parseUniprot(xml);
				parseFeatures(primary_accession, server['Categories'], server['Server'], featureCallback, data, url)
			}
	});

};

module.exports = fetch_annotations;
},{"../common/cache":18,"./handleCath":8,"./handlePredictProtein":9,"./handleSnap2":10,"ajv":19,"axios":62,"storage-lru":141}],8:[function(require,module,exports){
const url = require('highcharts');

 module.exports = function (jsonObj1, getFeatures, validateAgainstSchema, primary_accession, featureCallback){

	 console.log("$$$$$$$ Requesting CATH :)")
	 console.log(jsonObj1);

	// Stage 1:
	let convertedFeatures = {};
	let featureNames = []

	let funFamFeatureSet = []
	let superFamFeatureSet = []

	let keyFunFam = "Functional families (CATH-FunFams)"
	let keySuperFam = "Structural domains (CATH-SuperFamilies)"

	// array of residues; // Map of residues, {FunFam_number} => residues
	if (!jsonObj1.hasOwnProperty('data') || jsonObj1.data.length < 1){
		validateAgainstSchema(convertedFeatures, primary_accession, featureCallback, 'CATH')
	}
	sendTheMultipleRequests(jsonObj1).then(function(thePromises){
	//Promise.all(promises_funFamInfo).then(function(theData){
	Promise.all(thePromises.funFamInfo.concat(thePromises.cathDomains)).then(function(allTheData){

		//console.log("All the data")
		//console.log(allTheData)
		let trueNumOfFeatures = allTheData.length/2;

		// console.log(allTheData.length/2)
		allTheData.forEach(function(theRes, i){

			if (i < trueNumOfFeatures){
				// FunFam name.
				if (theRes.hasOwnProperty('data') && theRes['data'].hasOwnProperty('data') && theRes['data']['data'].hasOwnProperty('name')){

					featureNames.push(theRes.data.data.name)

				}
				else{
					featureNames.push(null)
				}

			}
			else {
				// handle cath domains

				let aConvertedFeature = {}
				let aFunFamFeature = {}
				let aSuperFamFeature = {}
				let aSuperFam_description = ""

				// name
				if (theRes.hasOwnProperty('data') && theRes['data'].hasOwnProperty('data')){
					console.log("The res")
					console.log(theRes);

					if (featureNames[i-trueNumOfFeatures] != null){
						aConvertedFeature['Name'] = "Functional family: " + featureNames[i-trueNumOfFeatures]

						// Add a functional family feature
						aFunFamFeature['Name'] = featureNames[i-trueNumOfFeatures]
					}

					if (theRes.data.data.hasOwnProperty('classification_name') && theRes.data.data.classification_name != null){
						// Add a super family feature
						aConvertedFeature['Name'] = "Superfam classification name: " + theRes.data.data.classification_name

						aSuperFamFeature['Name'] = theRes.data.data.classification_name
					}
					else if (theRes.data.data.hasOwnProperty('superfamily_id') && theRes.data.data.superfamily_id != null){
						aConvertedFeature['Name'] = "Superfamily ID: " + theRes.data.data.superfamily_id

						aSuperFamFeature['Name'] = theRes.data.data.superfamily_id

					}

					/*
					else if (theRes.data.data.hasOwnProperty('cath_id') && theRes.data.data.cath_id != null){
						aConvertedFeature['Name'] = "Superfamily ID: " + theRes.data.data.cath_id
					}
					else{
						aConvertedFeature['Name'] = "Unknown"
					}
					*/





					// description
					if (theRes.hasOwnProperty('data') && theRes['data'].hasOwnProperty('data') && theRes['data']['data'].hasOwnProperty('example_domain_id')){
						aSuperFam_description = "<i>Shown here is example domain:</i> <a href=\"https://www.cathdb.info/version/latest/domain/" +  theRes.data.data.example_domain_id +  "\" target=\"_blank\"> " + theRes.data.data.example_domain_id + " </a> <br> <img src='http://www.cathdb.info/version/v4_1_0/api/rest/id/" + theRes.data.data.example_domain_id + ".png?size=M' width='200' height='200' />"
					}


					if (Object.keys(aFunFamFeature).length > 0){
						let funFameFeat_res = handleResidues(thePromises.residues[i - trueNumOfFeatures], featureNames[i-trueNumOfFeatures], '')

						if (Object.keys(funFameFeat_res).length > 0){
							// add to set.
							funFamFeatureSet = funFamFeatureSet.concat(funFameFeat_res)

						}
					}



					if (Object.keys(aSuperFamFeature).length > 0){
						let superFameFeat_res = handleResidues(thePromises.residues[i - trueNumOfFeatures], featureNames[i-trueNumOfFeatures], aSuperFam_description)

						if (Object.keys(superFameFeat_res).length > 0){
							// add to set.
							superFamFeatureSet = superFamFeatureSet.concat(superFameFeat_res)

						}
					}


					// convertedFeatures = addToConvertedFeature(convertedFeatures, featureNames[i-trueNumOfFeatures], aConvertedFeature)

				}


			}

			// console.log("Counter " + i + " " + allTheData.length)
			if (i == (allTheData.length - 1)){



				convertedFeatures[keyFunFam] = {}
				convertedFeatures[keyFunFam]["Features"] = funFamFeatureSet

				convertedFeatures[keySuperFam] = {}
				convertedFeatures[keySuperFam]["Features"] = superFamFeatureSet


				console.log("The fun fam feature set")
				console.log(funFamFeatureSet)

				console.log("The fun fam feature set")
				console.log(superFamFeatureSet)

				console.log("The converted features are:  ");
				console.log(convertedFeatures);


				validateAgainstSchema(convertedFeatures, primary_accession, featureCallback, 'CATH')
				// return (convertedFeatures)
			}
		})
	}).catch(function(error){
		console.log("There was an error")
		console.log(error)

		validateAgainstSchema(convertedFeatures, primary_accession, featureCallback, 'CATH')
	})

	})
	.catch(function(error){
		console.log("Encountered error when sending requests to CATH")
		console.log(error);

		validateAgainstSchema(convertedFeatures, primary_accession, featureCallback, 'CATH')
	})

	return convertedFeatures

}
// http://www.cathdb.info/version/v4_2_0/superfamily/1.10.8.10/highcharts/ec
function handleResidues(res, featureName, description){

	let features = []


	/* if (theResidue.length == 1){
		// Add to feature set.
		features.append({'Name': featureName, 'Residue':theResidue, 'Description': description})
	}
	else { */
	let re = new RegExp("\-")

	if (!Array.isArray(res)){

		if (re.test(item)){
			let theResToDel = item.split(/\-/).map(Number)
			features.push({'Name': featureName, 'Residues': theResToDel, 'Description': description})
		}
		else{
			features.push({'Name': featureName, 'Residue': item, 'Description': description})
		}
	}
	else {
		res.forEach(function(item, i){
			if (re.test(item)){
				let theResToDel = item.split(/\-/).map(Number)
				features.push({'Name': featureName, 'Residues': theResToDel, 'Description': description})
			}
			else{
				features.push({'Name': featureName, 'Residue': item, 'Description': description})
			}
		});
	}


	// }

	return (features);
}


function sendTheMultipleRequests(jsonObj1){
	// also extracts residues,

	return new Promise(function(resolve, reject){

		let promises_funFamInfo = []
		let promises_superfamilyId = []
		let residues = [];
		let encountered_str = [];

		jsonObj1.data.forEach(function(funFam, i){
			if (funFam.hasOwnProperty('member_id') &&  funFam.hasOwnProperty('funfam_number') && funFam.hasOwnProperty('superfamily_id')){

				let aResidue = funFam.member_id.split('/')[1];

				if (!encountered_str.includes(aResidue)){
					// FunFam info
					promises_funFamInfo.push(getFromLocation("http://www.cathdb.info/version/v4_1_0/api/rest/superfamily/" + funFam.superfamily_id + "/funfam/" + funFam.funfam_number))

					// Cath domain info.
					promises_superfamilyId.push(getFromLocation("http://www.cathdb.info/version/v4_1_0/api/rest/superfamily/" + funFam.superfamily_id))

					encountered_str.push(aResidue)

					residues.push(aResidue.split(/\_+/))
					console.log("a residue is:" + aResidue)

				}


			}


			if (i == (jsonObj1.data.length -1)){
				/* Promise.all(arrPromises_funFamInfo).then(function(theData){
					resolve(theData);
				}) */
				//console.log(" i is " + i)
				//console.log(jsonObj1.data.length)

				resolve({'funFamInfo': promises_funFamInfo, 'cathDomains': promises_superfamilyId, 'residues': residues});
			}
		});
		//console.log(promises_funFamInfo)
		//return (promises_funFamInfo)
	});

}

var axios = require('axios')
function getFromLocation(url){
	return new Promise(function(resolve, reject){
		let featuresFromExtServer = {};

		axios({
			method: 'get',
			url: url,
		})
		.then(function (response) {
			// handle success
			// console.log("Success");
			// console.log(response.data);
			featuresFromExtServer['status'] = "success";
			featuresFromExtServer['data'] = response.data;
			resolve(featuresFromExtServer)
		})
		.catch(function (error) {
			// handle error
			console.log("Error");
			console.log(error);

			featuresFromExtServer['status'] = "error";
			resolve(featuresFromExtServer)
		});
	})
}



function addToConvertedFeature(convertedFeatures, featureKey, aFeature){
	console.log(featureKey)
	if(!convertedFeatures.hasOwnProperty(featureKey)){
		convertedFeatures[featureKey] = {}
		convertedFeatures[featureKey]['Features'] = []
	}

	convertedFeatures[featureKey]['Features'].push(aFeature)

	return (convertedFeatures)
}
},{"axios":62,"highcharts":99}],9:[function(require,module,exports){
const url = require('url');

module.exports = function (jsonObj, primary_accession, featureCallback, validateAgainstSchema){

	let aquariaJsonObj = {};

	const features_rost = 'features';

	let convertedFeature = undefined;

	Object.keys(jsonObj).forEach(function(key){
		// console.log(key);

		if (key == features_rost){
			// first; create the 'Feature' property in aquariaJson if not present
			/* if (!aquariaJsonObj.hasOwnProperty(features_od)){
				aquariaJsonObj[features_od] = [];
			} */



			// go through each feature
			jsonObj[key].forEach(function(feature){
				// console.log(feature);
				convertedFeature = convertTheFeature(feature);
				addToAquariaFeatures(convertedFeature, aquariaJsonObj);
			});
		}

		else{
			// Ignore
			// aquariaJsonObj[key] = jsonObj[key];
		}
	});
	console.log(aquariaJsonObj)
	validateAgainstSchema(aquariaJsonObj, primary_accession, featureCallback, 'PredictProtein')
	// console.log(aquariaJsonObj);
	//return (aquariaJsonObj);
}

function addToAquariaFeatures(convertedFeature, aquariaJsonObj){
	if (! aquariaJsonObj.hasOwnProperty(convertedFeature.featureKey)){
		aquariaJsonObj[convertedFeature.featureKey] =  {}; // [];
		aquariaJsonObj[convertedFeature.featureKey]['Features'] = [];
	}

	if (convertedFeature.sources.length > 0 && !aquariaJsonObj[convertedFeature.featureKey].hasOwnProperty('Source')){
		aquariaJsonObj[convertedFeature.featureKey]['Source'] = convertedFeature.sources[0];
	}

	if (convertedFeature.urls.length >0 && !aquariaJsonObj[convertedFeature.featureKey].hasOwnProperty('URL')){
		aquariaJsonObj[convertedFeature.featureKey]['URL'] = convertedFeature.urls[0];
	}

	aquariaJsonObj[convertedFeature.featureKey]['Features'].push(convertedFeature.convertedFeature);
}

function convertTheFeature(feature){
	let featureKey = '';
	let convertedFeature = {};
	let source_evidence = [];
	let url_evidence = [];

	let residue = [-1, -1]
	// console.log(feature);
	Object.keys(feature).forEach(function(key){
		if (key == 'type'){
			featureKey = feature[key];
		}

		if (key == 'ftId'){
			convertedFeature['Name'] = feature[key];
		}

		if (key == 'description'){
			convertedFeature['Description'] = feature[key];
		}

		if (key == 'begin'){
			residue[0] = feature[key];
		}

		if (key == 'end'){
			residue[1] = feature[key];
		}

		if (key == 'color'){
			convertedFeature['Color'] = feature[key];
		}

		if (key == 'evidences') {
			let sourceAndUrl = handleTheEvidences(feature[key]);

			if(sourceAndUrl.source != ''){
				source_evidence.push(sourceAndUrl.source);
			}
			if (sourceAndUrl.url != ''){
				url_evidence.push(sourceAndUrl.url);
			}
		}


	});


	if (residue[0] == residue[1]){
		convertedFeature['Residue'] = residue[0];
	}
	else{
		convertedFeature['Residues'] = [(residue[0] + '-' + residue[1])];
		console.log("Predict protein " + convertedFeature['Residues'])
		// console.log(residue);
	}

	/* Added this because ftId is not present in the normal API e.g. https://api.predictprotein.org/v1/results/molart/Q15084 */
	if (!convertedFeature.hasOwnProperty('Name')) {
		convertedFeature['Name'] = convertedFeature.Description
	}

	return ({'featureKey': featureKey, "convertedFeature": convertedFeature, 'urls': url_evidence, 'sources': source_evidence});
}

/* Function to extract url's if present (will later be added to the feature set itself).
*
*/
function handleTheEvidences(evidencesArr){
	let featureSet_source = '';
	let featureSet_url = '';

	evidencesArr.forEach(function(evidence){
		if (evidence.hasOwnProperty('source')){
			if (evidence.source.hasOwnProperty('name')){
				featureSet_source = evidence.source.name;
			}
			if (evidence.source.hasOwnProperty('url')){
				featureSet_url = url.parse(evidence.source.url).host;
			}

		}
	});

	return ({source: featureSet_source, url: featureSet_url})
}

},{"url":177}],10:[function(require,module,exports){
const url = require('url');

/* Remove additionalProperties & convert string-numbers to numbers */
module.exports = function (jsonObj, primary_accession, featureCallback, validateAgainstSchema){


	// console.log("In the handleSnap2 function")

	let theKeys = Object.keys(jsonObj);

	console.log(theKeys);

	Object.keys(jsonObj).forEach(function(featureSet){
		if (Object.keys(jsonObj[featureSet]).hasOwnProperty('Features')){

		}

		for (let i=0; i< jsonObj[featureSet]['Features'].length; i++){

			if(jsonObj[featureSet]['Features'][i].hasOwnProperty('Residue')){
				// console.log(jsonObj[featureSet]['Features'][i]['Residue'])

				jsonObj[featureSet]['Features'][i]['Residue'] = parseInt(jsonObj[featureSet]['Features'][i]['Residue'])

			}
			if(jsonObj[featureSet]['Features'][i].hasOwnProperty('Residues')){
				jsonObj[featureSet]['Features'][i]['Residues'] = jsonObj[featureSet]['Features'][i]['Residue'].map(function(x){
					return parseInt(x)
				});
				console.log("Snap2 " + jsonObj[featureSet]['Features'][i]['Residues'])
			}
			/* if (jsonObj[featureSet]['Features'][i].hasOwnProperty('Residue')){
				//jsonObj[featureSet]['Features'][i].Residue = parseInt(jsonObj[featureSet]['Features'][i].Residue)
			} */
		}
	})

	validateAgainstSchema(jsonObj, primary_accession, featureCallback, 'SNAP2')
	// return (jsonObj)
}

// module.exports = { handleSnap2 };

},{"url":177}],11:[function(require,module,exports){
var JoleculePanel = function(attachToDiv, chainSelected) {
  this.blankApplet();
  this.attachToDiv = attachToDiv;
  var n = attachToDiv.length
  var divId = attachToDiv.substring(1, n)
  var currentDiv = document.getElementById(divId);
  var newDiv = document.createElement("div")
  var newDivId = divId + '-inner'
  var newAttachToDiv = '#' + newDivId
  newDiv.setAttribute('id', newDivId)
  newDiv.setAttribute('style', 'padding-bottom: 10px; box-sizing: border-box; width: 100%; height: 100%')
  currentDiv.appendChild(newDiv);
  this.chainSelected = chainSelected;
  this.embededJolecule = jolecule.initEmbedJolecule({
    divTag: newAttachToDiv,
    isLoop: false,
    isGrid: true,
    isLegend: true,
    backgroundColor: "#cccccc",
    isEditable: true,
    isResidueSelector: false,
    isExtraEditable: true,
    isMenu: true,
    isToolbarOnTop: true,
    isToolbarOn: true,
    isTextOverlay: false,
    isMouseWheel: false
  });
  var alignment = new jolecule.AquariaAlignment()
  this.joleculeAlignment = alignment
  var controller = this.embededJolecule.controller

  this.embededJolecule.soupWidget.focus = function() {
    document.activeElement.blur()
  }

  document.onkeydown = function (event) {
    let c = String.fromCharCode(event.keyCode).toUpperCase()
    if (false) {
    } else if (event.keyCode === 37) {
      let isClear = !event.shiftKey
      controller.selectPrevResidue(isClear)
    } else if (event.keyCode === 39) {
      let isClear = !event.shiftKey
      controller.selectNextResidue(isClear)
    } else if (event.keyCode === 13) {
      controller.zoomToSelection()
    } else if (event.keyCode === 27) {
      alignment.selectSeq = ''
      controller.clearSelectedResidues()
    } else if (c === "C" && event.metaKey) {
      alignment.copyToClipboard()
    } else {
      if (document.activeElement === document.body) {
        if (c.match( /^[A-Z]+$/i)) {
          alignment.selectNextChar(c)
        }
      }
    }
  }

  document.addEventListener('paste', e => {
    if (document.activeElement !== document.body) {
      return
    }
    let data = e.clipboardData
    if (data && data.getData) {
      alignment.selectSeq = ''
      let text = data.getData('text/plain')
      console.log('AlignAquaria.paste', text)
      for (let c of text.toUpperCase()) {
        alignment.selectNextChar(c)
      }
    }
  })

};


JoleculePanel.prototype.load = function(attributes) {
  this.reload(attributes);
}

JoleculePanel.prototype.changeViewerSize = function(w, h) {
  this.embededJolecule.resize()
}

buildFeatures = function(featureNames, featureDescriptions, featurePositions, featureColours) {
  let features = []
  for (i = 0; i < featurePositions.length; i++) {
    featurePosition = featurePositions[i].split(":")
    featureStart = parseInt(featurePosition[0])
    featureEnd = parseInt(featurePosition[1])
    for (j = featureStart; j <= featureEnd; j++) {
      features.push({
        Residue: j,
        Color: featureColours[i],
        Name: featureNames[i],
        Description: featureDescriptions[i]
      })
    }
  }
  return features
}

JoleculePanel.prototype.addAnnotation = function(id, annotationName, featureColours, featureNames, featureDescriptions, featurePositions, featureURLs, featureURLTexts) {
  let features = buildFeatures(featureNames, featureDescriptions, featurePositions, featureColours)
  console.log(`JoleculePanel.addAnnotation ${id} "${annotationName}"`, features)
  this.joleculeAlignment.colorFromFeatures(this.embededJolecule, features, id, annotationName)
};

JoleculePanel.prototype.removeAnnotation = function(id, annotationName) {
  console.log('JoleculePanel.removeAnnotation', id, annotationName, this.embededJolecule)
  this.joleculeAlignment.colorFromConservation(this.embededJolecule)
};

JoleculePanel.prototype.setAlignment = function(attributes) {
  console.log('JoleculePanel.setAlignment', attributes)
  console.log("THIS IS ATTRIBUTE", this.embededJolecule);
  this.joleculeAlignment.reload(attributes, this.embededJolecule)
  var that = this;
  this.joleculeAlignment.selectNewChain = function(seqId, seqName, pdbId, chain) {
    if (seqId && !(seqId === that.seqId && chain === that.chain)) {
      console.log('JoleculePanel.setAlignment.selectNewChain', seqId, seqName, chain)
      that.chainSelected(seqId, pdbId, chain)
      that.seqId = seqId
      that.chain = chain
    }
  }
}

JoleculePanel.prototype.Mesh = function(){
  this.embededJolecule;
}

JoleculePanel.prototype.reload = function(attributes) {
  console.log('JoleculePanel.reload', attributes)
  attributes = attributes || this.attributes;
  this.attributes = attributes;
  this.seqId = attributes.sequences[0].primary_acccession
  this.embededJolecule.clear()

  // prevent chain switching from Jolecule inadvertently
  // telling Aquaria to switch proteins when loading and
  // the default chain is not the first
  this.joleculeAlignment.selectNewChain = () => {}

  let that = this
  this.embededJolecule.asyncAddDataServer(
      jolecule.makeDataServer(
        attributes.pdb_id,
        "",
        false,
        false,
        false,
        attributes.biounit)
    )
    .then(function() {
      that.setAlignment(attributes)
    })
    .then(function() {
      that.blankApplet(false);
      that.initialised = true;
    })
};

// JoleculePanel.prototype.exportGLTF = function(){


// // window.addEventListener('click', () => exportGLTF());

// }

JoleculePanel.prototype.generateAttributes = function(threeDWidth, threeDHeight, pdb_id, pdb_chain, biounit, source_primary_accession, sequences, common_names, pssh_alignment, links, transform,
  conservations) {
  var instanceId = sequences[0].primary_accession + '-' + pdb_id + '-' + pdb_chain[0];
  return {
    width: threeDWidth,
    height: threeDHeight,
    instanceId,
    biounit,
    pdb_id,
    pdb_chain,
    common_names,
    transform,
    alignment: pssh_alignment,
    conservations,
    sequenceAlignments: null,
    sequences
  };
};


JoleculePanel.prototype.gestures = function() {
  var ret = {};
  return ret;
}

JoleculePanel.prototype.blankApplet = function(isOn, message) {
  if (isOn) {
    var appletMessage = $('#waitingFrame').contents().find('#appletMessage');
    if (message) {
      appletMessage.html(message);
    } else {
      appletMessage.text("Please wait...");
    }
    if (!$('#waitingFrame').is(":visible")) {

      $('#waitingFrame').hide();
      $('#waitingFrame').fadeIn("fast");
    }
  } else {
    $('#waitingFrame').fadeOut("slow");
  }
};

module.exports = JoleculePanel;
},{}],12:[function(require,module,exports){
var html = require('./menubar.html');
 
var MenuBar = function (root, callbacks) {
  this.root = root;
  $(this.root).append(html);
//  var mainMenu = [{name: 'type': 'Representation'},
//       {'colour': 'Color'},
//       ];
  
  $('#entropyWeight').val(1);
  $('#preferredWeight').val(1);
  $('#distanceWeight').val(1);
  
  $('.nav li').hover(
      function () { //appearing on hover
        $('ul', this).fadeIn();
      },
      function () { //disappearing on hover
        $('ul', this).fadeOut();
      }
    );
  
  $('#MenuLines').click(function (e) {
    callbacks['type']('lines');
  });
  $('#MenuCartoon').click(function (e) {
    callbacks['type']('cartoon');
  });
  $('#MenuBallAndStick').click(function (e) {
    callbacks['type']('ballsAndSticks');
  });
  $('#MenuLineTrace').click(function (e) {
	callbacks['type']('lineTrace');
  });
  
  
  $('#MenuHomology').click(function (e) {
    callbacks['colourScheme']('homology');
  });
  $('#MenuChains').click(function (e) {
    callbacks['colourScheme']('chains');
  });
  $('#MenuElement').click(function (e) {
    callbacks['colourScheme']('element');
  });
  
//  $('#MenuLockedView').click(function(e) {
//	 callbacks['view']('locked');
//  });
//  $('#MenuPCAView').click(function(e) {
//	 callbacks['view']('pca');
//  });
//  $('#MenuEntropyView').click(function(e) {
//	 callbacks['view']('entropy');
//  });
//  $('#MenuAutoView').click(function(e) {
//		 callbacks['view']('auto',{
//			 entropyWeight: $('#entropyWeight').val(),
//			 preferredWeight: $('#preferredWeight').val(),
//			 distanceWeight: $('#distanceWeight').val()
//			 });
//  });
  
}


//MenuBar.prototype.addMenu = function (name) {
//  this.root.append('<li><a href="#">' + name + '</a></li>');
//}

module.exports = MenuBar;
},{"./menubar.html":13}],13:[function(require,module,exports){
module.exports = '\
<div class="navigation">\
	<ul class="nav">\
		<li><div >Color</div>\
			<ul>\
				<li><div id="MenuHomology" >Homology</div></li>\
        <li><div id="MenuChains" >Chains</div></li>\
				<li><div id="MenuElement" >By Element</div></li>\
			</ul></li>\
		<li><div >Representation</div>\
			<ul>\
				<li><div id="MenuCartoon" >Ribbon</div></li>\
				<li><div id="MenuLines" >Lines</div></li>\
        		<li><div id="MenuBallAndStick" >Ball And Stick</div></li>\
        		<li><div id="MenuLineTrace">Lines Trace</div></li>\
			</ul></li>\
		<!--\
		<li><div>View</div>\
			<ul>\
				<li><div id="MenuLockedView">Locked</div></li>\
				<li><div id="MenuPCAView">PCA</div></li>\
				<li><div id="MenuEntropyView">Entropy</div></li>\
				<li><div id="MenuAutoView">Auto</div></li>\
				<li><div id="MenuEntropyWeight">Entropy weight: <input type="text" id="entropyWeight" name="entropyWeight" style="width:20px;"></div></li>\
				<li><div id="MenuPreferredWeight">Preferred weight: <input type="text" id="preferredWeight" name="preferredWeight" style="width:20px;"></div></li>\
				<li><div id="MenuDistanceWeight">Distance weight: <input type="text" id="distanceWeight" name="distanceWeight" style="width:20px;"></div></li>\
			</ul>\
		</li>\
		-->\
	</ul>\
</div>\
';
},{}],14:[function(require,module,exports){
//var PVSelector = require('./pvSelector');
var seedrandom = require('seedrandom');
var menuBar = require('./pv/menuBar');
var numeric = require('numeric');
var rng = seedrandom('aquaria', {global: true});

var singleResidue = {};
singleResidue["ALA"] =  "A";
singleResidue["CYS"] =  "C";
singleResidue["ASP"] =  "D";
singleResidue["GLU"] =  "E";
singleResidue["PHE"] =  "F";
singleResidue["GLY"] =  "G";
singleResidue["HIS"] =  "H";
singleResidue["ILE"] =  "I";
singleResidue["LYS"] =  "K";
singleResidue["LEU"] =  "L";
singleResidue["MET"] =  "M";
singleResidue["ASN"] =  "N";
singleResidue["PRO"] =  "P";
singleResidue["GLN"] =  "Q";
singleResidue["ARG"] =  "R";
singleResidue["SER"] =  "S";
singleResidue["THR"] =  "T";
singleResidue["VAL"] =  "V";
singleResidue["TRP"] =  "W";
singleResidue["TYR"] =  "Y";
singleResidue[" DA"] =  "a";
singleResidue[" DT"] =  "t";
singleResidue[" DG"] =  "g";
singleResidue[" DC"] =  "c";
singleResidue[" DI"] =  "i";
singleResidue[" DU"] =  "u";

var pViewer;
var structure;
var PV3DPanel = function (attachToDiv) {
	var that = this;
	this.attachToDiv = attachToDiv;
	menuBar(this.attachToDiv, {
		type: function (type) {
			pViewer.clear();
			that.setType(type);
		},
		colourScheme: function (colourScheme) {
//			pViewer.clear();
			that.initFeatureView(structure);
			that.setColourScheme(colourScheme);
			that.geom.colorBy(that.colourScheme);
			pViewer.requestRedraw();
//			that.loadType(that.type, structure, attributes);
		},
		view: function (view, options) {
			that.setViewMode(view, options);
		}
	});
	this.type = 'cartoon';
	this.colourSchemeName = 'homology';
	this.attachPV = $(attachToDiv).append('<div id="pv"></div>');
	this.viewMode = 'pca';
	this.initialised = false;
};

PV3DPanel.prototype.getChainsForAccession = function(accession) {
	var ret = [];
	var segments = this.attributes.alignment.split(';');
	segments.forEach(function (segment) {
		if (segment.trim().length > 0) {

			var parts = segment.split(',');
			var seqPart = parts[1].split(':');
			if (accession === seqPart[0]) {
				var pdbPart = parts[0].split(':');
				var chain = structure.select({cname: pdbPart[1], rnumRange:[pdbPart[2], parseInt(pdbPart[4]) + 1]});
				if (chain) {
					ret.push(chain);
				}
			}
		}

	});
	return ret;

};

PV3DPanel.prototype.alignToPDB = function(accession, start, end) {
	var ret = {};
	var segments = this.attributes.alignment.split(';');
	segments.forEach(function (segment) {
		if (segment.trim().length > 0) {

			var parts = segment.split(',');
			var seqPart = parts[1].split(':');
			if (accession === seqPart[0]) {
				var seqStart = parseInt(seqPart[1]);
				var seqEnd = parseInt(seqPart[2]);
				var pdbPart = parts[0].split(':');
				var pdbStart = parseInt(pdbPart[2]);
				var pdbEnd = parseInt(pdbPart[4]);
				if (start >= seqStart && start <= seqEnd) {
					ret.start = pdbStart + (start - seqStart); 
				}
				else if (start < seqStart && ( typeof ret.start === 'undefined' || seqStart < ret.start)) {
					ret.start = pdbStart;
				}
				if (end >= seqStart && end <= seqEnd) {
					ret.end = pdbStart + (end - seqStart); 
				}
				else if (end > seqEnd && ( typeof ret.end === 'undefined' || seqEnd > ret.end)) {
					ret.end = pdbEnd;
				}
			}
		}
	});
	return ret;

}


PV3DPanel.prototype.addAnnotation = function(id, annotationName, featureColours,
		featureNames, featureDescriptions, featurePositions, featureURLs, featureURLTexts) {

	var that = this;
	that.geom.colorBy(color.uniform('#AAAAAA'));	

	var view = new mol.MolView(structure.full());
	var molviews = this.getChainsForAccession(id);
	var features = [];

	featurePositions.forEach(function (featurePosition, f) {
		var colour = color.uniform(featureColours[f]);
		// map feature onto every available chain
		molviews.forEach(function (molview) {
			molview.chains().forEach(function(chain) {
				var chainView = view.addChain(chain, false);
				var pos = featurePosition.split(':');
				var seqStart = parseInt(pos[0]);
				var seqEnd = pos[1] ? parseInt(pos[1]) : seqStart;
				var ret = that.alignToPDB(id, seqStart, seqEnd);
				var allResidues = chain.residues();
				var pdbStart = allResidues[0].num();
				var pdbEnd = allResidues[allResidues.length - 1].num();
				// check if chain starts or ends with non-aminoacids
				var i = 0;
				for (; i < allResidues.length; ++i) {
					if (allResidues[i].isAminoacid()) break;
				}
				if (i >= allResidues.length) return;
				pdbStart = allResidues[i].num();

				for (i = allResidues.length - 1; i > 0; i--) {
					if (allResidues[i].isAminoacid()) break;
				}
				pdbEnd = allResidues[i].num();

				if (pdbStart <= ret.end && pdbEnd >= ret.start) {
					ret.start = Math.max(ret.start,pdbStart);
					ret.end = Math.min(ret.end,pdbEnd);
					var residues = chain.full().residuesInRnumRange(ret.start, ret.end);
//					var residues = molview.select({rindexRange:[ret.start, ret.end+1]});
					residues.forEach(function (residue) {
						residue["featureName"] = featureNames[f];
						var residueView = chainView.addResidue(residue, true);
					});
					features.push({view:chainView, colour:colour});
				}
			});
//			var chainView = view.addChain(chain, false);
		});
	});
	// now add it to the global features
	this.featureViews[annotationName] = features;
	this.updateFeatureWeights(features);
	// color the new feature
	this.colorFeatures();
//	this.setViewMode(this.viewMode, {
//		 entropyWeight: $('#entropyWeight').val(),
//		 preferredWeight: $('#preferredWeight').val(),
//		 distanceWeight: $('#distanceWeight').val()
//		 });
	pViewer.requestRedraw();
};

PV3DPanel.prototype.colorFeatures = function() {
	
	if (typeof(this.featureViews) === 'undefined') {	
		return;	// no features set
	};
	
	var that = this;
	//FIXME: does not guarantee to reflect the order in which features were added!
	if (Object.keys(this.featureViews).length) {
		that.geom.colorBy(color.uniform('#AAAAAA'));	
	}
	for (var annotation in this.featureViews) {
		if (annotation == 'SS') continue;
		var features = this.featureViews[annotation];
		if (features !== undefined) {
			features.forEach(function(feature) {
				that.geom.colorBy(feature.colour, feature.view);
			});
		}
	}
}

PV3DPanel.prototype.removeAnnotation = function(id, annotationName) {
//	document.applets[0].removeAnnotation(id, annotationName);
}

PV3DPanel.prototype.initFeatureView = function(structure) {
	var that = this;
	this.featureViews = [];
	this.featureWeights = {};
	
//	this.rotationSamples = createRandomRotations(128);
	this.preferredRotations = [];
	
	var pca = this.computePCA();
	var pc1 = [pca[0], pca[4], pca[8]];
	var rot = mat4.create();
	mat4.rotate(rot, pca, Math.PI, pc1);
	
	this.preferredRotations.push(pca, rot);
	
	var preferred1 = vec3.fromValues(this.preferredRotations[0][2], this.preferredRotations[0][6], this.preferredRotations[0][10]);
	vec3.normalize(preferred1, preferred1);

	var preferred2 = vec3.fromValues(this.preferredRotations[1][2], this.preferredRotations[1][6], this.preferredRotations[1][10]);
	vec3.normalize(preferred2, preferred2);
	
	this.rotationSamples = [preferred1, preferred2];
	
	this.sampleRotations(this.rotationSamples, this.preferredRotations[0], 
			pc1, 128);
	
//	this.featureMap = this.computeFeatureMap(this.rotationSamples);

	structure.eachResidue(function(residue) {
		var index = getIndexFromResidue(residue);
		that.featureWeights[index] = 0;
	});
//	this.featureViews["SS"] = [{view:structure, colour:that.colourScheme}];
//	this.updateFeatureWeights(this.featureViews["SS"]);
}

PV3DPanel.prototype.updateFeatureWeights = function(features) {
	var that = this;
	var featureLength = 0;
	features.forEach(function(feature) {
		feature.view.eachResidue(function(residue) {
			featureLength += 1;
		});
	});
	if (featureLength > 0) {

		features.forEach(function(feature) {
			feature.view.eachResidue(function(residue) {
				var index = getIndexFromResidue(residue);
				if (that.featureWeights[index] === undefined) {
					that.featureWeights[index] = 1/featureLength;
				} else {
					that.featureWeights[index] += 1/featureLength;
				}
			});
		});

	}
}

function preset() {
//	var ligand = structure.select({'rnames' : ['SAH', 'RVP']});
//	pv.ballsAndSticks('structure.ligand', ligand, { 
//	showRelated: '1' 
//	});
}

PV3DPanel.prototype.setType = function (newType) {
	if (newType !== this.type) {
		this.type = newType;
//		this.reload();
		this.loadType(newType, structure, this.attributes);
	}
}


PV3DPanel.prototype.load = function (attributes) {
	var that = this;
	this.attributes = attributes;
	$(this.attachPV).width(attributes.width);
	$(this.attachPV).height(attributes.height);

	pViewer = pv.Viewer($(this.attachPV)[0], 
			{ quality : 'high', width: 'auto', height : 'auto',
		antialias : true, outline : true,
		slabMode : 'fixed',
		near: 0.1,
		animateTime: 500,
		far: 10000,
		background: [0.8, 0.8, 0.8]
			});
	pViewer.options('fog', false);
	this.reload(attributes);
}

PV3DPanel.prototype.changeViewerSize = function(w, h) {

	$(this.attachToDiv).width(w);
	$(this.attachToDiv).height(h);
	pViewer.fitParent();
}


PV3DPanel.prototype.reload =  function(attributes) {
	var that = this;
	attributes = attributes || this.attributes;
	this.attributes = attributes;

	$(this.attachToDiv).width(attributes.width);
	$(this.attachToDiv).height(attributes.height);
	pViewer.fitParent();
//	pViewer.resize(attributes.width, attributes.height);

//	var url = "https://files.rcsb.org/download/" + attributes.pdb_id + ".pdb.gz";
//	if (biounit > 0) {
//	url = "https://files.rcsb.org/download/" + attributes.pdb_id + ".pdb" + attributes.biounit + ".gz";
//	}
	var beforeSend = function(xhr) {xhr.setRequestHeader('Access-Control-Allow-Origin', '*')};

	$.ajax({ 
	  url : attributes.url, 
	  success : function(data) {
  		structure = io.pdb(data);
  		pViewer.clear();
  		that.setColourScheme(that.colourSchemeName);
  		that.loadType(that.type, structure, attributes);
  		that.initFeatureView(structure);
  		pViewer.autoZoom();
  		that.blankApplet(false);
  		that.setViewMode(that.viewMode);
  		that.initialised = true;
	  }
//	  'beforeSend' : beforeSend,
//	  'headers': { 
//	      'Access-Control-Allow-Origin': '*',
//	      "Access-Control-Allow-Headers": "X-Requested-With"
//	  }
//    crossDomain: true
	});
};

PV3DPanel.prototype.loadType =  function(type, structure, attributes) {
	var that = this;
	that.type = type;
	that.geom = pViewer.renderAs('structure.protein', structure, type, {color: that.colourScheme, strength: 1.0});
	if (typeof that.selector === 'undefined') {
		that.selector =  that.PVSelector(structure, pViewer, that.geom); 
	}
	else {
		that.selector.update(structure, that.geom);
	}
	this.colorFeatures();
//	this.selector.geom = that.geom;
};

PV3DPanel.prototype.setColourScheme =  function(colourScheme) {
	var that = this;
	that.colourSchemeName = colourScheme;
//	pViewer.clear();
	switch (colourScheme) {
	case 'homology' :
		that.colourScheme = that.colorBySSAndHomology(that.attributes.conservations);
		break;
	case 'chains' :
		that.colourScheme = color.byChain();
		break;
	case 'element' :
		that.colourScheme = byElementWithBlack();
		break;
	}
};


PV3DPanel.prototype.mousePressed =  function(atom, e) {
	console.log('obj: ' + atom.residue().num() + ', e: ' + e);
};

var interpolateColour = function (base, other, amount) {
	var i;
	var ret = [];
	for (i = 0; i < base.length; i++) {
		ret[i] = base[i] * amount + other[i] * (1 - amount);
	}
	return ret;
}

var assignColour = function (out, index, colorArray) {
	out[index] = colorArray[0]; 
	out[index+1] = colorArray[1]; 
	out[index+2] = colorArray[2];
	out[index+3] = colorArray[3];
}


PV3DPanel.prototype.colorBySSAndHomology = function(conservations) {
	var that = this;
	this.conservations = conservations;
	this.notConserved = [0/255, 0/255, 0/255, 1];
	this.identicalColourMap = {
			'C': [99/255, 153/255, 65/255, 1], //coil
			'H': [86/255, 138/255, 181/255, 1],   	// helix 
			'E': [255/255, 201/255, 0/255, 1]   	//sheet 
	};
	this.conservedColourMap = {};
	Object.keys(this.identicalColourMap).forEach (function (key) {
		that.conservedColourMap[key] = interpolateColour(that.identicalColourMap[key], that.notConserved, 0.55);
	});

	return new ColorOp(function(atom, out, index) {
		var residue = atom.residue();
		var colour = that.getColourForResidue(residue);
		assignColour(out, index, colour);
	}, null, null);
};

PV3DPanel.prototype.getColourForResidue = function (residue) {
	var chain = residue.chain().name();
	var chainConservation = this.conservations[chain]; 

	var checkAgainst = this.identicalColourMap[residue.ss()];
	if (chainConservation && chainConservation.nonconserved.indexOf(residue.num()) > -1) {
		// non conserved residue
		checkAgainst = this.notConserved;
	}
	else if (chainConservation){
		var map = (chainConservation.conserved.indexOf(residue.num()) > -1) ? this.conservedColourMap : this.identicalColourMap;
		checkAgainst =  map[residue.ss()];
	}
	return checkAgainst;
};


PV3DPanel.prototype.generateAttributes = function(threeDWidth, threeDHeight, pdb_id, pdb_chain, biounit, source_primary_accession, sequences, common_names, pssh_alignment, links, transform, conservations) {
	var instanceId = sequences[0].primary_accession + '-' + pdb_id + '-' + pdb_chain[0];
	return {
		url: getPDBURL(pdb_id, biounit),
		width: threeDWidth,
		height: threeDHeight,
		instanceId: instanceId,
		biounit: biounit,
		pdb_id: pdb_id,
		pdb_chain: pdb_chain,
		transform: transform,
		alignment: pssh_alignment,
		conservations: conservations,
		sequenceAlignments: null,
		interactive: false
	};
};

function getPDBURL(pdbID, biounit) {
	var url = "https://files.rcsb.org/download/" + pdbID + ".pdb";
	if (biounit > 0) {
		url = "https://files.rcsb.org/download/" + pdbID + ".pdb" + biounit ;
	}
	return url;
}

PV3DPanel.prototype.blankApplet = function(isOn, message) {
//	changeAppletSize();
	if (isOn ) {
		var appletMessage = $('#waitingFrame').contents().find('#appletMessage');
		if (message) {
			appletMessage.html(message);
		}
		else {
			appletMessage.text("Please wait...");
		}
		if (!$('#waitingFrame').is(":visible")) {

			$('#waitingFrame').hide();
			$('#waitingFrame').fadeIn("fast");
		}
	}
	else {
		$('#waitingFrame').fadeOut("slow");
	}
};

var selectionText = function(isOn, message) {
//	changeAppletSize();
	if (isOn ) {
		var selectionTextMessage = $('#selectionText').contents().find('#selectionTextMessage');
		if (message) {
			selectionTextMessage.html(message);
		}
		if (!$('#selectionText').is(":visible")) {

			$('#selectionText').hide();
			$('#selectionText').fadeIn("fast");
		}
	}
	else {
		$('#selectionText').fadeOut("slow");
	}
};

PV3DPanel.prototype.selectNew = function (oldResidue, newResidue) {
	var that = this;
	if (oldResidue === newResidue ) {
		return;
	}
	var newChain = newResidue ? newResidue.chain().name() : null;
	var oldChain = oldResidue ? oldResidue.chain().name() : null;
	var chainChanged = newChain !== oldChain;
	if (chainChanged && newResidue) {
		pViewer.fitTo(newResidue.chain());
//		pViewer.requestRedraw();

	}

	var view = new mol.MolView(structure.full());
	var chainView = view.addChain(newResidue.chain(), false);
	var residueView = chainView.addResidue(newResidue, true);

	that.existingColour = [];
	that.geom.getColorByAtom(newResidue.atom(0), existingColour);
	that.geom.colorBy(color.uniform('white'), residueView);



	if (oldResidue) {
		var chainView = view.addChain(oldResidue.chain(), false);
		var residueView = chainView.addResidue(oldResidue, true);
		that.geom.colorBy(that.colourScheme, residueView);

	}
//	if (newResidue) {
//	newResidue.colorBy(color.uniform('white'));
//	}


//	oldResidue.eachAtom(function (atom) {
//	that.colourScheme.colorFor(atom)

//	});

//	return new ColorOp(function(atom, out, index) {
//	var residueChanged = true;
//	var residue = atom.residue();
//	var opacity = 1;
////	if (chainChanged) {
//	var residueChain = residue.chain().name();
//	if (residueChain === newChain) {
//	opacity = 1;
//	}
//	else {
//	opacity = 0.15;
//	}
//	residueChanged = true;
////	}
//	if (residue == newResidue) {
////	var colour = that.getColourForResidue(residue);
//	assignColour(out, index, vec4.fromValues(1,1,1,1));
//	}
//	else if (residue == oldResidue || residueChanged) {
//	var colour = that.getColourForResidue(residue);
//	colour[3] = opacity;
//	assignColour(out, index, colour);
//	}

//	}, null, null);

}

PV3DPanel.prototype.getExistingColour = function() {
//	var traces = this._structure.backboneTraces();
//	console.assert(this._perResidueColors, 
//	"per-residue colors must be set for recoloring to work");
//	for (i = 0; i < traces.length; ++i) {
//	// get current residue colors
//	var data = this._perResidueColors[i];
//	console.assert(data, "no per-residue colors. Seriously, man?");
//	var index = 0;
//	var trace = traces[i];
//	for (j = 0; j < trace.length(); ++j) {
//	if (!view.containsResidue(trace.residueAt(j))) {
//	index+=4;
//	continue;
//	}
//	colorOp.colorFor(trace.centralAtomAt(j), data, index);

}
PV3DPanel.prototype.getResidueTextForSingleChain = function (chain, residues) {
	var i;
	var lastResidue = residues[0];
	var ranges = [];
	var range = null;
	residues.forEach(function (residue) {
		if (residue && (residue.num() === (lastResidue.num() + 1))) {
			lastResidue = residue; 
			range.end = lastResidue;
		}else {
			if (range) {
				ranges.push(range);
			}
			lastResidue = residue; 
			range = {
					start: lastResidue,
					end: lastResidue
			};
		}
	});
	ranges.push(range);

	var rangeTexts = ranges.map(function (r) {
		var ret = singleResidue[r.start.name()] + "(" + r.start.num() + ")" ;
		return r.start === r.end ? ret : ret + '-' + singleResidue[r.end.name()] + "(" + r.end.num() + ")";  
	})
	return chain.name() + ": " + rangeTexts.join(",") + "<br>"; 
};

PV3DPanel.prototype.getResidueText = function (residues) {
	var that = this;
	var ret = '';
	if (residues.length === 0) {
		return ret;
	}
	residues.sort(function (a,b) {
		return a.chain().name() === b.chain().name() ? a.num() - b.num() : a.chain().name() < b.chain().name() ? -1 : 1;
	});
	var lastChain = residues[0].chain();
	var chainResidues = [];
	residues.forEach(function (residue) {
		var currentChain = residue.chain();
		if (lastChain.name() !== currentChain.name()) {
			ret += that.getResidueTextForSingleChain(lastChain, chainResidues);
			lastChain = currentChain;
			chainResidues = [];
		}
		chainResidues.push(residue);
	});
	ret += that.getResidueTextForSingleChain(lastChain, chainResidues);

	return ret;
}

PV3DPanel.prototype.PVSelector = function (structure, viewer, geom) {
	var that = this;
	this.lastSelectedAtom = null;
	var selector = new Selector(structure, viewer, geom);
	selector.addSelectionListener(function (residues) {
		selectionText(true, that.getResidueText(residues));
	});
	return selector;

};

PV3DPanel.prototype.gestures = function () {
	var functions = ['triggerPan', 'triggerRotate', 'triggerZoom', 'point', 'reset', 'zoomToSelection', 'selectMouseCursor'];
	var ret = {};
	functions.forEach(function (funcName) {
		ret[funcName] = function () {
			var newArgs = [funcName];
			newArgs.push(Array.prototype.slice.call(arguments));
			if (funcName === 'triggerRotate') {
				console.log('about to call TODO for webgl: ' + newArgs);
			}
//			if (document.applets[0]) {
//			document.applets[0].molecularControlToolkit.apply(document.applets[0], newArgs);
//			}
		}
	})
	return ret;
}

var  byElementWithBlack = function() {
	return new ColorOp(function(atom, out, index) {
		var ele = atom.element();
		if (ele === 'C') {
			out[index] = 0.0; 
			out[index+1] = 0.0; 
			out[index+2] = 0.0; 
			out[index+3] = 1.0;
			return out;
		}
		if (ele === 'N') {
			out[index] = 0; 
			out[index+1] = 0; 
			out[index+2] = 1;
			out[index+3] = 1.0;
			return out;
		}
		if (ele === 'O') {
			out[index] = 1; 
			out[index+1] = 0; 
			out[index+2] = 0;
			out[index+3] = 1.0;
			return out;
		}
		if (ele === 'S') {
			out[index] = 0.8; 
			out[index+1] = 0.8; 
			out[index+2] = 0;
			out[index+3] = 1.0;
			return out;
		}
		if (ele === 'CA') {
			out[index] = 0.533; 
			out[index+1] = 0.533; 
			out[index+2] = 0.666;
			out[index+3] = 1.0;
			return out;
		}
		out[index] = 1; 
		out[index+1] = 0; 
		out[index+2] = 1;
		out[index+3] = 1.0;
		return out;
	}, null, null);
};

PV3DPanel.prototype.setViewMode = function(mode, options) {
	options = options || {entropyWeight:1,preferredWeight:1,distanceWeight:1}
	var that = this;
	mode = mode || 'locked';

	this.viewMode = mode;

	var rotation = mat4.clone(pViewer._cam.rotation());
	var center = vec3.clone(pViewer._cam.center());
	var zoom = pViewer._cam.zoom();

	var cameraPosition = function(rotation, center, zoom) {
		var currentCameraPosition = vec3.fromValues(rotation[2], rotation[6], rotation[10]);
		vec3.normalize(currentCameraPosition, currentCameraPosition);
		vec3.scaleAndAdd(currentCameraPosition, center, currentCameraPosition, zoom);
		return(currentCameraPosition);
	}

	var currentCameraPosition = cameraPosition(rotation, center, zoom);
	var v1 = vec3.create();
	vec3.subtract(v1, currentCameraPosition, center);
//	pViewer.label('C', 'C', currentCameraPosition);
	vec3.normalize(currentCameraPosition, currentCameraPosition);

//	console.log("finding best view for " + options.type + "s based on " + mode);

	if (mode === 'entropy') {

		var featureMap = this.computeFeatureMap(this.rotationSamples);
		if (featureMap[0].entropy > 0) {
			rotation = featureMap[0].rotation;
			console.log("max entropy:" + featureMap[0].entropy);
		};
		

	} else if (mode === 'pca') {

		var samples = this.preferredRotations;

		// find the shortest distance from the current view
		var shortestDistance = 100000;
		var ccp = vec3.create();
		vec3.normalize(ccp, v1);
		samples.forEach(function(r) {
			var p = vec3.fromValues(r[2], r[6], r[10]);
			vec3.normalize(p,p);
			var d = Math.acos(vec3.dot(p, ccp)) / Math.PI;
			if (d < shortestDistance) {
				shortestDistance = d;
				rotation = r;
			}
		});

//		console.log("entropy for PCA: " + this.computeEntropy(rotation));

	} else if (mode === 'auto') {

		var featureMap = this.computeFeatureMap(this.rotationSamples);

		var dist = normal(0, 1);
		// find the shortest distance from the current view
		var maxScore = -1;
//		var ccp = vec3.create();
		var cam_rotation = mat4.clone(pViewer._cam.rotation());
		var ccp = vec3.fromValues(cam_rotation[2], cam_rotation[6], cam_rotation[10]);
		vec3.normalize(ccp, ccp);
		featureMap.forEach(function(feature) {
			var e = feature.entropy;
			var pr = feature.preferredRegion;
			console.assert(pr <= 1, "spherical distance > 1: " + pr);
			var r = feature.rotation;
//			var s = that.getViewStability(r);
			var p = feature.point;
			vec3.normalize(p, p);
			var d = dist(sphericalDistance(p, ccp));
//			that.labelPoints([p]);
			var score = options.distanceWeight * d + 
						options.entropyWeight * e + 
						options.preferredWeight * pr;
			if (score > maxScore) {
				maxScore = score;
				// get rotation to p, but maintain current camera orientation
				var q = quat.create();
				quat.rotationTo(q, p, ccp);
				var m = mat4.create();
				mat4.fromQuat(m, q);
				mat4.multiply(rotation, cam_rotation, m);
			}
		});

		console.log("max score: " + maxScore);

	}

//	pViewer.autoZoom();

	
	pViewer.setRotation(rotation, 500);

};

PV3DPanel.prototype.computeFeatureMap = function(samples) {
	var that = this;

	var featureMap = [];

//	var pcaPoint = vec3.fromValues(this.preferredRotation[2], this.preferredRotation[6], this.preferredRotation[10]);
//
//	this.labelPoints([pcaPoint], "P1");
//	this.labelPoints([vec3.scale(pcaPoint, pcaPoint, -1)], "P2");
//	this.labelPoints(samples);

	var maxEntropy = 0;
	// compute feature maps
	samples.forEach(function(point) {

		var rotation = that.createRotation(point);
		var e = that.computeEntropy(rotation);
		if ( e > maxEntropy ) {
			maxEntropy = e;
		}
		var d = that.computePreferredRegion(point);
		console.assert(d <= 1, "distance to pr > 1: " + d);
		featureMap.push(
				{
					'point' : point,
					'rotation' : rotation, 
					'entropy' : e,
					'preferredRegion' : d
				});
	});

	// normalize entropy
	if (maxEntropy > 0) {
		featureMap.forEach(function(feature) {
			feature.entropy /= maxEntropy;
		});
	}

	featureMap.sort(function(a, b) {
		return b.entropy - a.entropy;
	});
	
	return featureMap;

}

PV3DPanel.prototype.labelPoints = function(points, label) {
	label = label || '*';
	var v = vec3.create();
	var r = pViewer._cam.zoom();
	var center = vec3.clone(pViewer._cam.center());
	points.forEach(function(point) {
		vec3.normalize(v, point);
		vec3.scaleAndAdd(v, center, v, r);
		pViewer.label('p', label, v);
	});
	pViewer.requestRedraw();

}

//returns the normalized spherical distance of two cartesian vectors
sphericalDistance = function(a, b) {
	var an = vec3.create();
	var bn = vec3.create();
	vec3.normalize(an, a);
	vec3.normalize(bn, b);
	return Math.acos(vec3.dot(an, bn)) / Math.PI;
};


PV3DPanel.prototype.createRotation = function(view) {
	var start = vec3.fromValues(0, 0, 1);
	var q = quat.create();
	var m = mat4.create();
	var tmpVec = vec3.create();
	vec3.normalize(tmpVec, view);
	var rotation = mat4.fromQuat(m, quat.rotationTo(q, tmpVec, start));

	return(rotation);
}

PV3DPanel.prototype.computeTMRotation = function(features) {
	var rotation = mat4.create();

	var extraCellularAtoms = [];
	var intraCellularAtoms = [];

	var center = vec3.clone(pViewer._cam.center());

	features.forEach(function(feature) {
		feature.view.eachResidue(function(res) {
			var pos = res.atom('CA').pos();
			switch (res._residue.featureName) {
			case 'Extracellular':
			case 'Periplasmic':
				extraCellularAtoms.push([pos[0], pos[1], pos[2]]);
				break;
			case 'Cytoplasmic':
				intraCellularAtoms.push([pos[0], pos[1], pos[2]]);
				break;
			}

		});
	});

	var comExtra = getCenterOfMass(extraCellularAtoms);
	var comIntra = getCenterOfMass(intraCellularAtoms);

	var up = vec3.create();
	vec3.subtract(up, comExtra, comIntra);

	// construct a 3D coordinate system around the up vector
	var right = vec3.create();
	var view = vec3.create();

	vec3.cross(right, [1,0,0], up);
	if (right[0] === 0 && right[1] === 0 && right[2] === 0) {	// check for parallel vectors
		vec3.cross(right, [0,1,0], up);
	}

	vec3.cross(view, up, right);

//	var tmpVec = vec3.create();
//	pViewer.label('u', 'u', comExtra);
//	pViewer.label('d', 'd', comIntra);
//	pViewer.label('l', 'l', vec3.subtract(tmpVec, center, right));
//	pViewer.label('r', 'r', vec3.add(tmpVec, center, right));
//	pViewer.label('n', 'n', vec3.subtract(tmpVec, center, view));
//	pViewer.label('f', 'f', vec3.add(tmpVec, center, view));

	vec3.normalize(up, up);
	vec3.normalize(view, view);
	vec3.normalize(right, right);
	rotation = mat4.fromValues(
			right[0], up[0], view[0], 0,
			right[1], up[1], view[1], 0,
			right[2], up[2], view[2], 0,
			0,0,0,1);

	var r = mat3.create();
	mat3.fromMat4(r, rotation);
	if (mat3.determinant(r) < 0) {
		rotation = mat4.fromValues(
				-right[0], up[0], view[0], 0,
				-right[1], up[1], view[1], 0,
				-right[2], up[2], view[2], 0,
				0,0,0,1);
	}

	return(rotation);
}

getCenterOfMass = function(points) {
	var c = [0, 0, 0];
	var l = points.length;
	points.forEach(function(point) {
		c[0] += point[0] / l;
		c[1] += point[1] / l;
		c[2] += point[2] / l;
	});
	return c;
}

PV3DPanel.prototype.sampleRotations = function(ret, rotation, axis, samples) {
	for (var i = 0; i < samples; ++i) {
		var rad = 2*Math.PI*(i+1)/(samples + 1);
		var auxRotation = mat4.create();
		mat4.rotate(auxRotation, rotation, rad, axis);
		var p = vec3.fromValues(auxRotation[2], auxRotation[6], auxRotation[10]);
		vec3.normalize(p,p);
		ret.push(p);
	}
	return(ret);
}

//PV3DPanel.prototype.getMaximumEntropyView = function() {
//	var that = this;
//	var maxI = 0;
//	var npix = {};
//
//	return(this.featureMap[0].rotation);
//
//};

PV3DPanel.prototype.computeEntropy = function(rotation) {
	var npix = {};
	var that = this;

	pViewer.eachVisibleObject(rotation, function(obj) {
		var index = getIndexFromResidue(obj.atom.residue());
		if (npix[index] === undefined) {
			npix[index] = 1;
		} else {
			npix[index]++;
		}
	});

	return this.entropy(npix);

}

PV3DPanel.prototype.entropy = function(npix) {
	var size = pViewer.ENTROPY_BUFFER_WIDTH * pViewer.ENTROPY_BUFFER_HEIGHT;
	var e = 0;
	for (var index in npix) {
		if (npix.hasOwnProperty(index)) {
			var tmp = npix[index]/size;    // > 0 by construction
			var w = this.featureWeights[index];
			var contrib = w * tmp * Math.log(tmp) / Math.log(2);
			e += contrib;
		} 
	}
//	console.log("entropy: " + -e);
	return -e;
}

PV3DPanel.prototype.computePreferredRegion = function(point) {

	// distance from equator, which is defined by the 1st principal component

	var p = vec3.clone(point);
	vec3.normalize(p, p);

	var preferred1 = vec3.fromValues(this.preferredRotations[0][2], this.preferredRotations[0][6], this.preferredRotations[0][10]);
	vec3.normalize(preferred1, preferred1);

	var preferred2 = vec3.fromValues(this.preferredRotations[1][2], this.preferredRotations[1][6], this.preferredRotations[1][10]);
	vec3.normalize(preferred2, preferred2);
//	vec3.scale(preferred2, preferred1, -1);

	var sp1 = spherical(preferred1);
	var sp2 = spherical(preferred2);
	var mu1 = sp1[1];
	var mu2 = sp2[1];

//	var phi = sp1[2];

	var sp = spherical(p);

//	var d = gaussian([mu1, phi], [1, 1]);
	
	var p1 = mvNormal([0], [[1]]);
	var p2 = mvNormal([0], [[1]]);
	var dp1 = sphericalDistance(p, preferred1);
	var dp2 = sphericalDistance(p, preferred2);
	
	return 0.5 * p1([dp1]) + 0.5 * p2([dp2]); //Math.min(sphericalDistance(p, preferred1), sphericalDistance(p, preferred2));

}

gaussian = function(mu, sigma) {
	return function(x) {
		var dx = x[0] - mu[0];
		var dy = x[1] - mu[1];
		return Math.exp(-(dx*dx/(2*sigma[0]) + dy*dy/2*sigma[1]));
	}
}

normal = function(mu, sd) {
	return mvNormal([mu], [[sd]]);
}

mvNormal = function(mu, S) {
	var Sinv = numeric.inv(S);
	var Sdet = numeric.det(S);
	var k = mu.length;
	var A = Math.sqrt(Math.pow(2*Math.PI, k) * Sdet);
	A = 1/A;
	return function(x) {
		var xx = x;
		if (!(x instanceof Array)) {
			xx = [x];
		}
		var dx = numeric.sub(xx, mu);
		var v = numeric.dot(numeric.dot(numeric.transpose([dx]), Sinv), [dx]);
		return A * Math.exp(-0.5 * v[0][0]);
	}
}

spherical = function(cartesian) {
	var r = vec3.length(cartesian);
	var theta = Math.atan2(cartesian[1], cartesian[0]);
	var phi = Math.acos(cartesian[2]/r);
	return vec3.fromValues(r, theta, phi);
}

getIndexFromResidue = function(residue) {
	return residue.chain().name() + residue.num();
}

PV3DPanel.prototype.computePCA = function() {
	var X = [];

	//var feature = pViewer.renderAs('feature', view, this.type);
	this.geom.eachCentralAtom(function(atom, pos) {
		X.push([pos[0], pos[1], pos[2]]);
	});
//	pViewer.rm('feature');

	console.log("computing PCA for: " + X.length + "residues");

	if (!X.length) {
		return(mat4.create());
	}

	// compute and subtract column means
	var svd = pca(X);
	var V = svd.V;
	var right = V[0];
	var up = V[1];
	var view = V[2];
	var m = mat4.fromValues(
			right[0], right[1], right[2], 0,
			up[0], up[1], up[2], 0,
			view[0], view[1], view[2], 0,
			0, 0, 0, 1);

	var r = mat3.create();
	mat3.fromMat4(r, m);
	if (mat3.determinant(r) < 0) {
		m = mat4.fromValues(-right[0], -right[1], -right[2], 0,
				-up[0], -up[1], -up[2], 0,
				-view[0], -view[1], -view[2], 0,
				0, 0, 0, 1);
	}
	return(m);
}

function pca(X) {
	var XT = numeric.transpose(X);
	var mean = XT.map(function(row) {return numeric.sum(row) / row.length;});
	X = numeric.transpose(XT.map(function(row, i) {return numeric.sub(row, mean[i]);}));

	var sigma = numeric.dot(numeric.transpose(X), X);
	var svd = numeric.svd(sigma);
	return svd;
}

function hammersleySampler(n) {
	var points = [];
	var t;
	for (var k = 0; k < n; ++k) {
		t = 0;
		var kk;
		for (var p = 0.5, kk=k; kk; p*=0.5, kk>>=1) {
			if (kk & 1) {
				t += p;
			}
		}
		t = 2 * t - 1;
		var st = Math.sqrt(1 - t*t);
		var phi = (k + 0.5) / n;  // theta in [0,1]
		var phirad = phi * 2 * Math.PI;
//		var phi = Math.acos(t);
		var p = vec3.fromValues(st * Math.cos(phirad), st*Math.sin(phirad), t);
//		points.push(vec3.fromValues(1, phirad, Math.acos(t)));
		points.push(p);

	}
	return points;
}

//returns spherical coordinates
function haltonSampler(n, p2) {
	var points = [];
	for (var k = 0, pos = 0; k < n; ++k) {
		var t = 0;
		for (var p = 0.5, kk=k; kk; p*=0.5, kk>>=1) {
			if (kk & 1) {	// kk % 2 == 1
				t += p;
			}
		}
		t = 2 * t - 1;				// map from [0,1] to [-1,1]
		var st = Math.sqrt(1 - t*t);
		var phi = 0;
		var ip = 1/p2;
		for (var p = ip, kk=k; kk; p *= ip, kk/=p2) {
			var a = kk % p2;
			if (a) {
				phi += a * p;
			}
		}
		var phirad = phi * 4 * Math.PI;
		var p = vec3.fromValues(st * Math.cos(phirad), st*Math.sin(phirad), t);
		var r = vec3.length(p);
		points.push(vec3.fromValues(r, phirad, Math.acos(t)));
//		points.push(p);
	}

	return points;
}

sphericalToRotation = function(point) {
	var t = Math.cos(point[2]);
	var st = Math.sqrt(1 - t*t);
	var phirad = point[1];
	var p = vec3.fromValues(st * Math.cos(phirad), st*Math.sin(phirad), t);
	var start = vec3.fromValues(0, 0, 1);
	var q = quat.create();
	var m = mat4.create();
	var tmpVec = vec3.create();
	vec3.normalize(tmpVec, p);
	return mat4.fromQuat(m, quat.rotationTo(q, tmpVec, start));
}

function createRandomRotations(n) {

	return hammersleySampler(n);

	var start = vec3.fromValues(0, 0, 1);
	var points = hammersleySampler(n);
	var ret = points.map(function(p) {
		var q = quat.create();
		var m = mat4.create();
		var tmpVec = vec3.create();
		vec3.normalize(tmpVec, p);
		return mat4.fromQuat(m, quat.rotationTo(q, tmpVec, start));
	});

//	var twoPI = 2 * Math.PI;
//	var ret = [];
//	for (var i = 0; i < n; ++i) {
//	var u1 = Math.random();
//	var u2 = Math.random();
//	var u3 = Math.random();
//	var st = Math.sqrt(1-u1);

//	var q = quat.fromValues(st*Math.sin(twoPI*u2),st*Math.cos(twoPI*u2), Math.sqrt(u1)*Math.sin(twoPI*u3), Math.sqrt(u1)*Math.cos(twoPI*u3));
//	var auxRotation = mat4.create();
//	mat4.fromQuat(auxRotation,q);
//	ret.push(auxRotation);
//	}
	return(ret);
}

module.exports = PV3DPanel;

},{"./pv/menuBar":12,"numeric":129,"seedrandom":130}],15:[function(require,module,exports){
var ClusterRenderer = require('./clusterRenderer');
// Render 2D structures in SVG.
//
// Authors: Christian Stolte, Vivian Ho, Kenny Sabir
// Utilises new format (see matching_structures_multipleuniprotinput.js)
// as opposed to matching_structures_singleuniprotinput.js
// new tree drawing routine

var that = null;
var ShowMatchingStructures = function(onTextClick) {
	this.onTextClick = onTextClick;
	that = this;
	this.clusters = [];
	this.clusterRenderers = [];
};

ShowMatchingStructures.prototype.removeAll = function() {
	// clear previous contents
	$("#vis.content div, #featurelist div").remove();

};

ShowMatchingStructures.prototype.selectCluster = function(cluster, clusterNumber) {
	this.selectedCluster = cluster || this.selectedCluster;
	if (typeof this.selectedCluster === 'undefined') {
	  console.log('ShowMatchingStructures.selectCluster error: cannot select null cluster for number: ' + clusterNumber);
	}
	else {
	  	this.bestClusterNumber = (typeof clusterNumber === 'undefined') ? this.bestClusterNumber : clusterNumber;
	  	var loadPDBStructure = this.selectedCluster.pdb_id;
	  	this.mark_loaded_structure(loadPDBStructure, this.bestClusterNumber);
	  	// update title bar for 3D structure view
	  	var identity_score = this.selectedCluster.members[0].alignment_identity_score;
	}
};


ShowMatchingStructures.prototype.initialise = function(sequence) {
	this.sequence = sequence || this.sequence; 
	// counter for clusters
	this.rank = 0;

	var seqLength = 0;
//	var clusters = matching_structures.clusters;
//	var Selected_PDB = matching_structures.Selected_PDB;

	// main function begins
		seqLength = this.sequence.length;
//		AQUARIA.structures2match = matching_structures;

		this.width = document.getElementById("structureviewer").offsetWidth
				- AQUARIA.margin.right - AQUARIA.margin.left;
		this.height = 40 - AQUARIA.margin.top - AQUARIA.margin.bottom + 35; // height
																																		// for one
																																		// structure

		this.xScale = d3.scale.linear().domain([ 1, seqLength ]).range([ 1, this.width ]); // .range([1, width]);

		// set single residue width
		AQUARIA.srw = this.xScale(100) / 100;
		// console.log("srw: "+srw);

		this.removeAll();

		// draw axis ruler
		this.drawAxisRuler("vis");
		
		// append div for clusters
		$("#vis").append("<div id='allclusters' data-intro='Visual summary of all structures in PDB matching the specified protein, grouped by region of match.' data-position='left'></div>");

};

ShowMatchingStructures.prototype.updateSizes = function(newClusters) {
	var i;
	if (newClusters.length != this.clusterRenderers.length) {
		console.log("ShowMatchingStructures.updateSizes error, clusters don't exist for size update" + newClusters.length + " , " + this.clusterRenderers.length )
	}
	else {
	  this.clusters = newClusters;
		for (i = 0; i < newClusters.length; i++) {
			this.clusterRenderers[i].updateCluster(newClusters[i]);
		}
	}
	this.finishedLoading();
}

ShowMatchingStructures.prototype.refresh = function() {
	this.initialise();
	var existingClusters = this.clusters;
	this.clusters = [];
	this.clusterRenderers = [];
	existingClusters.forEach(function (cluster) {
		that.addCluster(cluster);
	});
	this.updateSizes(existingClusters);
	this.selectCluster();
};

ShowMatchingStructures.prototype.addCluster = function(cluster) {
	this.clusters.push(cluster);
	var clusterRenderer = new ClusterRenderer(cluster, this.rank, this.xScale, this.width,
			this.height, function (d, clusterSelected) {
				console.log('ShowMatchingStructures.addCluster.onclick', clusterSelected)
				var cluster_nbr = that.getClusterId(d);
				that.onTextClick(d, clusterSelected);
			}, this.clusterItemClick);
	this.clusterRenderers.push(clusterRenderer);
	this.rank++;
};



ShowMatchingStructures.prototype.finishedLoading = function() {
	var structureCount = totalStructures(this.clusters);
	console.log('ShowMatchingStructures.finishedLoading', structureCount + " structures total!");
	$("#structureexplanation").html("<span class='counter'>" + structureCount + "</span>");
	$("#structurematches h3 span.counter, div.container svg g.expandable text").digits();
	
};

var totalStructures = function(clusters) {
	var total = 0;
	clusters.forEach(function(cluster) {
		total += parseInt(cluster.cluster_size);
	});
	return total;
}

ShowMatchingStructures.prototype.getClusterId = function (d) {
	return parseInt(d.attr("id").substr(15));
};

ShowMatchingStructures.prototype.clusterItemClick = function(d) {
	
	var shortId = d.attr("id").substr(10, 4);
	var cluster_nbr = that.getClusterId(d);

	that.mark_loaded_structure(shortId, cluster_nbr);
	console.log(
		"ShowMatchingStructures.clusterItemClick",
		"shortId: " + shortId,
		"cluster-number: " + cluster_nbr,
		that.clusters[cluster_nbr]
	);

	if (window.threedViewer === 'IDR') {
		var threeDWidth = $("#threeD").width();
		var threeDHeight = threeDWidth;
		threeDHeight = $("#threeDSpan").innerHeight();
		if (threeDHeight < 570) {
			threeDHeight = 570;
		}
		AQUARIA.panel3d.display_cluster(that.clusters[cluster_nbr], threeDWidth, threeDHeight);
	} else {
		var member = that.clusters[cluster_nbr].members[0];
		AQUARIA.display_member(member);
	}
	
};

ShowMatchingStructures.prototype.drawAxisRuler = function(layerId) { // console.log("Ruler
																																// width:
//	d3.select("#" + layerId + "div.ruler").remove();																															// "+width+",

	var rsvg = d3.select("#" + layerId)
		.append("div")
			.attr("class", "ruler")
			.attr("data-intro","Graphical representation of the specified protein's sequence")
			.attr("data-position", "left")
		.append("svg").attr("width",
			parseInt(this.width + AQUARIA.margin.left)-80).attr("viewBox",
			"0 0 " + parseInt(this.width + AQUARIA.margin.left) + " 15").attr(
			"preserveAspectRatio", "none").attr("height", 15).append("g").attr(
			"transform", "translate(" + AQUARIA.margin.left + ",0)");

	rsvg.append("g").attr("class", "x axis").call(
			d3.svg.axis()
				.scale(this.xScale)
				.orient("bottom")
				.tickSize(4, 2, 6)
				.tickPadding(2)
			//	.tickValues([allTicks,this.sequence.length])
		);	
	
	var tickList = [];
	var allTicks = d3.selectAll("#vis div.ruler g.x text")[0];	
	
	for (var n=0; n < allTicks.length; n++) {
		tickList.push(+allTicks[n].textContent);		//console.log(n+":"+tickList);
	}
	
	function doesItFit(x) { 
		var rulerEnd = AQUARIA.showMatchingStructures.sequence.length;
		return  (x!== 1 && x!==rulerEnd && x*AQUARIA.srw < (rulerEnd*AQUARIA.srw-30) );
	
	}
	
	tickList = tickList.filter(doesItFit);   // console.log("filtered:"+tickList);
	tickList.push(AQUARIA.showMatchingStructures.sequence.length);
	tickList.unshift(1);
	// left
	//console.log(" = = = ticks: "+allTicks)	;																	// margin:
	//console.log(tickList);	
	
	d3.select("#" + layerId + " div.ruler g.x").call(
			d3.svg.axis()
			.scale(this.xScale)
			.orient("bottom")
			.tickSize(4, 2, 6)
			.tickPadding(2)
			.tickValues(tickList)
	);	
		
	d3.selectAll("g.x text").attr("text-anchor", "end");

};


ShowMatchingStructures.prototype.mark_loaded_structure = function(id, nbr) { // console.log("highlight
																																							// id:
																																							// "+id+",
																																							// cluster:
																																							// "+nbr);
	$("div.container.loaded").removeClass("loaded");
	d3.select("g.loaded").classed("loaded", false);
	d3.select("g#structure_" + id + "_" + nbr).classed("loaded", true);
	d3.select("div#c_" + id + "_" + nbr).classed("loaded", true);
	// AQUARIA.currentData.cluster_number = nbr;
}
// //// Expanding clusters: moved to show_expanded_clusters.js /////////////
module.exports = ShowMatchingStructures;
//module.exports.set = function(global) {
//	AQUARIA = global;
//};

// /////// sidebar information panels: moved to textpanels.js //

},{"./clusterRenderer":4}],16:[function(require,module,exports){
var LRU = require("lru-cache");


var TopTen = function (id, MAX_SIZE) {
	var that = this;
//	this.maxSize = MAX_SIZE;
	this.id = id;
	if (getUrlParameter("clearCache")) {
	  localStorage.removeItem(this.id);
	}
	var existing = localStorage.getItem(this.id);
  this.cache = new LRU(MAX_SIZE);
	if (existing === null) {
	}
	else {
		var entries = JSON.parse(existing);
		entries.forEach(function (entry) {
		  that.cache.set(entry.key, entry.value);
		});
	}
};


TopTen.prototype.submitFired = function (name, primary_accession, pdb_id) {
	var last = {name: name, primary_accession: primary_accession, pdb_id: pdb_id};
	this.cache.set(primary_accession + pdb_id, last);
	this.save();
};

TopTen.prototype.save = function () {
  var saveArray = [];
  this.cache.forEach(function(value, key) {
    saveArray.push({key: key, value: value});
  })
	var savedText =  JSON.stringify(saveArray);
	console.log('TopTen.save', saveArray);
	localStorage.setItem(this.id, savedText);
};


TopTen.prototype.getAll = function() {
	var ret = [];
	this.cache.forEach(function(value) {
	  ret.push(value)
	});
	return ret;
};


module.exports = TopTen;
},{"lru-cache":125}],17:[function(require,module,exports){
/** generic functions and stuff to run once document is loaded
 * 
 */

// jQuery - format numbers with commas every 3 digits;   to use:  $("span.numbers").digits();
$.fn.digits = function(){ 
    return this.each(function(){ 
        $(this).text( $(this).text().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,") ); 
    })
}

// Once document is ready, move focus to protein input field

$(document).ready(function() {
	  $( "#protein_syn_input, #organism_syn_input" ).focus( function() {
		  $(".infocus").removeClass("infocus"); 
		  $("#searchByName").addClass("infocus");
	  });
	  
	  $("#help3D").hide();

});

$(function() {
    $( document ).tooltip({ position: { my: "right top+15", at: "right center", collision: "none" }}, { show: { delay: 1200 } });
  });


},{}],18:[function(require,module,exports){
//
// Simple cache with automatic removal of oldest values.
//
// Authors: Sean O'Donoghue. Kenny Sabir
//
// WARNING, this logger is now used by client & server. The client cannot use the logger.
// var logger = require('./log');

var Cache = function (maximum_cache_size) {
  var cache = {}
  var last_access = {}
  var enabled = true
  if (typeof maximum_cache_size === 'undefined') { maximum_cache_size = 100 };

  return {
    write: function (key, value) {
      if (typeof (Storage) !== "undefined"){
        console.log("Cache.write save " + key + " to local storage")
        localStorage.setItem(key, JSON.stringify(value))
      } else {
        //				console.log("*** write to cache");
        if (enabled) {
          last_access[key] = Date()

          // store in cache
          cache[key] = value

          // if cache size is too large, remove oldest key
          var size = Object.keys(cache).length
          // logger.info('Stored ' + key + ' in cache (size = ' + size + ')');
          if (size > maximum_cache_size) {
            var oldest_key = null
            var oldest_date = null
            // find and delete oldest key
            oldest_date = last_access[key]
            Object.keys(cache).forEach(function (temp_key) {
              // console.log('checking key = ' + temp_key);
              if (last_access[temp_key] <= oldest_date) {
                // console.log('key is older: ' + last_access[temp_key]);
                oldest_key = temp_key
                oldest_date = last_access[temp_key]
              }
            })
            // console.log('final oldest key = ' + oldest_key);
            if (oldest_key !== null) {
              delete cache[oldest_key]
              delete last_access[oldest_key]
            }
            // logger.info('Deleted ' + oldest_key + ' from cache');
          }
        }
      }
      return (value)
    },
    read: function (key) {
      if (typeof (Storage) !== "undefined"){
        if (localStorage.getItem(key) !== null){
          console.log("Cache.read " + key + " fetched from local storage")
          return (JSON.parse(localStorage.getItem(key)))
        } else {
          console.log("Cache.write error: " + key + " not found in local storage")
          return (false)
        }
      } else if (enabled && key in cache && cache[key]) {
        // use cached value if available
        // logger.info('Read ' + key + ' from cache');
        //				console.log("*** read from cache");
        return (cache[key])
      } else {
        return (false)
      }
    },
    clear: function () {
      cache = {}
      last_access = {}
    }
  }
}

module.exports = Cache

},{}],19:[function(require,module,exports){
'use strict';

var compileSchema = require('./compile')
  , resolve = require('./compile/resolve')
  , Cache = require('./cache')
  , SchemaObject = require('./compile/schema_obj')
  , stableStringify = require('fast-json-stable-stringify')
  , formats = require('./compile/formats')
  , rules = require('./compile/rules')
  , $dataMetaSchema = require('./data')
  , util = require('./compile/util');

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = require('./compile/async');
var customKeyword = require('./keyword');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = require('./compile/error_classes');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = require('./refs/data.json');
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = require('./refs/json-schema-draft-07.json');
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}

},{"./cache":20,"./compile":24,"./compile/async":21,"./compile/error_classes":22,"./compile/formats":23,"./compile/resolve":25,"./compile/rules":26,"./compile/schema_obj":27,"./compile/util":29,"./data":30,"./keyword":58,"./refs/data.json":59,"./refs/json-schema-draft-07.json":60,"fast-json-stable-stringify":97}],20:[function(require,module,exports){
'use strict';


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

},{}],21:[function(require,module,exports){
'use strict';

var MissingRefError = require('./error_classes').MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

},{"./error_classes":22}],22:[function(require,module,exports){
'use strict';

var resolve = require('./resolve');

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

},{"./resolve":25}],23:[function(require,module,exports){
'use strict';

var util = require('./util');

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}

},{"./util":29}],24:[function(require,module,exports){
'use strict';

var resolve = require('./resolve')
  , util = require('./util')
  , errorClasses = require('./error_classes')
  , stableStringify = require('fast-json-stable-stringify');

var validateGenerator = require('../dotjs/validate');

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = require('fast-deep-equal');

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

},{"../dotjs/validate":57,"./error_classes":22,"./resolve":25,"./util":29,"fast-deep-equal":96,"fast-json-stable-stringify":97}],25:[function(require,module,exports){
'use strict';

var URI = require('uri-js')
  , equal = require('fast-deep-equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj')
  , traverse = require('json-schema-traverse');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}

},{"./schema_obj":27,"./util":29,"fast-deep-equal":96,"json-schema-traverse":100,"uri-js":146}],26:[function(require,module,exports){
'use strict';

var ruleModules = require('../dotjs')
  , toHash = require('./util').toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};

},{"../dotjs":46,"./util":29}],27:[function(require,module,exports){
'use strict';

var util = require('./util');

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

},{"./util":29}],28:[function(require,module,exports){
'use strict';

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

},{}],29:[function(require,module,exports){
'use strict';


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: require('fast-deep-equal'),
  ucs2length: require('./ucs2length'),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

},{"./ucs2length":28,"fast-deep-equal":96}],30:[function(require,module,exports){
'use strict';

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};

},{}],31:[function(require,module,exports){
'use strict';

var metaSchema = require('./refs/json-schema-draft-07.json');

module.exports = {
  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};

},{"./refs/json-schema-draft-07.json":60}],32:[function(require,module,exports){
'use strict';
module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],33:[function(require,module,exports){
'use strict';
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],34:[function(require,module,exports){
'use strict';
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],35:[function(require,module,exports){
'use strict';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],36:[function(require,module,exports){
'use strict';
module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],37:[function(require,module,exports){
'use strict';
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],38:[function(require,module,exports){
'use strict';
module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}

},{}],39:[function(require,module,exports){
'use strict';
module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],40:[function(require,module,exports){
'use strict';
module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],41:[function(require,module,exports){
'use strict';
module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}

},{}],42:[function(require,module,exports){
'use strict';
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],43:[function(require,module,exports){
'use strict';
module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],44:[function(require,module,exports){
'use strict';
module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],45:[function(require,module,exports){
'use strict';
module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],46:[function(require,module,exports){
'use strict';

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': require('./ref'),
  allOf: require('./allOf'),
  anyOf: require('./anyOf'),
  '$comment': require('./comment'),
  const: require('./const'),
  contains: require('./contains'),
  dependencies: require('./dependencies'),
  'enum': require('./enum'),
  format: require('./format'),
  'if': require('./if'),
  items: require('./items'),
  maximum: require('./_limit'),
  minimum: require('./_limit'),
  maxItems: require('./_limitItems'),
  minItems: require('./_limitItems'),
  maxLength: require('./_limitLength'),
  minLength: require('./_limitLength'),
  maxProperties: require('./_limitProperties'),
  minProperties: require('./_limitProperties'),
  multipleOf: require('./multipleOf'),
  not: require('./not'),
  oneOf: require('./oneOf'),
  pattern: require('./pattern'),
  properties: require('./properties'),
  propertyNames: require('./propertyNames'),
  required: require('./required'),
  uniqueItems: require('./uniqueItems'),
  validate: require('./validate')
};

},{"./_limit":32,"./_limitItems":33,"./_limitLength":34,"./_limitProperties":35,"./allOf":36,"./anyOf":37,"./comment":38,"./const":39,"./contains":40,"./dependencies":42,"./enum":43,"./format":44,"./if":45,"./items":47,"./multipleOf":48,"./not":49,"./oneOf":50,"./pattern":51,"./properties":52,"./propertyNames":53,"./ref":54,"./required":55,"./uniqueItems":56,"./validate":57}],47:[function(require,module,exports){
'use strict';
module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],48:[function(require,module,exports){
'use strict';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],49:[function(require,module,exports){
'use strict';
module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}

},{}],50:[function(require,module,exports){
'use strict';
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}

},{}],51:[function(require,module,exports){
'use strict';
module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],52:[function(require,module,exports){
'use strict';
module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],53:[function(require,module,exports){
'use strict';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],54:[function(require,module,exports){
'use strict';
module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}

},{}],55:[function(require,module,exports){
'use strict';
module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}

},{}],56:[function(require,module,exports){
'use strict';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],57:[function(require,module,exports){
'use strict';
module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}

},{}],58:[function(require,module,exports){
'use strict';

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require('./dotjs/custom');
var definitionSchema = require('./definition_schema');

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}

},{"./definition_schema":31,"./dotjs/custom":41}],59:[function(require,module,exports){
module.exports={
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#",
    "description": "Meta-schema for $data reference (JSON Schema extension proposal)",
    "type": "object",
    "required": [ "$data" ],
    "properties": {
        "$data": {
            "type": "string",
            "anyOf": [
                { "format": "relative-json-pointer" }, 
                { "format": "json-pointer" }
            ]
        }
    },
    "additionalProperties": false
}

},{}],60:[function(require,module,exports){
module.exports={
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "http://json-schema.org/draft-07/schema#",
    "title": "Core schema meta-schema",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "nonNegativeInteger": {
            "type": "integer",
            "minimum": 0
        },
        "nonNegativeIntegerDefault0": {
            "allOf": [
                { "$ref": "#/definitions/nonNegativeInteger" },
                { "default": 0 }
            ]
        },
        "simpleTypes": {
            "enum": [
                "array",
                "boolean",
                "integer",
                "null",
                "number",
                "object",
                "string"
            ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "uniqueItems": true,
            "default": []
        }
    },
    "type": ["object", "boolean"],
    "properties": {
        "$id": {
            "type": "string",
            "format": "uri-reference"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "$ref": {
            "type": "string",
            "format": "uri-reference"
        },
        "$comment": {
            "type": "string"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": true,
        "readOnly": {
            "type": "boolean",
            "default": false
        },
        "examples": {
            "type": "array",
            "items": true
        },
        "multipleOf": {
            "type": "number",
            "exclusiveMinimum": 0
        },
        "maximum": {
            "type": "number"
        },
        "exclusiveMaximum": {
            "type": "number"
        },
        "minimum": {
            "type": "number"
        },
        "exclusiveMinimum": {
            "type": "number"
        },
        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "pattern": {
            "type": "string",
            "format": "regex"
        },
        "additionalItems": { "$ref": "#" },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": true
        },
        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "uniqueItems": {
            "type": "boolean",
            "default": false
        },
        "contains": { "$ref": "#" },
        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": { "$ref": "#" },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "propertyNames": { "format": "regex" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "propertyNames": { "$ref": "#" },
        "const": true,
        "enum": {
            "type": "array",
            "items": true,
            "minItems": 1,
            "uniqueItems": true
        },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "format": { "type": "string" },
        "contentMediaType": { "type": "string" },
        "contentEncoding": { "type": "string" },
        "if": {"$ref": "#"},
        "then": {"$ref": "#"},
        "else": {"$ref": "#"},
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
    },
    "default": true
}

},{}],61:[function(require,module,exports){
(function (process){
module.exports = function (arr, iterator, callback) {
  callback = callback || function () {};
  if (!Array.isArray(arr) || !arr.length) {
      return callback();
  }
  var completed = 0;
  var iterate = function () {
    iterator(arr[completed], function (err) {
      if (err) {
        callback(err);
        callback = function () {};
      }
      else {
        ++completed;
        if (completed >= arr.length) { callback(); }
        else { nextTick(iterate); }
      }
    });
  };
  iterate();
};

function nextTick (cb) {
  if (typeof setImmediate === 'function') {
    setImmediate(cb);
  } else {
    process.nextTick(cb);
  }
}
}).call(this,require('_process'))
},{"_process":160}],62:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":64}],63:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/buildFullPath":70,"../core/createError":71,"./../core/settle":75,"./../helpers/buildURL":79,"./../helpers/cookies":81,"./../helpers/isURLSameOrigin":83,"./../helpers/parseHeaders":85,"./../utils":87}],64:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":65,"./cancel/CancelToken":66,"./cancel/isCancel":67,"./core/Axios":68,"./core/mergeConfig":74,"./defaults":77,"./helpers/bind":78,"./helpers/spread":86,"./utils":87}],65:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],66:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":65}],67:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],68:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":79,"./../utils":87,"./InterceptorManager":69,"./dispatchRequest":72,"./mergeConfig":74}],69:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":87}],70:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":80,"../helpers/isAbsoluteURL":82}],71:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":73}],72:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":67,"../defaults":77,"./../utils":87,"./transformData":76}],73:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

},{}],74:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = [
    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath'
  ];

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys);

  var otherKeys = Object
    .keys(config2)
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};

},{"../utils":87}],75:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":71}],76:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":87}],77:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this,require('_process'))
},{"./adapters/http":63,"./adapters/xhr":63,"./helpers/normalizeHeaderName":84,"./utils":87,"_process":160}],78:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],79:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":87}],80:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],81:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":87}],82:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],83:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":87}],84:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":87}],85:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":87}],86:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],87:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":78}],88:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var scrubber = require('./lib/scrub');
var objectKeys = require('./lib/keys');
var forEach = require('./lib/foreach');
var isEnumerable = require('./lib/is_enum');

module.exports = function (cons, opts) {
    return new Proto(cons, opts);
};

(function () { // browsers bleh
    for (var key in EventEmitter.prototype) {
        Proto.prototype[key] = EventEmitter.prototype[key];
    }
})();

function Proto (cons, opts) {
    var self = this;
    EventEmitter.call(self);
    if (!opts) opts = {};
    
    self.remote = {};
    self.callbacks = { local : [], remote : [] };
    self.wrap = opts.wrap;
    self.unwrap = opts.unwrap;
    
    self.scrubber = scrubber(self.callbacks.local);
    
    if (typeof cons === 'function') {
        self.instance = new cons(self.remote, self);
    }
    else self.instance = cons || {};
}

Proto.prototype.start = function () {
    this.request('methods', [ this.instance ]);
};

Proto.prototype.cull = function (id) {
    delete this.callbacks.remote[id];
    this.emit('request', {
        method : 'cull',
        arguments : [ id ]
    });
};

Proto.prototype.request = function (method, args) {
    var scrub = this.scrubber.scrub(args);
    
    this.emit('request', {
        method : method,
        arguments : scrub.arguments,
        callbacks : scrub.callbacks,
        links : scrub.links
    });
};

Proto.prototype.handle = function (req) {
    var self = this;
    var args = self.scrubber.unscrub(req, function (id) {
        if (self.callbacks.remote[id] === undefined) {
            // create a new function only if one hasn't already been created
            // for a particular id
            var cb = function () {
                self.request(id, [].slice.apply(arguments));
            };
            self.callbacks.remote[id] = self.wrap ? self.wrap(cb, id) : cb;
            return cb;
        }
        return self.unwrap
            ? self.unwrap(self.callbacks.remote[id], id)
            : self.callbacks.remote[id]
        ;
    });
    
    if (req.method === 'methods') {
        self.handleMethods(args[0]);
    }
    else if (req.method === 'cull') {
        forEach(args, function (id) {
            delete self.callbacks.local[id];
        });
    }
    else if (typeof req.method === 'string') {
        if (isEnumerable(self.instance, req.method)) {
            self.apply(self.instance[req.method], args);
        }
        else {
            self.emit('fail', new Error(
                'request for non-enumerable method: ' + req.method
            ));
        }
    }
    else if (typeof req.method == 'number') {
        var fn = self.callbacks.local[req.method];
        if (!fn) {
            self.emit('fail', new Error('no such method'));
        }
        else self.apply(fn, args);
    }
};

Proto.prototype.handleMethods = function (methods) {
    var self = this;
    if (typeof methods != 'object') {
        methods = {};
    }
    
    // copy since assignment discards the previous refs
    forEach(objectKeys(self.remote), function (key) {
        delete self.remote[key];
    });
    
    forEach(objectKeys(methods), function (key) {
        self.remote[key] = methods[key];
    });
    
    self.emit('remote', self.remote);
    self.emit('ready');
};

Proto.prototype.apply = function (f, args) {
    try { f.apply(undefined, args) }
    catch (err) { this.emit('error', err) }
};

},{"./lib/foreach":89,"./lib/is_enum":90,"./lib/keys":91,"./lib/scrub":92,"events":155}],89:[function(require,module,exports){
module.exports = function forEach (xs, f) {
    if (xs.forEach) return xs.forEach(f)
    for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
    }
}

},{}],90:[function(require,module,exports){
var objectKeys = require('./keys');

module.exports = function (obj, key) {
    if (Object.prototype.propertyIsEnumerable) {
        return Object.prototype.propertyIsEnumerable.call(obj, key);
    }
    var keys = objectKeys(obj);
    for (var i = 0; i < keys.length; i++) {
        if (key === keys[i]) return true;
    }
    return false;
};

},{"./keys":91}],91:[function(require,module,exports){
module.exports = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

},{}],92:[function(require,module,exports){
var traverse = require('traverse');
var objectKeys = require('./keys');
var forEach = require('./foreach');

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) if (xs[i] === x) return i;
    return -1;
}

// scrub callbacks out of requests in order to call them again later
module.exports = function (callbacks) {
    return new Scrubber(callbacks);
};

function Scrubber (callbacks) {
    this.callbacks = callbacks;
}

// Take the functions out and note them for future use
Scrubber.prototype.scrub = function (obj) {
    var self = this;
    var paths = {};
    var links = [];
    
    var args = traverse(obj).map(function (node) {
        if (typeof node === 'function') {
            var i = indexOf(self.callbacks, node);
            if (i >= 0 && !(i in paths)) {
                // Keep previous function IDs only for the first function
                // found. This is somewhat suboptimal but the alternatives
                // are worse.
                paths[i] = this.path;
            }
            else {
                var id = self.callbacks.length;
                self.callbacks.push(node);
                paths[id] = this.path;
            }
            
            this.update('[Function]');
        }
        else if (this.circular) {
            links.push({ from : this.circular.path, to : this.path });
            this.update('[Circular]');
        }
    });
    
    return {
        arguments : args,
        callbacks : paths,
        links : links
    };
};
 
// Replace callbacks. The supplied function should take a callback id and
// return a callback of its own.
Scrubber.prototype.unscrub = function (msg, f) {
    var args = msg.arguments || [];
    forEach(objectKeys(msg.callbacks || {}), function (sid) {
        var id = parseInt(sid, 10);
        var path = msg.callbacks[id];
        traverse.set(args, path, f(id));
    });
    
    forEach(msg.links || [], function (link) {
        var value = traverse.get(args, link.from);
        traverse.set(args, link.to, value);
    });
    
    return args;
};

},{"./foreach":89,"./keys":91,"traverse":144}],93:[function(require,module,exports){
var dnode = require('./lib/dnode');

module.exports = function (cons, opts) {
    return new dnode(cons, opts);
};

},{"./lib/dnode":94}],94:[function(require,module,exports){
(function (process){
var protocol = require('dnode-protocol');
var Stream = require('stream');
var json = typeof JSON === 'object' ? JSON : require('jsonify');

module.exports = dnode;
dnode.prototype = {};
(function () { // browsers etc
    for (var key in Stream.prototype) {
        dnode.prototype[key] = Stream.prototype[key];
    }
})();

function dnode (cons, opts) {
    Stream.call(this);
    var self = this;
    
    self.opts = opts || {};
    
    self.cons = typeof cons === 'function'
        ? cons
        : function () { return cons || {} }
    ;
    
    self.readable = true;
    self.writable = true;
    
    process.nextTick(function () {
        if (self._ended) return;
        self.proto = self._createProto();
        self.proto.start();
        
        if (!self._handleQueue) return;
        for (var i = 0; i < self._handleQueue.length; i++) {
            self.handle(self._handleQueue[i]);
        }
    });
}

dnode.prototype._createProto = function () {
    var self = this;
    var proto = protocol(function (remote) {
        if (self._ended) return;
        
        var ref = self.cons.call(this, remote, self);
        if (typeof ref !== 'object') ref = this;
        
        self.emit('local', ref, self);
        
        return ref;
    }, self.opts.proto);
    
    proto.on('remote', function (remote) {
        self.emit('remote', remote, self);
        self.emit('ready'); // backwards compatability, deprecated
    });
    
    proto.on('request', function (req) {
        if (!self.readable) return;
        
        if (self.opts.emit === 'object') {
            self.emit('data', req);
        }
        else self.emit('data', json.stringify(req) + '\n');
    });
    
    proto.on('fail', function (err) {
        // errors that the remote end was responsible for
        self.emit('fail', err);
    });
    
    proto.on('error', function (err) {
        // errors that the local code was responsible for
        self.emit('error', err);
    });
    
    return proto;
};

dnode.prototype.write = function (buf) {
    if (this._ended) return;
    var self = this;
    var row;
    
    if (buf && typeof buf === 'object'
    && buf.constructor && buf.constructor.name === 'Buffer'
    && buf.length
    && typeof buf.slice === 'function') {
        // treat like a buffer
        if (!self._bufs) self._bufs = [];
        
        // treat like a buffer
        for (var i = 0, j = 0; i < buf.length; i++) {
            if (buf[i] === 0x0a) {
                self._bufs.push(buf.slice(j, i));
                
                var line = '';
                for (var k = 0; k < self._bufs.length; k++) {
                    line += String(self._bufs[k]);
                }
                
                try { row = json.parse(line) }
                catch (err) { return self.end() }
                
                j = i + 1;
                
                self.handle(row);
                self._bufs = [];
            }
        }
        
        if (j < buf.length) self._bufs.push(buf.slice(j, buf.length));
    }
    else if (buf && typeof buf === 'object') {
        // .isBuffer() without the Buffer
        // Use self to pipe JSONStream.parse() streams.
        self.handle(buf);
    }
    else {
        if (typeof buf !== 'string') buf = String(buf);
        if (!self._line) self._line = '';
        
        for (var i = 0; i < buf.length; i++) {
            if (buf.charCodeAt(i) === 0x0a) {
                try { row = json.parse(self._line) }
                catch (err) { return self.end() }
                
                self._line = '';
                self.handle(row);
            }
            else self._line += buf.charAt(i)
        }
    }
};

dnode.prototype.handle = function (row) {
    if (!this.proto) {
        if (!this._handleQueue) this._handleQueue = [];
        this._handleQueue.push(row);
    }
    else this.proto.handle(row);
};

dnode.prototype.end = function () {
    if (this._ended) return;
    this._ended = true;
    this.writable = false;
    this.readable = false;
    this.emit('end');
};

dnode.prototype.destroy = function () {
    this.end();
};

}).call(this,require('_process'))
},{"_process":160,"dnode-protocol":88,"jsonify":101,"stream":175}],95:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],96:[function(require,module,exports){
'use strict';

// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

},{}],97:[function(require,module,exports){
'use strict';

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

},{}],98:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],99:[function(require,module,exports){
/*
 Highcharts JS v8.1.0 (2020-05-05)

 (c) 2009-2018 Torstein Honsi

 License: www.highcharts.com/license
*/
(function(X,Q){"object"===typeof module&&module.exports?(Q["default"]=Q,module.exports=X.document?Q(X):Q):"function"===typeof define&&define.amd?define("highcharts/highcharts",function(){return Q(X)}):(X.Highcharts&&X.Highcharts.error(16,!0),X.Highcharts=Q(X))})("undefined"!==typeof window?window:this,function(X){function Q(d,f,E,q){d.hasOwnProperty(f)||(d[f]=q.apply(null,E))}var A={};Q(A,"parts/Globals.js",[],function(){var d="undefined"!==typeof X?X:"undefined"!==typeof window?window:{},f=d.document,
E=d.navigator&&d.navigator.userAgent||"",q=f&&f.createElementNS&&!!f.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,M=/(edge|msie|trident)/i.test(E)&&!d.opera,K=-1!==E.indexOf("Firefox"),J=-1!==E.indexOf("Chrome"),L=K&&4>parseInt(E.split("Firefox/")[1],10);return{product:"Highcharts",version:"8.1.0",deg2rad:2*Math.PI/360,doc:f,hasBidiBug:L,hasTouch:!!d.TouchEvent,isMS:M,isWebKit:-1!==E.indexOf("AppleWebKit"),isFirefox:K,isChrome:J,isSafari:!J&&-1!==E.indexOf("Safari"),isTouchDevice:/(Mobile|Android|Windows Phone)/.test(E),
SVG_NS:"http://www.w3.org/2000/svg",chartCount:0,seriesTypes:{},symbolSizes:{},svg:q,win:d,marginNames:["plotTop","marginRight","marginBottom","plotLeft"],noop:function(){},charts:[],dateFormats:{}}});Q(A,"parts/Utilities.js",[A["parts/Globals.js"]],function(d){function f(){var a,c=arguments,k={},r=function(a,c){"object"!==typeof a&&(a={});Z(c,function(k,e){!E(k,!0)||t(k)||n(k)?a[e]=c[e]:a[e]=r(a[e]||{},k)});return a};!0===c[0]&&(k=c[1],c=Array.prototype.slice.call(c,2));var e=c.length;for(a=0;a<
e;a++)k=r(k,c[a]);return k}function E(a,c){return!!a&&"object"===typeof a&&(!c||!w(a))}function q(a,c,k){var r;D(c)?b(k)?a.setAttribute(c,k):a&&a.getAttribute&&((r=a.getAttribute(c))||"class"!==c||(r=a.getAttribute(c+"Name"))):Z(c,function(c,k){a.setAttribute(k,c)});return r}function M(){for(var a=arguments,c=a.length,k=0;k<c;k++){var r=a[k];if("undefined"!==typeof r&&null!==r)return r}}function K(a,c){if(!a)return c;var k=a.split(".").reverse();if(1===k.length)return c[a];for(a=k.pop();"undefined"!==
typeof a&&"undefined"!==typeof c&&null!==c;)c=c[a],a=k.pop();return c}d.timers=[];var J=d.charts,L=d.doc,x=d.win,F=d.error=function(a,c,k,r){var e=N(a),z=e?"Highcharts error #"+a+": www.highcharts.com/errors/"+a+"/":a.toString(),b=function(){if(c)throw Error(z);x.console&&console.log(z)};if("undefined"!==typeof r){var g="";e&&(z+="?");Z(r,function(a,c){g+="\n"+c+": "+a;e&&(z+=encodeURI(c)+"="+encodeURI(a))});z+=g}k?ba(k,"displayError",{code:a,message:z,params:r},b):b()},H=function(){function a(a,
c,k){this.options=c;this.elem=a;this.prop=k}a.prototype.dSetter=function(){var a=this.paths,c=a&&a[0];a=a&&a[1];var k=[],r=this.now||0;if(1!==r&&c&&a)if(c.length===a.length&&1>r)for(var e=0;e<a.length;e++){for(var z=c[e],b=a[e],g=[],l=0;l<b.length;l++){var h=z[l],P=b[l];g[l]="number"===typeof h&&"number"===typeof P&&("A"!==b[0]||4!==l&&5!==l)?h+r*(P-h):P}k.push(g)}else k=a;else k=this.toD||[];this.elem.attr("d",k,void 0,!0)};a.prototype.update=function(){var a=this.elem,c=this.prop,k=this.now,r=this.options.step;
if(this[c+"Setter"])this[c+"Setter"]();else a.attr?a.element&&a.attr(c,k,null,!0):a.style[c]=k+this.unit;r&&r.call(a,k,this)};a.prototype.run=function(a,c,k){var r=this,e=r.options,z=function(a){return z.stopped?!1:r.step(a)},b=x.requestAnimationFrame||function(a){setTimeout(a,13)},l=function(){for(var a=0;a<d.timers.length;a++)d.timers[a]()||d.timers.splice(a--,1);d.timers.length&&b(l)};a!==c||this.elem["forceAnimate:"+this.prop]?(this.startTime=+new Date,this.start=a,this.end=c,this.unit=k,this.now=
this.start,this.pos=0,z.elem=this.elem,z.prop=this.prop,z()&&1===d.timers.push(z)&&b(l)):(delete e.curAnim[this.prop],e.complete&&0===Object.keys(e.curAnim).length&&e.complete.call(this.elem))};a.prototype.step=function(a){var c=+new Date,k=this.options,r=this.elem,e=k.complete,z=k.duration,b=k.curAnim;if(r.attr&&!r.element)a=!1;else if(a||c>=z+this.startTime){this.now=this.end;this.pos=1;this.update();var l=b[this.prop]=!0;Z(b,function(a){!0!==a&&(l=!1)});l&&e&&e.call(r);a=!1}else this.pos=k.easing((c-
this.startTime)/z),this.now=this.start+(this.end-this.start)*this.pos,this.update(),a=!0;return a};a.prototype.initPath=function(a,c,k){function r(a,c){for(;a.length<p;){var k=a[0],r=c[p-a.length];r&&"M"===k[0]&&(a[0]="C"===r[0]?["C",k[1],k[2],k[1],k[2],k[1],k[2]]:["L",k[1],k[2]]);a.unshift(k);l&&a.push(a[a.length-1])}}function e(a,c){for(;a.length<p;)if(c=a[a.length/g-1].slice(),"C"===c[0]&&(c[1]=c[5],c[2]=c[6]),l){var k=a[a.length/g].slice();a.splice(a.length/2,0,c,k)}else a.push(c)}var z=a.startX,
b=a.endX;c=c&&c.slice();k=k.slice();var l=a.isArea,g=l?2:1;if(!c)return[k,k];if(z&&b){for(a=0;a<z.length;a++)if(z[a]===b[0]){var h=a;break}else if(z[0]===b[b.length-z.length+a]){h=a;var P=!0;break}else if(z[z.length-1]===b[b.length-z.length+a]){h=z.length-a;break}"undefined"===typeof h&&(c=[])}if(c.length&&N(h)){var p=k.length+h*g;P?(r(c,k),e(k,c)):(r(k,c),e(c,k))}return[c,k]};a.prototype.fillSetter=function(){a.prototype.strokeSetter.apply(this,arguments)};a.prototype.strokeSetter=function(){this.elem.attr(this.prop,
d.color(this.start).tweenTo(d.color(this.end),this.pos),null,!0)};return a}();d.Fx=H;d.merge=f;var C=d.pInt=function(a,c){return parseInt(a,c||10)},D=d.isString=function(a){return"string"===typeof a},w=d.isArray=function(a){a=Object.prototype.toString.call(a);return"[object Array]"===a||"[object Array Iterator]"===a};d.isObject=E;var n=d.isDOMElement=function(a){return E(a)&&"number"===typeof a.nodeType},t=d.isClass=function(a){var c=a&&a.constructor;return!(!E(a,!0)||n(a)||!c||!c.name||"Object"===
c.name)},N=d.isNumber=function(a){return"number"===typeof a&&!isNaN(a)&&Infinity>a&&-Infinity<a},m=d.erase=function(a,c){for(var k=a.length;k--;)if(a[k]===c){a.splice(k,1);break}},b=d.defined=function(a){return"undefined"!==typeof a&&null!==a};d.attr=q;var g=d.splat=function(a){return w(a)?a:[a]},v=d.syncTimeout=function(a,c,k){if(0<c)return setTimeout(a,c,k);a.call(0,k);return-1},h=d.clearTimeout=function(a){b(a)&&clearTimeout(a)},e=d.extend=function(a,c){var k;a||(a={});for(k in c)a[k]=c[k];return a};
d.pick=M;var p=d.css=function(a,c){d.isMS&&!d.svg&&c&&"undefined"!==typeof c.opacity&&(c.filter="alpha(opacity="+100*c.opacity+")");e(a.style,c)},l=d.createElement=function(a,c,k,r,z){a=L.createElement(a);c&&e(a,c);z&&p(a,{padding:"0",border:"none",margin:"0"});k&&p(a,k);r&&r.appendChild(a);return a},I=d.extendClass=function(a,c){var k=function(){};k.prototype=new a;e(k.prototype,c);return k},u=d.pad=function(a,c,k){return Array((c||2)+1-String(a).replace("-","").length).join(k||"0")+a},y=d.relativeLength=
function(a,c,k){return/%$/.test(a)?c*parseFloat(a)/100+(k||0):parseFloat(a)},G=d.wrap=function(a,c,k){var r=a[c];a[c]=function(){var a=Array.prototype.slice.call(arguments),c=arguments,e=this;e.proceed=function(){r.apply(e,arguments.length?arguments:c)};a.unshift(r);a=k.apply(this,a);e.proceed=null;return a}},S=d.format=function(a,c,k){var r="{",e=!1,z=[],b=/f$/,l=/\.([0-9])/,g=d.defaultOptions.lang,h=k&&k.time||d.time;for(k=k&&k.numberFormatter||T;a;){var P=a.indexOf(r);if(-1===P)break;var p=a.slice(0,
P);if(e){p=p.split(":");r=K(p.shift()||"",c);if(p.length&&"number"===typeof r)if(p=p.join(":"),b.test(p)){var u=parseInt((p.match(l)||["","-1"])[1],10);null!==r&&(r=k(r,u,g.decimalPoint,-1<p.indexOf(",")?g.thousandsSep:""))}else r=h.dateFormat(p,r);z.push(r)}else z.push(p);a=a.slice(P+1);r=(e=!e)?"}":"{"}z.push(a);return z.join("")},R=d.getMagnitude=function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))},B=d.normalizeTickInterval=function(a,c,k,r,e){var z=a;k=M(k,1);var b=a/k;c||(c=e?[1,
1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===r&&(1===k?c=c.filter(function(a){return 0===a%1}):.1>=k&&(c=[1/k])));for(r=0;r<c.length&&!(z=c[r],e&&z*k>=a||!e&&b<=(c[r]+(c[r+1]||c[r]))/2);r++);return z=P(z*k,-Math.round(Math.log(.001)/Math.LN10))},c=d.stableSort=function(a,c){var k=a.length,r,e;for(e=0;e<k;e++)a[e].safeI=e;a.sort(function(a,k){r=c(a,k);return 0===r?a.safeI-k.safeI:r});for(e=0;e<k;e++)delete a[e].safeI},a=d.arrayMin=function(a){for(var c=a.length,k=a[0];c--;)a[c]<k&&(k=a[c]);return k},
k=d.arrayMax=function(a){for(var c=a.length,k=a[0];c--;)a[c]>k&&(k=a[c]);return k},r=d.destroyObjectProperties=function(a,c){Z(a,function(k,r){k&&k!==c&&k.destroy&&k.destroy();delete a[r]})},z=d.discardElement=function(a){var c=d.garbageBin;c||(c=l("div"));a&&c.appendChild(a);c.innerHTML=""},P=d.correctFloat=function(a,c){return parseFloat(a.toPrecision(c||14))},U=d.setAnimation=function(a,c){c.renderer.globalAnimation=M(a,c.options.chart.animation,!0)},W=d.animObject=function(a){return E(a)?f(a):
{duration:a?500:0}},Y=d.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5},T=d.numberFormat=function(a,c,k,r){a=+a||0;c=+c;var e=d.defaultOptions.lang,z=(a.toString().split(".")[1]||"").split("e")[0].length,b=a.toString().split("e");if(-1===c)c=Math.min(z,20);else if(!N(c))c=2;else if(c&&b[1]&&0>b[1]){var l=c+ +b[1];0<=l?(b[0]=(+b[0]).toExponential(l).split("e")[0],c=l):(b[0]=b[0].split(".")[0]||0,a=20>c?(b[0]*Math.pow(10,b[1])).toFixed(c):
0,b[1]=0)}var g=(Math.abs(b[1]?b[0]:a)+Math.pow(10,-Math.max(c,z)-1)).toFixed(c);z=String(C(g));l=3<z.length?z.length%3:0;k=M(k,e.decimalPoint);r=M(r,e.thousandsSep);a=(0>a?"-":"")+(l?z.substr(0,l)+r:"");a+=z.substr(l).replace(/(\d{3})(?=\d)/g,"$1"+r);c&&(a+=k+g.slice(-c));b[1]&&0!==+a&&(a+="e"+b[1]);return a};Math.easeInOutSine=function(a){return-.5*(Math.cos(Math.PI*a)-1)};var ca=d.getStyle=function(a,c,k){if("width"===c)return c=Math.min(a.offsetWidth,a.scrollWidth),k=a.getBoundingClientRect&&
a.getBoundingClientRect().width,k<c&&k>=c-1&&(c=Math.floor(k)),Math.max(0,c-d.getStyle(a,"padding-left")-d.getStyle(a,"padding-right"));if("height"===c)return Math.max(0,Math.min(a.offsetHeight,a.scrollHeight)-d.getStyle(a,"padding-top")-d.getStyle(a,"padding-bottom"));x.getComputedStyle||F(27,!0);if(a=x.getComputedStyle(a,void 0))a=a.getPropertyValue(c),M(k,"opacity"!==c)&&(a=C(a));return a},aa=d.inArray=function(a,c,k){return c.indexOf(a,k)},O=d.find=Array.prototype.find?function(a,c){return a.find(c)}:
function(a,c){var k,r=a.length;for(k=0;k<r;k++)if(c(a[k],k))return a[k]};d.keys=Object.keys;var V=d.offset=function(a){var c=L.documentElement;a=a.parentElement||a.parentNode?a.getBoundingClientRect():{top:0,left:0};return{top:a.top+(x.pageYOffset||c.scrollTop)-(c.clientTop||0),left:a.left+(x.pageXOffset||c.scrollLeft)-(c.clientLeft||0)}},da=d.stop=function(a,c){for(var k=d.timers.length;k--;)d.timers[k].elem!==a||c&&c!==d.timers[k].prop||(d.timers[k].stopped=!0)},Z=d.objectEach=function(a,c,k){for(var r in a)Object.hasOwnProperty.call(a,
r)&&c.call(k||a[r],a[r],r,a)};Z({map:"map",each:"forEach",grep:"filter",reduce:"reduce",some:"some"},function(a,c){d[c]=function(c){return Array.prototype[a].apply(c,[].slice.call(arguments,1))}});var ha=d.addEvent=function(a,c,k,r){void 0===r&&(r={});var e=a.addEventListener||d.addEventListenerPolyfill;var z="function"===typeof a&&a.prototype?a.prototype.protoEvents=a.prototype.protoEvents||{}:a.hcEvents=a.hcEvents||{};d.Point&&a instanceof d.Point&&a.series&&a.series.chart&&(a.series.chart.runTrackerClick=
!0);e&&e.call(a,c,k,!1);z[c]||(z[c]=[]);z[c].push({fn:k,order:"number"===typeof r.order?r.order:Infinity});z[c].sort(function(a,c){return a.order-c.order});return function(){ea(a,c,k)}},ea=d.removeEvent=function(a,c,k){function r(c,k){var r=a.removeEventListener||d.removeEventListenerPolyfill;r&&r.call(a,c,k,!1)}function e(k){var e;if(a.nodeName){if(c){var z={};z[c]=!0}else z=k;Z(z,function(a,c){if(k[c])for(e=k[c].length;e--;)r(c,k[c][e].fn)})}}var z;["protoEvents","hcEvents"].forEach(function(b,
l){var g=(l=l?a:a.prototype)&&l[b];g&&(c?(z=g[c]||[],k?(g[c]=z.filter(function(a){return k!==a.fn}),r(c,k)):(e(g),g[c]=[])):(e(g),l[b]={}))})},ba=d.fireEvent=function(a,c,k,r){var z;k=k||{};if(L.createEvent&&(a.dispatchEvent||a.fireEvent)){var b=L.createEvent("Events");b.initEvent(c,!0,!0);e(b,k);a.dispatchEvent?a.dispatchEvent(b):a.fireEvent(c,b)}else k.target||e(k,{preventDefault:function(){k.defaultPrevented=!0},target:a,type:c}),function(c,r){void 0===c&&(c=[]);void 0===r&&(r=[]);var e=0,b=0,
l=c.length+r.length;for(z=0;z<l;z++)!1===(c[e]?r[b]?c[e].order<=r[b].order?c[e++]:r[b++]:c[e++]:r[b++]).fn.call(a,k)&&k.preventDefault()}(a.protoEvents&&a.protoEvents[c],a.hcEvents&&a.hcEvents[c]);r&&!k.defaultPrevented&&r.call(a,k)},A=d.animate=function(a,c,k){var r,e="",z,b;if(!E(k)){var l=arguments;k={duration:l[2],easing:l[3],complete:l[4]}}N(k.duration)||(k.duration=400);k.easing="function"===typeof k.easing?k.easing:Math[k.easing]||Math.easeInOutSine;k.curAnim=f(c);Z(c,function(l,g){da(a,g);
b=new H(a,k,g);z=null;"d"===g&&w(c.d)?(b.paths=b.initPath(a,a.pathArray,c.d),b.toD=c.d,r=0,z=1):a.attr?r=a.attr(g):(r=parseFloat(ca(a,g))||0,"opacity"!==g&&(e="px"));z||(z=l);z&&z.match&&z.match("px")&&(z=z.replace(/px/g,""));b.run(r,z,e)})},ia=d.seriesType=function(a,c,k,r,e){var z=d.getOptions(),b=d.seriesTypes;z.plotOptions[a]=f(z.plotOptions[c],k);b[a]=I(b[c]||function(){},r);b[a].prototype.type=a;e&&(b[a].prototype.pointClass=I(d.Point,e));return b[a]},fa=d.uniqueKey=function(){var a=Math.random().toString(36).substring(2,
9),c=0;return function(){return"highcharts-"+a+"-"+c++}}(),ja=d.isFunction=function(a){return"function"===typeof a};x.jQuery&&(x.jQuery.fn.highcharts=function(){var a=[].slice.call(arguments);if(this[0])return a[0]?(new (d[D(a[0])?a.shift():"Chart"])(this[0],a[0],a[1]),this):J[q(this[0],"data-highcharts-chart")]});return{Fx:d.Fx,addEvent:ha,animate:A,animObject:W,arrayMax:k,arrayMin:a,attr:q,clamp:function(a,c,k){return a>c?a<k?a:k:c},clearTimeout:h,correctFloat:P,createElement:l,css:p,defined:b,
destroyObjectProperties:r,discardElement:z,erase:m,error:F,extend:e,extendClass:I,find:O,fireEvent:ba,format:S,getMagnitude:R,getNestedProperty:K,getStyle:ca,inArray:aa,isArray:w,isClass:t,isDOMElement:n,isFunction:ja,isNumber:N,isObject:E,isString:D,merge:f,normalizeTickInterval:B,numberFormat:T,objectEach:Z,offset:V,pad:u,pick:M,pInt:C,relativeLength:y,removeEvent:ea,seriesType:ia,setAnimation:U,splat:g,stableSort:c,stop:da,syncTimeout:v,timeUnits:Y,uniqueKey:fa,wrap:G}});Q(A,"parts/Color.js",[A["parts/Globals.js"],
A["parts/Utilities.js"]],function(d,f){var E=f.isNumber,q=f.merge,M=f.pInt;f=function(){function d(f){this.parsers=[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(d){return[M(d[1]),M(d[2]),M(d[3]),parseFloat(d[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(d){return[M(d[1]),M(d[2]),M(d[3]),1]}}];this.rgba=[];if(!(this instanceof d))return new d(f);this.init(f)}d.parse=function(f){return new d(f)};
d.prototype.init=function(f){var q,x;if((this.input=f=d.names[f&&f.toLowerCase?f.toLowerCase():""]||f)&&f.stops)this.stops=f.stops.map(function(f){return new d(f[1])});else{if(f&&f.charAt&&"#"===f.charAt()){var F=f.length;f=parseInt(f.substr(1),16);7===F?q=[(f&16711680)>>16,(f&65280)>>8,f&255,1]:4===F&&(q=[(f&3840)>>4|(f&3840)>>8,(f&240)>>4|f&240,(f&15)<<4|f&15,1])}if(!q)for(x=this.parsers.length;x--&&!q;){var H=this.parsers[x];(F=H.regex.exec(f))&&(q=H.parse(F))}}this.rgba=q||[]};d.prototype.get=
function(d){var f=this.input,x=this.rgba;if("undefined"!==typeof this.stops){var F=q(f);F.stops=[].concat(F.stops);this.stops.forEach(function(f,x){F.stops[x]=[F.stops[x][0],f.get(d)]})}else F=x&&E(x[0])?"rgb"===d||!d&&1===x[3]?"rgb("+x[0]+","+x[1]+","+x[2]+")":"a"===d?x[3]:"rgba("+x.join(",")+")":f;return F};d.prototype.brighten=function(d){var f,x=this.rgba;if(this.stops)this.stops.forEach(function(f){f.brighten(d)});else if(E(d)&&0!==d)for(f=0;3>f;f++)x[f]+=M(255*d),0>x[f]&&(x[f]=0),255<x[f]&&
(x[f]=255);return this};d.prototype.setOpacity=function(d){this.rgba[3]=d;return this};d.prototype.tweenTo=function(d,f){var x=this.rgba,q=d.rgba;q.length&&x&&x.length?(d=1!==q[3]||1!==x[3],f=(d?"rgba(":"rgb(")+Math.round(q[0]+(x[0]-q[0])*(1-f))+","+Math.round(q[1]+(x[1]-q[1])*(1-f))+","+Math.round(q[2]+(x[2]-q[2])*(1-f))+(d?","+(q[3]+(x[3]-q[3])*(1-f)):"")+")"):f=d.input||"none";return f};d.names={white:"#ffffff",black:"#000000"};return d}();d.Color=f;d.color=f.parse;return d.Color});Q(A,"parts/SVGElement.js",
[A["parts/Color.js"],A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f,E){var q=f.deg2rad,M=f.doc,K=f.hasTouch,J=f.isFirefox,L=f.noop,x=f.svg,F=f.SVG_NS,H=f.win,C=E.animate,D=E.animObject,w=E.attr,n=E.createElement,t=E.css,N=E.defined,m=E.erase,b=E.extend,g=E.fireEvent,v=E.inArray,h=E.isArray,e=E.isFunction,p=E.isNumber,l=E.isString,I=E.merge,u=E.objectEach,y=E.pick,G=E.pInt,S=E.stop,R=E.uniqueKey;E=function(){function B(){this.height=this.element=void 0;this.opacity=1;this.renderer=void 0;
this.SVG_NS=F;this.symbolCustomAttribs="x y width height r start end innerR anchorX anchorY rounded".split(" ");this.textProps="color cursor direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");this.width=void 0}B.prototype._defaultGetter=function(c){c=y(this[c+"Value"],this[c],this.element?this.element.getAttribute(c):null,0);/^[\-0-9\.]+$/.test(c)&&(c=parseFloat(c));return c};B.prototype._defaultSetter=function(c,a,k){k.setAttribute(a,
c)};B.prototype.add=function(c){var a=this.renderer,k=this.element;c&&(this.parentGroup=c);this.parentInverted=c&&c.inverted;"undefined"!==typeof this.textStr&&a.buildText(this);this.added=!0;if(!c||c.handleZ||this.zIndex)var r=this.zIndexSetter();r||(c?c.element:a.box).appendChild(k);if(this.onAdd)this.onAdd();return this};B.prototype.addClass=function(c,a){var k=a?"":this.attr("class")||"";c=(c||"").split(/ /g).reduce(function(a,c){-1===k.indexOf(c)&&a.push(c);return a},k?[k]:[]).join(" ");c!==
k&&this.attr("class",c);return this};B.prototype.afterSetters=function(){this.doTransform&&(this.updateTransform(),this.doTransform=!1)};B.prototype.align=function(c,a,k){var r,e={};var b=this.renderer;var g=b.alignedObjects;var h,p;if(c){if(this.alignOptions=c,this.alignByTranslate=a,!k||l(k))this.alignTo=r=k||"renderer",m(g,this),g.push(this),k=void 0}else c=this.alignOptions,a=this.alignByTranslate,r=this.alignTo;k=y(k,b[r],b);r=c.align;b=c.verticalAlign;g=(k.x||0)+(c.x||0);var u=(k.y||0)+(c.y||
0);"right"===r?h=1:"center"===r&&(h=2);h&&(g+=(k.width-(c.width||0))/h);e[a?"translateX":"x"]=Math.round(g);"bottom"===b?p=1:"middle"===b&&(p=2);p&&(u+=(k.height-(c.height||0))/p);e[a?"translateY":"y"]=Math.round(u);this[this.placed?"animate":"attr"](e);this.placed=!0;this.alignAttr=e;return this};B.prototype.alignSetter=function(c){var a={left:"start",center:"middle",right:"end"};a[c]&&(this.alignValue=c,this.element.setAttribute("text-anchor",a[c]))};B.prototype.animate=function(c,a,k){var r=D(y(a,
this.renderer.globalAnimation,!0));y(M.hidden,M.msHidden,M.webkitHidden,!1)&&(r.duration=0);0!==r.duration?(k&&(r.complete=k),C(this,c,r)):(this.attr(c,void 0,k),u(c,function(a,c){r.step&&r.step.call(this,a,{prop:c,pos:1})},this));return this};B.prototype.applyTextOutline=function(c){var a=this.element,k;-1!==c.indexOf("contrast")&&(c=c.replace(/contrast/g,this.renderer.getContrast(a.style.fill)));c=c.split(" ");var r=c[c.length-1];if((k=c[0])&&"none"!==k&&f.svg){this.fakeTS=!0;c=[].slice.call(a.getElementsByTagName("tspan"));
this.ySetter=this.xSetter;k=k.replace(/(^[\d\.]+)(.*?)$/g,function(a,c,k){return 2*c+k});this.removeTextOutline(c);var e=a.textContent?/^[\u0591-\u065F\u066A-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(a.textContent):!1;var b=a.firstChild;c.forEach(function(c,z){0===z&&(c.setAttribute("x",a.getAttribute("x")),z=a.getAttribute("y"),c.setAttribute("y",z||0),null===z&&a.setAttribute("y",0));z=c.cloneNode(!0);w(e&&!J?c:z,{"class":"highcharts-text-outline",fill:r,stroke:r,"stroke-width":k,"stroke-linejoin":"round"});
a.insertBefore(z,b)});e&&J&&c[0]&&(c=c[0].cloneNode(!0),c.textContent=" ",a.insertBefore(c,b))}};B.prototype.attr=function(c,a,k,r){var e=this.element,b,l=this,g,h,p=this.symbolCustomAttribs;if("string"===typeof c&&"undefined"!==typeof a){var m=c;c={};c[m]=a}"string"===typeof c?l=(this[c+"Getter"]||this._defaultGetter).call(this,c,e):(u(c,function(a,k){g=!1;r||S(this,k);this.symbolName&&-1!==v(k,p)&&(b||(this.symbolAttr(c),b=!0),g=!0);!this.rotation||"x"!==k&&"y"!==k||(this.doTransform=!0);g||(h=
this[k+"Setter"]||this._defaultSetter,h.call(this,a,k,e),!this.styledMode&&this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(k)&&this.updateShadows(k,a,h))},this),this.afterSetters());k&&k.call(this);return l};B.prototype.clip=function(c){return this.attr("clip-path",c?"url("+this.renderer.url+"#"+c.id+")":"none")};B.prototype.crisp=function(c,a){a=a||c.strokeWidth||0;var k=Math.round(a)%2/2;c.x=Math.floor(c.x||this.x||0)+k;c.y=Math.floor(c.y||this.y||0)+k;c.width=Math.floor((c.width||
this.width||0)-2*k);c.height=Math.floor((c.height||this.height||0)-2*k);N(c.strokeWidth)&&(c.strokeWidth=a);return c};B.prototype.complexColor=function(c,a,k){var r=this.renderer,e,b,l,p,m,v,y,n,O,V,t=[],G;g(this.renderer,"complexColor",{args:arguments},function(){c.radialGradient?b="radialGradient":c.linearGradient&&(b="linearGradient");if(b){l=c[b];m=r.gradients;v=c.stops;O=k.radialReference;h(l)&&(c[b]=l={x1:l[0],y1:l[1],x2:l[2],y2:l[3],gradientUnits:"userSpaceOnUse"});"radialGradient"===b&&O&&
!N(l.gradientUnits)&&(p=l,l=I(l,r.getRadialAttr(O,p),{gradientUnits:"userSpaceOnUse"}));u(l,function(a,c){"id"!==c&&t.push(c,a)});u(v,function(a){t.push(a)});t=t.join(",");if(m[t])V=m[t].attr("id");else{l.id=V=R();var z=m[t]=r.createElement(b).attr(l).add(r.defs);z.radAttr=p;z.stops=[];v.forEach(function(a){0===a[1].indexOf("rgba")?(e=d.parse(a[1]),y=e.get("rgb"),n=e.get("a")):(y=a[1],n=1);a=r.createElement("stop").attr({offset:a[0],"stop-color":y,"stop-opacity":n}).add(z);z.stops.push(a)})}G="url("+
r.url+"#"+V+")";k.setAttribute(a,G);k.gradient=t;c.toString=function(){return G}}})};B.prototype.css=function(c){var a=this.styles,k={},r=this.element,e="",l=!a,g=["textOutline","textOverflow","width"];c&&c.color&&(c.fill=c.color);a&&u(c,function(c,r){a&&a[r]!==c&&(k[r]=c,l=!0)});if(l){a&&(c=b(a,k));if(c)if(null===c.width||"auto"===c.width)delete this.textWidth;else if("text"===r.nodeName.toLowerCase()&&c.width)var h=this.textWidth=G(c.width);this.styles=c;h&&!x&&this.renderer.forExport&&delete c.width;
if(r.namespaceURI===this.SVG_NS){var p=function(a,c){return"-"+c.toLowerCase()};u(c,function(a,c){-1===g.indexOf(c)&&(e+=c.replace(/([A-Z])/g,p)+":"+a+";")});e&&w(r,"style",e)}else t(r,c);this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),c&&c.textOutline&&this.applyTextOutline(c.textOutline))}return this};B.prototype.dashstyleSetter=function(c){var a=this["stroke-width"];"inherit"===a&&(a=1);if(c=c&&c.toLowerCase()){var k=c.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot",
"3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(c=k.length;c--;)k[c]=""+G(k[c])*y(a,NaN);c=k.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",c)}};B.prototype.destroy=function(){var c=this,a=c.element||{},k=c.renderer,r=k.isSVG&&"SPAN"===a.nodeName&&c.parentGroup||void 0,e=a.ownerSVGElement;a.onclick=a.onmouseout=a.onmouseover=a.onmousemove=a.point=
null;S(c);if(c.clipPath&&e){var b=c.clipPath;[].forEach.call(e.querySelectorAll("[clip-path],[CLIP-PATH]"),function(a){-1<a.getAttribute("clip-path").indexOf(b.element.id)&&a.removeAttribute("clip-path")});c.clipPath=b.destroy()}if(c.stops){for(e=0;e<c.stops.length;e++)c.stops[e].destroy();c.stops.length=0;c.stops=void 0}c.safeRemoveChild(a);for(k.styledMode||c.destroyShadows();r&&r.div&&0===r.div.childNodes.length;)a=r.parentGroup,c.safeRemoveChild(r.div),delete r.div,r=a;c.alignTo&&m(k.alignedObjects,
c);u(c,function(a,k){c[k]&&c[k].parentGroup===c&&c[k].destroy&&c[k].destroy();delete c[k]})};B.prototype.destroyShadows=function(){(this.shadows||[]).forEach(function(c){this.safeRemoveChild(c)},this);this.shadows=void 0};B.prototype.destroyTextPath=function(c,a){var k=c.getElementsByTagName("text")[0];if(k){if(k.removeAttribute("dx"),k.removeAttribute("dy"),a.element.setAttribute("id",""),this.textPathWrapper&&k.getElementsByTagName("textPath").length){for(c=this.textPathWrapper.element.childNodes;c.length;)k.appendChild(c[0]);
k.removeChild(this.textPathWrapper.element)}}else if(c.getAttribute("dx")||c.getAttribute("dy"))c.removeAttribute("dx"),c.removeAttribute("dy");this.textPathWrapper&&(this.textPathWrapper=this.textPathWrapper.destroy())};B.prototype.dSetter=function(c,a,k){h(c)&&("string"===typeof c[0]&&(c=this.renderer.pathToSegments(c)),this.pathArray=c,c=c.reduce(function(a,c,k){return c&&c.join?(k?a+" ":"")+c.join(" "):(c||"").toString()},""));/(NaN| {2}|^$)/.test(c)&&(c="M 0 0");this[a]!==c&&(k.setAttribute(a,
c),this[a]=c)};B.prototype.fadeOut=function(c){var a=this;a.animate({opacity:0},{duration:y(c,150),complete:function(){a.attr({y:-9999}).hide()}})};B.prototype.fillSetter=function(c,a,k){"string"===typeof c?k.setAttribute(a,c):c&&this.complexColor(c,a,k)};B.prototype.getBBox=function(c,a){var k,r=this.renderer,z=this.element,l=this.styles,g=this.textStr,h=r.cache,p=r.cacheKeys,u=z.namespaceURI===this.SVG_NS;a=y(a,this.rotation,0);var m=r.styledMode?z&&B.prototype.getStyle.call(z,"font-size"):l&&l.fontSize;
if(N(g)){var v=g.toString();-1===v.indexOf("<")&&(v=v.replace(/[0-9]/g,"0"));v+=["",a,m,this.textWidth,l&&l.textOverflow,l&&l.fontWeight].join()}v&&!c&&(k=h[v]);if(!k){if(u||r.forExport){try{var O=this.fakeTS&&function(a){[].forEach.call(z.querySelectorAll(".highcharts-text-outline"),function(c){c.style.display=a})};e(O)&&O("none");k=z.getBBox?b({},z.getBBox()):{width:z.offsetWidth,height:z.offsetHeight};e(O)&&O("")}catch(V){""}if(!k||0>k.width)k={width:0,height:0}}else k=this.htmlGetBBox();r.isSVG&&
(c=k.width,r=k.height,u&&(k.height=r={"11px,17":14,"13px,20":16}[l&&l.fontSize+","+Math.round(r)]||r),a&&(l=a*q,k.width=Math.abs(r*Math.sin(l))+Math.abs(c*Math.cos(l)),k.height=Math.abs(r*Math.cos(l))+Math.abs(c*Math.sin(l))));if(v&&0<k.height){for(;250<p.length;)delete h[p.shift()];h[v]||p.push(v);h[v]=k}}return k};B.prototype.getStyle=function(c){return H.getComputedStyle(this.element||this,"").getPropertyValue(c)};B.prototype.hasClass=function(c){return-1!==(""+this.attr("class")).split(" ").indexOf(c)};
B.prototype.hide=function(c){c?this.attr({y:-9999}):this.attr({visibility:"hidden"});return this};B.prototype.htmlGetBBox=function(){return{height:0,width:0,x:0,y:0}};B.prototype.init=function(c,a){this.element="span"===a?n(a):M.createElementNS(this.SVG_NS,a);this.renderer=c;g(this,"afterInit")};B.prototype.invert=function(c){this.inverted=c;this.updateTransform();return this};B.prototype.on=function(c,a){var k,r,e=this.element,b;K&&"click"===c?(e.ontouchstart=function(a){k=a.touches[0].clientX;r=
a.touches[0].clientY},e.ontouchend=function(c){k&&4<=Math.sqrt(Math.pow(k-c.changedTouches[0].clientX,2)+Math.pow(r-c.changedTouches[0].clientY,2))||a.call(e,c);b=!0;c.preventDefault()},e.onclick=function(c){b||a.call(e,c)}):e["on"+c]=a;return this};B.prototype.opacitySetter=function(c,a,k){this[a]=c;k.setAttribute(a,c)};B.prototype.removeClass=function(c){return this.attr("class",(""+this.attr("class")).replace(l(c)?new RegExp(" ?"+c+" ?"):c,""))};B.prototype.removeTextOutline=function(c){for(var a=
c.length,k;a--;)k=c[a],"highcharts-text-outline"===k.getAttribute("class")&&m(c,this.element.removeChild(k))};B.prototype.safeRemoveChild=function(c){var a=c.parentNode;a&&a.removeChild(c)};B.prototype.setRadialReference=function(c){var a=this.element.gradient&&this.renderer.gradients[this.element.gradient];this.element.radialReference=c;a&&a.radAttr&&a.animate(this.renderer.getRadialAttr(c,a.radAttr));return this};B.prototype.setTextPath=function(c,a){var k=this.element,r={textAnchor:"text-anchor"},
e=!1,b=this.textPathWrapper,l=!b;a=I(!0,{enabled:!0,attributes:{dy:-5,startOffset:"50%",textAnchor:"middle"}},a);var g=a.attributes;if(c&&a&&a.enabled){b&&null===b.element.parentNode?(l=!0,b=b.destroy()):b&&this.removeTextOutline.call(b.parentGroup,[].slice.call(k.getElementsByTagName("tspan")));this.options&&this.options.padding&&(g.dx=-this.options.padding);b||(this.textPathWrapper=b=this.renderer.createElement("textPath"),e=!0);var h=b.element;(a=c.element.getAttribute("id"))||c.element.setAttribute("id",
a=R());if(l)for(c=k.getElementsByTagName("tspan");c.length;)c[0].setAttribute("y",0),p(g.dx)&&c[0].setAttribute("x",-g.dx),h.appendChild(c[0]);e&&b&&b.add({element:this.text?this.text.element:k});h.setAttributeNS("http://www.w3.org/1999/xlink","href",this.renderer.url+"#"+a);N(g.dy)&&(h.parentNode.setAttribute("dy",g.dy),delete g.dy);N(g.dx)&&(h.parentNode.setAttribute("dx",g.dx),delete g.dx);u(g,function(a,c){h.setAttribute(r[c]||c,a)});k.removeAttribute("transform");this.removeTextOutline.call(b,
[].slice.call(k.getElementsByTagName("tspan")));this.text&&!this.renderer.styledMode&&this.attr({fill:"none","stroke-width":0});this.applyTextOutline=this.updateTransform=L}else b&&(delete this.updateTransform,delete this.applyTextOutline,this.destroyTextPath(k,c),this.updateTransform(),this.options&&this.options.rotation&&this.applyTextOutline(this.options.style.textOutline));return this};B.prototype.shadow=function(c,a,k){var r=[],e=this.element,l=!1,g=this.oldShadowOptions;var h={color:"#000000",
offsetX:1,offsetY:1,opacity:.15,width:3};var p;!0===c?p=h:"object"===typeof c&&(p=b(h,c));p&&(p&&g&&u(p,function(a,c){a!==g[c]&&(l=!0)}),l&&this.destroyShadows(),this.oldShadowOptions=p);if(!p)this.destroyShadows();else if(!this.shadows){var m=p.opacity/p.width;var v=this.parentInverted?"translate(-1,-1)":"translate("+p.offsetX+", "+p.offsetY+")";for(h=1;h<=p.width;h++){var y=e.cloneNode(!1);var O=2*p.width+1-2*h;w(y,{stroke:c.color||"#000000","stroke-opacity":m*h,"stroke-width":O,transform:v,fill:"none"});
y.setAttribute("class",(y.getAttribute("class")||"")+" highcharts-shadow");k&&(w(y,"height",Math.max(w(y,"height")-O,0)),y.cutHeight=O);a?a.element.appendChild(y):e.parentNode&&e.parentNode.insertBefore(y,e);r.push(y)}this.shadows=r}return this};B.prototype.show=function(c){return this.attr({visibility:c?"inherit":"visible"})};B.prototype.strokeSetter=function(c,a,k){this[a]=c;this.stroke&&this["stroke-width"]?(B.prototype.fillSetter.call(this,this.stroke,"stroke",k),k.setAttribute("stroke-width",
this["stroke-width"]),this.hasStroke=!0):"stroke-width"===a&&0===c&&this.hasStroke?(k.removeAttribute("stroke"),this.hasStroke=!1):this.renderer.styledMode&&this["stroke-width"]&&(k.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0)};B.prototype.strokeWidth=function(){if(!this.renderer.styledMode)return this["stroke-width"]||0;var c=this.getStyle("stroke-width"),a=0;if(c.indexOf("px")===c.length-2)a=G(c);else if(""!==c){var k=M.createElementNS(F,"rect");w(k,{width:c,"stroke-width":0});
this.element.parentNode.appendChild(k);a=k.getBBox().width;k.parentNode.removeChild(k)}return a};B.prototype.symbolAttr=function(c){var a=this;"x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function(k){a[k]=y(c[k],a[k])});a.attr({d:a.renderer.symbols[a.symbolName](a.x,a.y,a.width,a.height,a)})};B.prototype.textSetter=function(c){c!==this.textStr&&(delete this.textPxLength,this.textStr=c,this.added&&this.renderer.buildText(this))};B.prototype.titleSetter=function(c){var a=
this.element.getElementsByTagName("title")[0];a||(a=M.createElementNS(this.SVG_NS,"title"),this.element.appendChild(a));a.firstChild&&a.removeChild(a.firstChild);a.appendChild(M.createTextNode(String(y(c,"")).replace(/<[^>]*>/g,"").replace(/&lt;/g,"<").replace(/&gt;/g,">")))};B.prototype.toFront=function(){var c=this.element;c.parentNode.appendChild(c);return this};B.prototype.translate=function(c,a){return this.attr({translateX:c,translateY:a})};B.prototype.updateShadows=function(c,a,k){var r=this.shadows;
if(r)for(var e=r.length;e--;)k.call(r[e],"height"===c?Math.max(a-(r[e].cutHeight||0),0):"d"===c?this.d:a,c,r[e])};B.prototype.updateTransform=function(){var c=this.translateX||0,a=this.translateY||0,k=this.scaleX,r=this.scaleY,e=this.inverted,b=this.rotation,l=this.matrix,g=this.element;e&&(c+=this.width,a+=this.height);c=["translate("+c+","+a+")"];N(l)&&c.push("matrix("+l.join(",")+")");e?c.push("rotate(90) scale(-1,1)"):b&&c.push("rotate("+b+" "+y(this.rotationOriginX,g.getAttribute("x"),0)+" "+
y(this.rotationOriginY,g.getAttribute("y")||0)+")");(N(k)||N(r))&&c.push("scale("+y(k,1)+" "+y(r,1)+")");c.length&&g.setAttribute("transform",c.join(" "))};B.prototype.visibilitySetter=function(c,a,k){"inherit"===c?k.removeAttribute(a):this[a]!==c&&k.setAttribute(a,c);this[a]=c};B.prototype.xGetter=function(c){"circle"===this.element.nodeName&&("x"===c?c="cx":"y"===c&&(c="cy"));return this._defaultGetter(c)};B.prototype.zIndexSetter=function(c,a){var k=this.renderer,r=this.parentGroup,e=(r||k).element||
k.box,b=this.element,l=!1;k=e===k.box;var g=this.added;var h;N(c)?(b.setAttribute("data-z-index",c),c=+c,this[a]===c&&(g=!1)):N(this[a])&&b.removeAttribute("data-z-index");this[a]=c;if(g){(c=this.zIndex)&&r&&(r.handleZ=!0);a=e.childNodes;for(h=a.length-1;0<=h&&!l;h--){r=a[h];g=r.getAttribute("data-z-index");var p=!N(g);if(r!==b)if(0>c&&p&&!k&&!h)e.insertBefore(b,a[h]),l=!0;else if(G(g)<=c||p&&(!N(c)||0<=c))e.insertBefore(b,a[h+1]||null),l=!0}l||(e.insertBefore(b,a[k?3:0]||null),l=!0)}return l};return B}();
E.prototype["stroke-widthSetter"]=E.prototype.strokeSetter;E.prototype.yGetter=E.prototype.xGetter;E.prototype.matrixSetter=E.prototype.rotationOriginXSetter=E.prototype.rotationOriginYSetter=E.prototype.rotationSetter=E.prototype.scaleXSetter=E.prototype.scaleYSetter=E.prototype.translateXSetter=E.prototype.translateYSetter=E.prototype.verticalAlignSetter=function(e,c){this[c]=e;this.doTransform=!0};f.SVGElement=E;return f.SVGElement});Q(A,"parts/SvgRenderer.js",[A["parts/Color.js"],A["parts/Globals.js"],
A["parts/SVGElement.js"],A["parts/Utilities.js"]],function(d,f,E,q){var M=d.parse,K=q.addEvent,J=q.attr,L=q.createElement,x=q.css,F=q.defined,H=q.destroyObjectProperties,C=q.extend,D=q.isArray,w=q.isNumber,n=q.isObject,t=q.isString,N=q.merge,m=q.objectEach,b=q.pick,g=q.pInt,v=q.removeEvent,h=q.splat,e=q.uniqueKey,p=f.charts,l=f.deg2rad,I=f.doc,u=f.isFirefox,y=f.isMS,G=f.isWebKit;q=f.noop;var S=f.svg,R=f.SVG_NS,B=f.symbolSizes,c=f.win;d=f.SVGRenderer=function(){this.init.apply(this,arguments)};C(d.prototype,
{Element:E,SVG_NS:R,init:function(a,k,r,e,b,l,g){var z=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"});g||z.css(this.getStyle(e));e=z.element;a.appendChild(e);J(a,"dir","ltr");-1===a.innerHTML.indexOf("xmlns")&&J(e,"xmlns",this.SVG_NS);this.isSVG=!0;this.box=e;this.boxWrapper=z;this.alignedObjects=[];this.url=(u||G)&&I.getElementsByTagName("base").length?c.location.href.split("#")[0].replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20"):"";this.createElement("desc").add().element.appendChild(I.createTextNode("Created with Highcharts 8.1.0"));
this.defs=this.createElement("defs").add();this.allowHTML=l;this.forExport=b;this.styledMode=g;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(k,r,!1);var h;u&&a.getBoundingClientRect&&(k=function(){x(a,{left:0,top:0});h=a.getBoundingClientRect();x(a,{left:Math.ceil(h.left)-h.left+"px",top:Math.ceil(h.top)-h.top+"px"})},k(),this.unSubPixelFix=K(c,"resize",k))},definition:function(a){function c(a,k){var e;h(a).forEach(function(a){var b=r.createElement(a.tagName),l={};
m(a,function(a,c){"tagName"!==c&&"children"!==c&&"textContent"!==c&&(l[c]=a)});b.attr(l);b.add(k||r.defs);a.textContent&&b.element.appendChild(I.createTextNode(a.textContent));c(a.children||[],b);e=b});return e}var r=this;return c(a)},getStyle:function(a){return this.style=C({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=
this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();H(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var c=new this.Element;c.init(this,a);return c},draw:q,getRadialAttr:function(a,c){return{cx:a[0]-a[2]/2+c.cx*a[2],cy:a[1]-a[2]/2+c.cy*a[2],r:c.r*a[2]}},truncate:function(a,c,r,e,b,l,g){var k=this,z=a.rotation,h,p=e?1:0,u=(r||e).length,P=u,m=[],v=function(a){c.firstChild&&
c.removeChild(c.firstChild);a&&c.appendChild(I.createTextNode(a))},y=function(l,z){z=z||l;if("undefined"===typeof m[z])if(c.getSubStringLength)try{m[z]=b+c.getSubStringLength(0,e?z+1:z)}catch(fa){""}else k.getSpanWidth&&(v(g(r||e,l)),m[z]=b+k.getSpanWidth(a,c));return m[z]},n;a.rotation=0;var U=y(c.textContent.length);if(n=b+U>l){for(;p<=u;)P=Math.ceil((p+u)/2),e&&(h=g(e,P)),U=y(P,h&&h.length-1),p===u?p=u+1:U>l?u=P-1:p=P;0===u?v(""):r&&u===r.length-1||v(h||g(r||e,P))}e&&e.splice(0,P);a.actualWidth=
U;a.rotation=z;return n},escapes:{"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},buildText:function(a){var c=a.element,r=this,e=r.forExport,l=b(a.textStr,"").toString(),h=-1!==l.indexOf("<"),p=c.childNodes,u,v=J(c,"x"),y=a.styles,n=a.textWidth,O=y&&y.lineHeight,V=y&&y.textOutline,t=y&&"ellipsis"===y.textOverflow,G=y&&"nowrap"===y.whiteSpace,d=y&&y.fontSize,w,B=p.length;y=n&&!a.added&&this.box;var f=function(a){var k;r.styledMode||(k=/(px|em)$/.test(a&&a.style.fontSize)?a.style.fontSize:
d||r.style.fontSize||12);return O?g(O):r.fontMetrics(k,a.getAttribute("style")?a:c).h},N=function(a,c){m(r.escapes,function(k,r){c&&-1!==c.indexOf(k)||(a=a.toString().replace(new RegExp(k,"g"),r))});return a},C=function(a,c){var k=a.indexOf("<");a=a.substring(k,a.indexOf(">")-k);k=a.indexOf(c+"=");if(-1!==k&&(k=k+c.length+1,c=a.charAt(k),'"'===c||"'"===c))return a=a.substring(k+1),a.substring(0,a.indexOf(c))},D=/<br.*?>/g;var q=[l,t,G,O,V,d,n].join();if(q!==a.textCache){for(a.textCache=q;B--;)c.removeChild(p[B]);
h||V||t||n||-1!==l.indexOf(" ")&&(!G||D.test(l))?(y&&y.appendChild(c),h?(l=r.styledMode?l.replace(/<(b|strong)>/g,'<span class="highcharts-strong">').replace(/<(i|em)>/g,'<span class="highcharts-emphasized">'):l.replace(/<(b|strong)>/g,'<span style="font-weight:bold">').replace(/<(i|em)>/g,'<span style="font-style:italic">'),l=l.replace(/<a/g,"<span").replace(/<\/(b|strong|i|em|a)>/g,"</span>").split(D)):l=[l],l=l.filter(function(a){return""!==a}),l.forEach(function(k,b){var l=0,g=0;k=k.replace(/^\s+|\s+$/g,
"").replace(/<span/g,"|||<span").replace(/<\/span>/g,"</span>|||");var z=k.split("|||");z.forEach(function(k){if(""!==k||1===z.length){var h={},p=I.createElementNS(r.SVG_NS,"tspan"),m,P;(m=C(k,"class"))&&J(p,"class",m);if(m=C(k,"style"))m=m.replace(/(;| |^)color([ :])/,"$1fill$2"),J(p,"style",m);(P=C(k,"href"))&&!e&&(J(p,"onclick",'location.href="'+P+'"'),J(p,"class","highcharts-anchor"),r.styledMode||x(p,{cursor:"pointer"}));k=N(k.replace(/<[a-zA-Z\/](.|\n)*?>/g,"")||" ");if(" "!==k){p.appendChild(I.createTextNode(k));
l?h.dx=0:b&&null!==v&&(h.x=v);J(p,h);c.appendChild(p);!l&&w&&(!S&&e&&x(p,{display:"block"}),J(p,"dy",f(p)));if(n){var O=k.replace(/([^\^])-/g,"$1- ").split(" ");h=!G&&(1<z.length||b||1<O.length);P=0;var y=f(p);if(t)u=r.truncate(a,p,k,void 0,0,Math.max(0,n-parseInt(d||12,10)),function(a,c){return a.substring(0,c)+"\u2026"});else if(h)for(;O.length;)O.length&&!G&&0<P&&(p=I.createElementNS(R,"tspan"),J(p,{dy:y,x:v}),m&&J(p,"style",m),p.appendChild(I.createTextNode(O.join(" ").replace(/- /g,"-"))),c.appendChild(p)),
r.truncate(a,p,null,O,0===P?g:0,n,function(a,c){return O.slice(0,c).join(" ").replace(/- /g,"-")}),g=a.actualWidth,P++}l++}}});w=w||c.childNodes.length}),t&&u&&a.attr("title",N(a.textStr,["&lt;","&gt;"])),y&&y.removeChild(c),V&&a.applyTextOutline&&a.applyTextOutline(V)):c.appendChild(I.createTextNode(N(l)))}},getContrast:function(a){a=M(a).rgba;a[0]*=1;a[1]*=1.2;a[2]*=.5;return 459<a[0]+a[1]+a[2]?"#000000":"#FFFFFF"},button:function(a,c,r,e,b,l,g,h,p,u){var k=this.label(a,c,r,p,void 0,void 0,u,void 0,
"button"),z=0,m=this.styledMode;k.attr(N({padding:8,r:2},b));if(!m){b=N({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",fontWeight:"normal"}},b);var P=b.style;delete b.style;l=N(b,{fill:"#e6e6e6"},l);var v=l.style;delete l.style;g=N(b,{fill:"#e6ebf5",style:{color:"#000000",fontWeight:"bold"}},g);var n=g.style;delete g.style;h=N(b,{style:{color:"#cccccc"}},h);var U=h.style;delete h.style}K(k.element,y?"mouseover":"mouseenter",function(){3!==z&&k.setState(1)});
K(k.element,y?"mouseout":"mouseleave",function(){3!==z&&k.setState(z)});k.setState=function(a){1!==a&&(k.state=z=a);k.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][a||0]);m||k.attr([b,l,g,h][a||0]).css([P,v,n,U][a||0])};m||k.attr(b).css(C({cursor:"default"},P));return k.on("click",function(a){3!==z&&e.call(k,a)})},crispLine:function(a,c,r){void 0===r&&(r="round");var k=a[0],e=a[1];k[1]===e[1]&&(k[1]=e[1]=Math[r](k[1])-
c%2/2);k[2]===e[2]&&(k[2]=e[2]=Math[r](k[2])+c%2/2);return a},path:function(a){var c=this.styledMode?{}:{fill:"none"};D(a)?c.d=a:n(a)&&C(c,a);return this.createElement("path").attr(c)},circle:function(a,c,r){a=n(a)?a:"undefined"===typeof a?{}:{x:a,y:c,r:r};c=this.createElement("circle");c.xSetter=c.ySetter=function(a,c,k){k.setAttribute("c"+c,a)};return c.attr(a)},arc:function(a,c,r,e,b,l){n(a)?(e=a,c=e.y,r=e.r,a=e.x):e={innerR:e,start:b,end:l};a=this.symbol("arc",a,c,r,r,e);a.r=r;return a},rect:function(a,
c,r,e,b,l){b=n(a)?a.r:b;var k=this.createElement("rect");a=n(a)?a:"undefined"===typeof a?{}:{x:a,y:c,width:Math.max(r,0),height:Math.max(e,0)};this.styledMode||("undefined"!==typeof l&&(a.strokeWidth=l,a=k.crisp(a)),a.fill="none");b&&(a.r=b);k.rSetter=function(a,c,r){k.r=a;J(r,{rx:a,ry:a})};k.rGetter=function(){return k.r};return k.attr(a)},setSize:function(a,c,r){var k=this.alignedObjects,e=k.length;this.width=a;this.height=c;for(this.boxWrapper.animate({width:a,height:c},{step:function(){this.attr({viewBox:"0 0 "+
this.attr("width")+" "+this.attr("height")})},duration:b(r,!0)?void 0:0});e--;)k[e].align()},g:function(a){var c=this.createElement("g");return a?c.attr({"class":"highcharts-"+a}):c},image:function(a,k,r,e,b,l){var g={preserveAspectRatio:"none"},h=function(a,c){a.setAttributeNS?a.setAttributeNS("http://www.w3.org/1999/xlink","href",c):a.setAttribute("hc-svg-href",c)},z=function(c){h(p.element,a);l.call(p,c)};1<arguments.length&&C(g,{x:k,y:r,width:e,height:b});var p=this.createElement("image").attr(g);
l?(h(p.element,"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="),g=new c.Image,K(g,"load",z),g.src=a,g.complete&&z({})):h(p.element,a);return p},symbol:function(a,c,r,e,l,g){var k=this,h=/^url\((.*?)\)$/,z=h.test(a),u=!z&&(this.symbols[a]?a:"circle"),m=u&&this.symbols[u],v;if(m){"number"===typeof c&&(v=m.call(this.symbols,Math.round(c||0),Math.round(r||0),e,l,g));var P=this.path(v);k.styledMode||P.attr("fill","none");C(P,{symbolName:u,x:c,y:r,width:e,height:l});g&&C(P,
g)}else if(z){var y=a.match(h)[1];P=this.image(y);P.imgwidth=b(B[y]&&B[y].width,g&&g.width);P.imgheight=b(B[y]&&B[y].height,g&&g.height);var n=function(){P.attr({width:P.width,height:P.height})};["width","height"].forEach(function(a){P[a+"Setter"]=function(a,c){var k={},r=this["img"+c],e="width"===c?"translateX":"translateY";this[c]=a;F(r)&&(g&&"within"===g.backgroundSize&&this.width&&this.height&&(r=Math.round(r*Math.min(this.width/this.imgwidth,this.height/this.imgheight))),this.element&&this.element.setAttribute(c,
r),this.alignByTranslate||(k[e]=((this[c]||0)-r)/2,this.attr(k)))}});F(c)&&P.attr({x:c,y:r});P.isImg=!0;F(P.imgwidth)&&F(P.imgheight)?n():(P.attr({width:0,height:0}),L("img",{onload:function(){var a=p[k.chartIndex];0===this.width&&(x(this,{position:"absolute",top:"-999em"}),I.body.appendChild(this));B[y]={width:this.width,height:this.height};P.imgwidth=this.width;P.imgheight=this.height;P.element&&n();this.parentNode&&this.parentNode.removeChild(this);k.imgCount--;if(!k.imgCount&&a&&!a.hasLoaded)a.onload()},
src:y}),this.imgCount++)}return P},symbols:{circle:function(a,c,r,e){return this.arc(a+r/2,c+e/2,r/2,e/2,{start:.5*Math.PI,end:2.5*Math.PI,open:!1})},square:function(a,c,r,e){return[["M",a,c],["L",a+r,c],["L",a+r,c+e],["L",a,c+e],["Z"]]},triangle:function(a,c,r,e){return[["M",a+r/2,c],["L",a+r,c+e],["L",a,c+e],["Z"]]},"triangle-down":function(a,c,r,e){return[["M",a,c],["L",a+r,c],["L",a+r/2,c+e],["Z"]]},diamond:function(a,c,r,e){return[["M",a+r/2,c],["L",a+r,c+e/2],["L",a+r/2,c+e],["L",a,c+e/2],["Z"]]},
arc:function(a,c,r,e,l){var k=l.start,g=l.r||r,h=l.r||e||r,p=l.end-.001;r=l.innerR;e=b(l.open,.001>Math.abs(l.end-l.start-2*Math.PI));var z=Math.cos(k),u=Math.sin(k),m=Math.cos(p);p=Math.sin(p);k=b(l.longArc,.001>l.end-k-Math.PI?0:1);g=[["M",a+g*z,c+h*u],["A",g,h,0,k,b(l.clockwise,1),a+g*m,c+h*p]];F(r)&&g.push(e?["M",a+r*m,c+r*p]:["L",a+r*m,c+r*p],["A",r,r,0,k,F(l.clockwise)?1-l.clockwise:0,a+r*z,c+r*u]);e||g.push(["Z"]);return g},callout:function(a,c,r,e,b){var k=Math.min(b&&b.r||0,r,e),l=k+6,g=
b&&b.anchorX;b=b&&b.anchorY;var h=[["M",a+k,c],["L",a+r-k,c],["C",a+r,c,a+r,c,a+r,c+k],["L",a+r,c+e-k],["C",a+r,c+e,a+r,c+e,a+r-k,c+e],["L",a+k,c+e],["C",a,c+e,a,c+e,a,c+e-k],["L",a,c+k],["C",a,c,a,c,a+k,c]];g&&g>r?b>c+l&&b<c+e-l?h.splice(3,1,["L",a+r,b-6],["L",a+r+6,b],["L",a+r,b+6],["L",a+r,c+e-k]):h.splice(3,1,["L",a+r,e/2],["L",g,b],["L",a+r,e/2],["L",a+r,c+e-k]):g&&0>g?b>c+l&&b<c+e-l?h.splice(7,1,["L",a,b+6],["L",a-6,b],["L",a,b-6],["L",a,c+k]):h.splice(7,1,["L",a,e/2],["L",g,b],["L",a,e/2],
["L",a,c+k]):b&&b>e&&g>a+l&&g<a+r-l?h.splice(5,1,["L",g+6,c+e],["L",g,c+e+6],["L",g-6,c+e],["L",a+k,c+e]):b&&0>b&&g>a+l&&g<a+r-l&&h.splice(1,1,["L",g-6,c],["L",g,c-6],["L",g+6,c],["L",r-k,c]);return h}},clipRect:function(a,c,r,b){var k=e()+"-",l=this.createElement("clipPath").attr({id:k}).add(this.defs);a=this.rect(a,c,r,b,0).add(l);a.id=k;a.clipPath=l;a.count=0;return a},text:function(a,c,e,b){var k={};if(b&&(this.allowHTML||!this.forExport))return this.html(a,c,e);k.x=Math.round(c||0);e&&(k.y=Math.round(e));
F(a)&&(k.text=a);a=this.createElement("text").attr(k);b||(a.xSetter=function(a,c,k){var e=k.getElementsByTagName("tspan"),r=k.getAttribute(c),b;for(b=0;b<e.length;b++){var l=e[b];l.getAttribute(c)===r&&l.setAttribute(c,a)}k.setAttribute(c,a)});return a},fontMetrics:function(a,k){a=!this.styledMode&&/px/.test(a)||!c.getComputedStyle?a||k&&k.style&&k.style.fontSize||this.style&&this.style.fontSize:k&&E.prototype.getStyle.call(k,"font-size");a=/px/.test(a)?g(a):12;k=24>a?a+3:Math.round(1.2*a);return{h:k,
b:Math.round(.8*k),f:a}},rotCorr:function(a,c,e){var k=a;c&&e&&(k=Math.max(k*Math.cos(c*l),4));return{x:-a/3*Math.sin(c*l),y:k}},pathToSegments:function(a){for(var c=[],e=[],b={A:8,C:7,H:2,L:3,M:3,Q:5,S:5,T:3,V:2},l=0;l<a.length;l++)t(e[0])&&w(a[l])&&e.length===b[e[0].toUpperCase()]&&a.splice(l,0,e[0].replace("M","L").replace("m","l")),"string"===typeof a[l]&&(e.length&&c.push(e.slice(0)),e.length=0),e.push(a[l]);c.push(e.slice(0));return c},label:function(a,c,e,b,l,g,h,p,u){var k=this,r=k.styledMode,
z=k.g("button"!==u&&"label"),m=z.text=k.text("",0,0,h).attr({zIndex:1}),y,P={width:0,height:0,x:0,y:0},n=P,t=0,I=3,G=0,U,d,B,f,S,R={},x,W,T=/^url\((.*?)\)$/.test(b),D=r||T,q=function(){return r?y.strokeWidth()%2/2:(x?parseInt(x,10):0)%2/2};u&&z.addClass("highcharts-"+u);var Y=function(){var a=m.element.style,c={};n=w(U)&&w(d)&&!S||!F(m.textStr)?P:m.getBBox();z.width=(U||n.width||0)+2*I+G;z.height=(d||n.height||0)+2*I;W=I+Math.min(k.fontMetrics(a&&a.fontSize,m).b,n.height||Infinity);D&&(y||(z.box=
y=k.symbols[b]||T?k.symbol(b):k.rect(),y.addClass(("button"===u?"":"highcharts-label-box")+(u?" highcharts-"+u+"-box":"")),y.add(z),a=q(),c.x=a,c.y=(p?-W:0)+a),c.width=Math.round(z.width),c.height=Math.round(z.height),y.attr(C(c,R)),R={})};var H=function(){var a=G+I;var c=p?0:W;F(U)&&n&&("center"===S||"right"===S)&&(a+={center:.5,right:1}[S]*(U-n.width));if(a!==m.x||c!==m.y)m.attr("x",a),m.hasBoxWidthChanged&&(n=m.getBBox(!0),Y()),"undefined"!==typeof c&&m.attr("y",c);m.x=a;m.y=c};var L=function(a,
c){y?y.attr(a,c):R[a]=c};z.onAdd=function(){m.add(z);z.attr({text:a||0===a?a:"",x:c,y:e});y&&F(l)&&z.attr({anchorX:l,anchorY:g})};z.widthSetter=function(a){U=w(a)?a:null};z.heightSetter=function(a){d=a};z["text-alignSetter"]=function(a){S=a};z.paddingSetter=function(a){F(a)&&a!==I&&(I=z.padding=a,H())};z.paddingLeftSetter=function(a){F(a)&&a!==G&&(G=a,H())};z.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==t&&(t=a,n&&z.attr({x:B}))};z.textSetter=function(a){"undefined"!==typeof a&&m.attr({text:a});
Y();H()};z["stroke-widthSetter"]=function(a,c){a&&(D=!0);x=this["stroke-width"]=a;L(c,a)};r?z.rSetter=function(a,c){L(c,a)}:z.strokeSetter=z.fillSetter=z.rSetter=function(a,c){"r"!==c&&("fill"===c&&a&&(D=!0),z[c]=a);L(c,a)};z.anchorXSetter=function(a,c){l=z.anchorX=a;L(c,Math.round(a)-q()-B)};z.anchorYSetter=function(a,c){g=z.anchorY=a;L(c,a-f)};z.xSetter=function(a){z.x=a;t&&(a-=t*((U||n.width)+2*I),z["forceAnimate:x"]=!0);B=Math.round(a);z.attr("translateX",B)};z.ySetter=function(a){f=z.y=Math.round(a);
z.attr("translateY",f)};z.isLabel=!0;var J=z.css;h={css:function(a){if(a){var c={};a=N(a);z.textProps.forEach(function(k){"undefined"!==typeof a[k]&&(c[k]=a[k],delete a[k])});m.css(c);var k="fontSize"in c||"fontWeight"in c;if("width"in c||k)Y(),k&&H()}return J.call(z,a)},getBBox:function(){return{width:n.width+2*I,height:n.height+2*I,x:n.x-I,y:n.y-I}},destroy:function(){v(z.element,"mouseenter");v(z.element,"mouseleave");m&&m.destroy();y&&(y=y.destroy());E.prototype.destroy.call(z);z=k=m=Y=H=L=null}};
z.on=function(a,c){var k=m&&"SPAN"===m.element.tagName?m:void 0;if(k){var e=function(e){("mouseenter"===a||"mouseleave"===a)&&e.relatedTarget instanceof Element&&(z.element.contains(e.relatedTarget)||k.element.contains(e.relatedTarget))||c.call(z.element,e)};k.on(a,e)}E.prototype.on.call(z,a,e||c);return z};r||(h.shadow=function(a){a&&(Y(),y&&y.shadow(a));return z});return C(z,h)}});f.Renderer=d});Q(A,"parts/Html.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.attr,q=f.createElement,
M=f.css,K=f.defined,J=f.extend,L=f.pick,x=f.pInt,F=d.isFirefox,H=d.isMS,C=d.isWebKit,D=d.SVGElement;f=d.SVGRenderer;var w=d.win;J(D.prototype,{htmlCss:function(n){var t="SPAN"===this.element.tagName&&n&&"width"in n,d=L(t&&n.width,void 0);if(t){delete n.width;this.textWidth=d;var m=!0}n&&"ellipsis"===n.textOverflow&&(n.whiteSpace="nowrap",n.overflow="hidden");this.styles=J(this.styles,n);M(this.element,n);m&&this.htmlUpdateTransform();return this},htmlGetBBox:function(){var n=this.element;return{x:n.offsetLeft,
y:n.offsetTop,width:n.offsetWidth,height:n.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var n=this.renderer,t=this.element,d=this.translateX||0,m=this.translateY||0,b=this.x||0,g=this.y||0,v=this.textAlign||"left",h={left:0,center:.5,right:1}[v],e=this.styles,p=e&&e.whiteSpace;M(t,{marginLeft:d,marginTop:m});!n.styledMode&&this.shadows&&this.shadows.forEach(function(e){M(e,{marginLeft:d+1,marginTop:m+1})});this.inverted&&[].forEach.call(t.childNodes,function(e){n.invertChild(e,t)});
if("SPAN"===t.tagName){e=this.rotation;var l=this.textWidth&&x(this.textWidth),I=[e,v,t.innerHTML,this.textWidth,this.textAlign].join(),u;(u=l!==this.oldTextWidth)&&!(u=l>this.oldTextWidth)&&((u=this.textPxLength)||(M(t,{width:"",whiteSpace:p||"nowrap"}),u=t.offsetWidth),u=u>l);u&&(/[ \-]/.test(t.textContent||t.innerText)||"ellipsis"===t.style.textOverflow)?(M(t,{width:l+"px",display:"block",whiteSpace:p||"normal"}),this.oldTextWidth=l,this.hasBoxWidthChanged=!0):this.hasBoxWidthChanged=!1;I!==this.cTT&&
(p=n.fontMetrics(t.style.fontSize,t).b,!K(e)||e===(this.oldRotation||0)&&v===this.oldAlign||this.setSpanRotation(e,h,p),this.getSpanCorrection(!K(e)&&this.textPxLength||t.offsetWidth,p,h,e,v));M(t,{left:b+(this.xCorr||0)+"px",top:g+(this.yCorr||0)+"px"});this.cTT=I;this.oldRotation=e;this.oldAlign=v}}else this.alignOnAdd=!0},setSpanRotation:function(n,t,d){var m={},b=this.renderer.getTransformKey();m[b]=m.transform="rotate("+n+"deg)";m[b+(F?"Origin":"-origin")]=m.transformOrigin=100*t+"% "+d+"px";
M(this.element,m)},getSpanCorrection:function(n,t,d){this.xCorr=-n*d;this.yCorr=-t}});J(f.prototype,{getTransformKey:function(){return H&&!/Edge/.test(w.navigator.userAgent)?"-ms-transform":C?"-webkit-transform":F?"MozTransform":w.opera?"-o-transform":""},html:function(n,t,d){var m=this.createElement("span"),b=m.element,g=m.renderer,v=g.isSVG,h=function(e,b){["opacity","visibility"].forEach(function(l){e[l+"Setter"]=function(g,h,p){var u=e.div?e.div.style:b;D.prototype[l+"Setter"].call(this,g,h,p);
u&&(u[h]=g)}});e.addedSetters=!0};m.textSetter=function(e){e!==b.innerHTML&&(delete this.bBox,delete this.oldTextWidth);this.textStr=e;b.innerHTML=L(e,"");m.doTransform=!0};v&&h(m,m.element.style);m.xSetter=m.ySetter=m.alignSetter=m.rotationSetter=function(e,b){"align"===b&&(b="textAlign");m[b]=e;m.doTransform=!0};m.afterSetters=function(){this.doTransform&&(this.htmlUpdateTransform(),this.doTransform=!1)};m.attr({text:n,x:Math.round(t),y:Math.round(d)}).css({position:"absolute"});g.styledMode||m.css({fontFamily:this.style.fontFamily,
fontSize:this.style.fontSize});b.style.whiteSpace="nowrap";m.css=m.htmlCss;v&&(m.add=function(e){var p=g.box.parentNode,l=[];if(this.parentGroup=e){var v=e.div;if(!v){for(;e;)l.push(e),e=e.parentGroup;l.reverse().forEach(function(e){function b(b,l){e[l]=b;"translateX"===l?u.left=b+"px":u.top=b+"px";e.doTransform=!0}var g=E(e.element,"class");v=e.div=e.div||q("div",g?{className:g}:void 0,{position:"absolute",left:(e.translateX||0)+"px",top:(e.translateY||0)+"px",display:e.display,opacity:e.opacity,
pointerEvents:e.styles&&e.styles.pointerEvents},v||p);var u=v.style;J(e,{classSetter:function(e){return function(b){this.element.setAttribute("class",b);e.className=b}}(v),on:function(){l[0].div&&m.on.apply({element:l[0].div},arguments);return e},translateXSetter:b,translateYSetter:b});e.addedSetters||h(e)})}}else v=p;v.appendChild(b);m.added=!0;m.alignOnAdd&&m.htmlUpdateTransform();return m});return m}})});Q(A,"parts/Tick.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.clamp,
q=f.correctFloat,M=f.defined,K=f.destroyObjectProperties,J=f.extend,L=f.fireEvent,x=f.isNumber,F=f.merge,H=f.objectEach,C=f.pick,D=d.deg2rad;f=function(){function d(n,t,d,m,b){this.isNewLabel=this.isNew=!0;this.axis=n;this.pos=t;this.type=d||"";this.parameters=b||{};this.tickmarkOffset=this.parameters.tickmarkOffset;this.options=this.parameters.options;L(this,"init");d||m||this.addLabel()}d.prototype.addLabel=function(){var n=this,t=n.axis,d=t.options,m=t.chart,b=t.categories,g=t.logarithmic,v=t.names,
h=n.pos,e=C(n.options&&n.options.labels,d.labels),p=t.tickPositions,l=h===p[0],I=h===p[p.length-1];v=this.parameters.category||(b?C(b[h],v[h],h):h);var u=n.label;b=(!e.step||1===e.step)&&1===t.tickInterval;p=p.info;var y,G;if(t.dateTime&&p){var f=m.time.resolveDTLFormat(d.dateTimeLabelFormats[!d.grid&&p.higherRanks[h]||p.unitName]);var w=f.main}n.isFirst=l;n.isLast=I;n.formatCtx={axis:t,chart:m,isFirst:l,isLast:I,dateTimeLabelFormat:w,tickPositionInfo:p,value:g?q(g.lin2log(v)):v,pos:h};d=t.labelFormatter.call(n.formatCtx,
this.formatCtx);if(G=f&&f.list)n.shortenLabel=function(){for(y=0;y<G.length;y++)if(u.attr({text:t.labelFormatter.call(J(n.formatCtx,{dateTimeLabelFormat:G[y]}))}),u.getBBox().width<t.getSlotWidth(n)-2*C(e.padding,5))return;u.attr({text:""})};b&&t._addedPlotLB&&t.isXAxis&&n.moveLabel(d,e);M(u)||n.movedLabel?u&&u.textStr!==d&&!b&&(!u.textWidth||e.style&&e.style.width||u.styles.width||u.css({width:null}),u.attr({text:d}),u.textPxLength=u.getBBox().width):(n.label=u=n.createLabel({x:0,y:0},d,e),n.rotation=
0)};d.prototype.createLabel=function(n,t,d){var m=this.axis,b=m.chart;if(n=M(t)&&d.enabled?b.renderer.text(t,n.x,n.y,d.useHTML).add(m.labelGroup):null)b.styledMode||n.css(F(d.style)),n.textPxLength=n.getBBox().width;return n};d.prototype.destroy=function(){K(this,this.axis)};d.prototype.getPosition=function(n,t,d,m){var b=this.axis,g=b.chart,v=m&&g.oldChartHeight||g.chartHeight;n={x:n?q(b.translate(t+d,null,null,m)+b.transB):b.left+b.offset+(b.opposite?(m&&g.oldChartWidth||g.chartWidth)-b.right-b.left:
0),y:n?v-b.bottom+b.offset-(b.opposite?b.height:0):q(v-b.translate(t+d,null,null,m)-b.transB)};n.y=E(n.y,-1E5,1E5);L(this,"afterGetPosition",{pos:n});return n};d.prototype.getLabelPosition=function(n,t,d,m,b,g,v,h){var e=this.axis,p=e.transA,l=e.isLinked&&e.linkedParent?e.linkedParent.reversed:e.reversed,I=e.staggerLines,u=e.tickRotCorr||{x:0,y:0},y=b.y,G=m||e.reserveSpaceDefault?0:-e.labelOffset*("center"===e.labelAlign?.5:1),f={};M(y)||(y=0===e.side?d.rotation?-8:-d.getBBox().height:2===e.side?
u.y+8:Math.cos(d.rotation*D)*(u.y-d.getBBox(!1,0).height/2));n=n+b.x+G+u.x-(g&&m?g*p*(l?-1:1):0);t=t+y-(g&&!m?g*p*(l?1:-1):0);I&&(d=v/(h||1)%I,e.opposite&&(d=I-d-1),t+=e.labelOffset/I*d);f.x=n;f.y=Math.round(t);L(this,"afterGetLabelPosition",{pos:f,tickmarkOffset:g,index:v});return f};d.prototype.getLabelSize=function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0};d.prototype.getMarkPath=function(n,d,f,m,b,g){return g.crispLine([["M",n,d],["L",n+(b?0:-f),d+(b?f:0)]],
m)};d.prototype.handleOverflow=function(n){var d=this.axis,f=d.options.labels,m=n.x,b=d.chart.chartWidth,g=d.chart.spacing,v=C(d.labelLeft,Math.min(d.pos,g[3]));g=C(d.labelRight,Math.max(d.isRadial?0:d.pos+d.len,b-g[1]));var h=this.label,e=this.rotation,p={left:0,center:.5,right:1}[d.labelAlign||h.attr("align")],l=h.getBBox().width,I=d.getSlotWidth(this),u=I,y=1,G,w={};if(e||"justify"!==C(f.overflow,"justify"))0>e&&m-p*l<v?G=Math.round(m/Math.cos(e*D)-v):0<e&&m+p*l>g&&(G=Math.round((b-m)/Math.cos(e*
D)));else if(b=m+(1-p)*l,m-p*l<v?u=n.x+u*(1-p)-v:b>g&&(u=g-n.x+u*p,y=-1),u=Math.min(I,u),u<I&&"center"===d.labelAlign&&(n.x+=y*(I-u-p*(I-Math.min(l,u)))),l>u||d.autoRotation&&(h.styles||{}).width)G=u;G&&(this.shortenLabel?this.shortenLabel():(w.width=Math.floor(G)+"px",(f.style||{}).textOverflow||(w.textOverflow="ellipsis"),h.css(w)))};d.prototype.moveLabel=function(n,d){var t=this,m=t.label,b=!1,g=t.axis,v=g.reversed,h=g.chart.inverted;m&&m.textStr===n?(t.movedLabel=m,b=!0,delete t.label):H(g.ticks,
function(e){b||e.isNew||e===t||!e.label||e.label.textStr!==n||(t.movedLabel=e.label,b=!0,e.labelPos=t.movedLabel.xy,delete e.label)});if(!b&&(t.labelPos||m)){var e=t.labelPos||m.xy;m=h?e.x:v?0:g.width+g.left;g=h?v?g.width+g.left:0:e.y;t.movedLabel=t.createLabel({x:m,y:g},n,d);t.movedLabel&&t.movedLabel.attr({opacity:0})}};d.prototype.render=function(n,d,f){var m=this.axis,b=m.horiz,g=this.pos,v=C(this.tickmarkOffset,m.tickmarkOffset);g=this.getPosition(b,g,v,d);v=g.x;var h=g.y;m=b&&v===m.pos+m.len||
!b&&h===m.pos?-1:1;f=C(f,1);this.isActive=!0;this.renderGridLine(d,f,m);this.renderMark(g,f,m);this.renderLabel(g,d,f,n);this.isNew=!1;L(this,"afterRender")};d.prototype.renderGridLine=function(n,d,f){var m=this.axis,b=m.options,g=this.gridLine,v={},h=this.pos,e=this.type,p=C(this.tickmarkOffset,m.tickmarkOffset),l=m.chart.renderer,I=e?e+"Grid":"grid",u=b[I+"LineWidth"],y=b[I+"LineColor"];b=b[I+"LineDashStyle"];g||(m.chart.styledMode||(v.stroke=y,v["stroke-width"]=u,b&&(v.dashstyle=b)),e||(v.zIndex=
1),n&&(d=0),this.gridLine=g=l.path().attr(v).addClass("highcharts-"+(e?e+"-":"")+"grid-line").add(m.gridGroup));if(g&&(f=m.getPlotLinePath({value:h+p,lineWidth:g.strokeWidth()*f,force:"pass",old:n})))g[n||this.isNew?"attr":"animate"]({d:f,opacity:d})};d.prototype.renderMark=function(n,d,f){var m=this.axis,b=m.options,g=m.chart.renderer,v=this.type,h=v?v+"Tick":"tick",e=m.tickSize(h),p=this.mark,l=!p,I=n.x;n=n.y;var u=C(b[h+"Width"],!v&&m.isXAxis?1:0);b=b[h+"Color"];e&&(m.opposite&&(e[0]=-e[0]),l&&
(this.mark=p=g.path().addClass("highcharts-"+(v?v+"-":"")+"tick").add(m.axisGroup),m.chart.styledMode||p.attr({stroke:b,"stroke-width":u})),p[l?"attr":"animate"]({d:this.getMarkPath(I,n,e[0],p.strokeWidth()*f,m.horiz,g),opacity:d}))};d.prototype.renderLabel=function(n,d,f,m){var b=this.axis,g=b.horiz,v=b.options,h=this.label,e=v.labels,p=e.step;b=C(this.tickmarkOffset,b.tickmarkOffset);var l=!0,I=n.x;n=n.y;h&&x(I)&&(h.xy=n=this.getLabelPosition(I,n,h,g,e,b,m,p),this.isFirst&&!this.isLast&&!C(v.showFirstLabel,
1)||this.isLast&&!this.isFirst&&!C(v.showLastLabel,1)?l=!1:!g||e.step||e.rotation||d||0===f||this.handleOverflow(n),p&&m%p&&(l=!1),l&&x(n.y)?(n.opacity=f,h[this.isNewLabel?"attr":"animate"](n),this.isNewLabel=!1):(h.attr("y",-9999),this.isNewLabel=!0))};d.prototype.replaceMovedLabel=function(){var n=this.label,d=this.axis,f=d.reversed,m=this.axis.chart.inverted;if(n&&!this.isNew){var b=m?n.xy.x:f?d.left:d.width+d.left;f=m?f?d.width+d.top:d.top:n.xy.y;n.animate({x:b,y:f,opacity:0},void 0,n.destroy);
delete this.label}d.isDirty=!0;this.label=this.movedLabel;delete this.movedLabel};return d}();d.Tick=f;return d.Tick});Q(A,"parts/Time.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.defined,q=f.error,M=f.extend,K=f.isObject,J=f.merge,L=f.objectEach,x=f.pad,F=f.pick,H=f.splat,C=f.timeUnits,D=d.win;f=function(){function f(d){this.options={};this.variableTimezone=this.useUTC=!1;this.Date=D.Date;this.getTimezoneOffset=this.timezoneOffsetFunction();this.update(d)}f.prototype.get=
function(d,t){if(this.variableTimezone||this.timezoneOffset){var n=t.getTime(),m=n-this.getTimezoneOffset(t);t.setTime(m);d=t["getUTC"+d]();t.setTime(n);return d}return this.useUTC?t["getUTC"+d]():t["get"+d]()};f.prototype.set=function(d,t,f){if(this.variableTimezone||this.timezoneOffset){if("Milliseconds"===d||"Seconds"===d||"Minutes"===d)return t["setUTC"+d](f);var m=this.getTimezoneOffset(t);m=t.getTime()-m;t.setTime(m);t["setUTC"+d](f);d=this.getTimezoneOffset(t);m=t.getTime()+d;return t.setTime(m)}return this.useUTC?
t["setUTC"+d](f):t["set"+d](f)};f.prototype.update=function(d){var n=F(d&&d.useUTC,!0);this.options=d=J(!0,this.options||{},d);this.Date=d.Date||D.Date||Date;this.timezoneOffset=(this.useUTC=n)&&d.timezoneOffset;this.getTimezoneOffset=this.timezoneOffsetFunction();this.variableTimezone=!(n&&!d.getTimezoneOffset&&!d.timezone)};f.prototype.makeTime=function(n,f,w,m,b,g){if(this.useUTC){var v=this.Date.UTC.apply(0,arguments);var h=this.getTimezoneOffset(v);v+=h;var e=this.getTimezoneOffset(v);h!==e?
v+=e-h:h-36E5!==this.getTimezoneOffset(v-36E5)||d.isSafari||(v-=36E5)}else v=(new this.Date(n,f,F(w,1),F(m,0),F(b,0),F(g,0))).getTime();return v};f.prototype.timezoneOffsetFunction=function(){var d=this,f=this.options,w=D.moment;if(!this.useUTC)return function(m){return 6E4*(new Date(m.toString())).getTimezoneOffset()};if(f.timezone){if(w)return function(m){return 6E4*-w.tz(m,f.timezone).utcOffset()};q(25)}return this.useUTC&&f.getTimezoneOffset?function(m){return 6E4*f.getTimezoneOffset(m.valueOf())}:
function(){return 6E4*(d.timezoneOffset||0)}};f.prototype.dateFormat=function(n,f,w){var m;if(!E(f)||isNaN(f))return(null===(m=d.defaultOptions.lang)||void 0===m?void 0:m.invalidDate)||"";n=F(n,"%Y-%m-%d %H:%M:%S");var b=this;m=new this.Date(f);var g=this.get("Hours",m),v=this.get("Day",m),h=this.get("Date",m),e=this.get("Month",m),p=this.get("FullYear",m),l=d.defaultOptions.lang,I=null===l||void 0===l?void 0:l.weekdays,u=null===l||void 0===l?void 0:l.shortWeekdays;m=M({a:u?u[v]:I[v].substr(0,3),
A:I[v],d:x(h),e:x(h,2," "),w:v,b:l.shortMonths[e],B:l.months[e],m:x(e+1),o:e+1,y:p.toString().substr(2,2),Y:p,H:x(g),k:g,I:x(g%12||12),l:g%12||12,M:x(this.get("Minutes",m)),p:12>g?"AM":"PM",P:12>g?"am":"pm",S:x(m.getSeconds()),L:x(Math.floor(f%1E3),3)},d.dateFormats);L(m,function(e,l){for(;-1!==n.indexOf("%"+l);)n=n.replace("%"+l,"function"===typeof e?e.call(b,f):e)});return w?n.substr(0,1).toUpperCase()+n.substr(1):n};f.prototype.resolveDTLFormat=function(d){return K(d,!0)?d:(d=H(d),{main:d[0],from:d[1],
to:d[2]})};f.prototype.getTimeTicks=function(d,f,w,m){var b=this,g=[],v={};var h=new b.Date(f);var e=d.unitRange,p=d.count||1,l;m=F(m,1);if(E(f)){b.set("Milliseconds",h,e>=C.second?0:p*Math.floor(b.get("Milliseconds",h)/p));e>=C.second&&b.set("Seconds",h,e>=C.minute?0:p*Math.floor(b.get("Seconds",h)/p));e>=C.minute&&b.set("Minutes",h,e>=C.hour?0:p*Math.floor(b.get("Minutes",h)/p));e>=C.hour&&b.set("Hours",h,e>=C.day?0:p*Math.floor(b.get("Hours",h)/p));e>=C.day&&b.set("Date",h,e>=C.month?1:Math.max(1,
p*Math.floor(b.get("Date",h)/p)));if(e>=C.month){b.set("Month",h,e>=C.year?0:p*Math.floor(b.get("Month",h)/p));var n=b.get("FullYear",h)}e>=C.year&&b.set("FullYear",h,n-n%p);e===C.week&&(n=b.get("Day",h),b.set("Date",h,b.get("Date",h)-n+m+(n<m?-7:0)));n=b.get("FullYear",h);m=b.get("Month",h);var u=b.get("Date",h),y=b.get("Hours",h);f=h.getTime();b.variableTimezone&&(l=w-f>4*C.month||b.getTimezoneOffset(f)!==b.getTimezoneOffset(w));f=h.getTime();for(h=1;f<w;)g.push(f),f=e===C.year?b.makeTime(n+h*p,
0):e===C.month?b.makeTime(n,m+h*p):!l||e!==C.day&&e!==C.week?l&&e===C.hour&&1<p?b.makeTime(n,m,u,y+h*p):f+e*p:b.makeTime(n,m,u+h*p*(e===C.day?1:7)),h++;g.push(f);e<=C.hour&&1E4>g.length&&g.forEach(function(e){0===e%18E5&&"000000000"===b.dateFormat("%H%M%S%L",e)&&(v[e]="day")})}g.info=M(d,{higherRanks:v,totalRange:e*p});return g};f.defaultOptions={Date:void 0,getTimezoneOffset:void 0,timezone:void 0,timezoneOffset:0,useUTC:!0};return f}();d.Time=f;return d.Time});Q(A,"parts/Options.js",[A["parts/Globals.js"],
A["parts/Time.js"],A["parts/Color.js"],A["parts/Utilities.js"]],function(d,f,E,q){E=E.parse;var M=q.merge;d.defaultOptions={colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{},time:f.defaultOptions,chart:{styledMode:!1,borderRadius:0,colorCount:10,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}},width:null,height:null,borderColor:"#335cad",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"},title:{text:"Chart title",align:"center",margin:15,
widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},caption:{margin:15,text:"",align:"left",verticalAlign:"bottom"},plotOptions:{},labels:{style:{position:"absolute",color:"#333333"}},legend:{enabled:!0,align:"center",alignColumns:!0,layout:"horizontal",labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{activeColor:"#003399",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",cursor:"pointer",fontSize:"12px",fontWeight:"bold",textOverflow:"ellipsis"},
itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#cccccc"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:d.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",
second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",padding:8,snap:d.isTouchDevice?25:10,headerFormat:'<span style="font-size: 10px">{point.key}</span><br/>',pointFormat:'<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',backgroundColor:E("#f7f7f7").setOpacity(.85).get(),borderWidth:1,shadow:!0,style:{color:"#333333",cursor:"default",fontSize:"12px",
whiteSpace:"nowrap"}},credits:{enabled:!0,href:"https://www.highcharts.com?credits",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"9px"},text:"Highcharts.com"}};d.setOptions=function(f){d.defaultOptions=M(!0,d.defaultOptions,f);(f.time||f.global)&&d.time.update(M(d.defaultOptions.global,d.defaultOptions.time,f.global,f.time));return d.defaultOptions};d.getOptions=function(){return d.defaultOptions};d.defaultPlotOptions=d.defaultOptions.plotOptions;
d.time=new f(M(d.defaultOptions.global,d.defaultOptions.time));d.dateFormat=function(f,q,L){return d.time.dateFormat(f,q,L)};""});Q(A,"parts/Axis.js",[A["parts/Color.js"],A["parts/Globals.js"],A["parts/Tick.js"],A["parts/Utilities.js"]],function(d,f,E,q){var M=q.addEvent,K=q.animObject,J=q.arrayMax,L=q.arrayMin,x=q.clamp,F=q.correctFloat,H=q.defined,C=q.destroyObjectProperties,D=q.error,w=q.extend,n=q.fireEvent,t=q.format,N=q.getMagnitude,m=q.isArray,b=q.isFunction,g=q.isNumber,v=q.isString,h=q.merge,
e=q.normalizeTickInterval,p=q.objectEach,l=q.pick,I=q.relativeLength,u=q.removeEvent,y=q.splat,G=q.syncTimeout,S=f.defaultOptions,R=f.deg2rad;q=function(){function B(c,a){this.zoomEnabled=this.width=this.visible=this.userOptions=this.translationSlope=this.transB=this.transA=this.top=this.ticks=this.tickRotCorr=this.tickPositions=this.tickmarkOffset=this.tickInterval=this.tickAmount=this.side=this.series=this.right=this.positiveValuesOnly=this.pos=this.pointRangePadding=this.pointRange=this.plotLinesAndBandsGroups=
this.plotLinesAndBands=this.paddedTicks=this.overlap=this.options=this.oldMin=this.oldMax=this.offset=this.names=this.minPixelPadding=this.minorTicks=this.minorTickInterval=this.min=this.maxLabelLength=this.max=this.len=this.left=this.labelFormatter=this.labelEdge=this.isLinked=this.height=this.hasVisibleSeries=this.hasNames=this.coll=this.closestPointRange=this.chart=this.categories=this.bottom=this.alternateBands=void 0;this.init(c,a)}B.prototype.init=function(c,a){var k=a.isX,e=this;e.chart=c;
e.horiz=c.inverted&&!e.isZAxis?!k:k;e.isXAxis=k;e.coll=e.coll||(k?"xAxis":"yAxis");n(this,"init",{userOptions:a});e.opposite=a.opposite;e.side=a.side||(e.horiz?e.opposite?0:2:e.opposite?1:3);e.setOptions(a);var g=this.options,h=g.type;e.labelFormatter=g.labels.formatter||e.defaultLabelFormatter;e.userOptions=a;e.minPixelPadding=0;e.reversed=g.reversed;e.visible=!1!==g.visible;e.zoomEnabled=!1!==g.zoomEnabled;e.hasNames="category"===h||!0===g.categories;e.categories=g.categories||e.hasNames;e.names||
(e.names=[],e.names.keys={});e.plotLinesAndBandsGroups={};e.positiveValuesOnly=!(!e.logarithmic||g.allowNegativeLog);e.isLinked=H(g.linkedTo);e.ticks={};e.labelEdge=[];e.minorTicks={};e.plotLinesAndBands=[];e.alternateBands={};e.len=0;e.minRange=e.userMinRange=g.minRange||g.maxZoom;e.range=g.range;e.offset=g.offset||0;e.max=null;e.min=null;e.crosshair=l(g.crosshair,y(c.options.tooltip.crosshairs)[k?0:1],!1);a=e.options.events;-1===c.axes.indexOf(e)&&(k?c.axes.splice(c.xAxis.length,0,e):c.axes.push(e),
c[e.coll].push(e));e.series=e.series||[];c.inverted&&!e.isZAxis&&k&&"undefined"===typeof e.reversed&&(e.reversed=!0);e.labelRotation=e.options.labels.rotation;p(a,function(a,c){b(a)&&M(e,c,a)});n(this,"afterInit")};B.prototype.setOptions=function(c){this.options=h(B.defaultOptions,"yAxis"===this.coll&&B.defaultYAxisOptions,[B.defaultTopAxisOptions,B.defaultRightAxisOptions,B.defaultBottomAxisOptions,B.defaultLeftAxisOptions][this.side],h(S[this.coll],c));n(this,"afterSetOptions",{userOptions:c})};
B.prototype.defaultLabelFormatter=function(){var c=this.axis,a=this.value,k=c.chart.time,e=c.categories,b=this.dateTimeLabelFormat,l=S.lang,g=l.numericSymbols;l=l.numericSymbolMagnitude||1E3;var h=g&&g.length,p=c.options.labels.format;c=c.logarithmic?Math.abs(a):c.tickInterval;var m=this.chart,u=m.numberFormatter;if(p)var v=t(p,this,m);else if(e)v=a;else if(b)v=k.dateFormat(b,a);else if(h&&1E3<=c)for(;h--&&"undefined"===typeof v;)k=Math.pow(l,h+1),c>=k&&0===10*a%k&&null!==g[h]&&0!==a&&(v=u(a/k,-1)+
g[h]);"undefined"===typeof v&&(v=1E4<=Math.abs(a)?u(a,-1):u(a,-1,void 0,""));return v};B.prototype.getSeriesExtremes=function(){var c=this,a=c.chart,k;n(this,"getSeriesExtremes",null,function(){c.hasVisibleSeries=!1;c.dataMin=c.dataMax=c.threshold=null;c.softThreshold=!c.isXAxis;c.stacking&&c.stacking.buildStacks();c.series.forEach(function(e){if(e.visible||!a.options.chart.ignoreHiddenSeries){var b=e.options,r=b.threshold;c.hasVisibleSeries=!0;c.positiveValuesOnly&&0>=r&&(r=null);if(c.isXAxis){if(b=
e.xData,b.length){k=e.getXExtremes(b);var h=k.min;var p=k.max;g(h)||h instanceof Date||(b=b.filter(g),k=e.getXExtremes(b),h=k.min,p=k.max);b.length&&(c.dataMin=Math.min(l(c.dataMin,h),h),c.dataMax=Math.max(l(c.dataMax,p),p))}}else if(e=e.applyExtremes(),g(e.dataMin)&&(h=e.dataMin,c.dataMin=Math.min(l(c.dataMin,h),h)),g(e.dataMax)&&(p=e.dataMax,c.dataMax=Math.max(l(c.dataMax,p),p)),H(r)&&(c.threshold=r),!b.softThreshold||c.positiveValuesOnly)c.softThreshold=!1}})});n(this,"afterGetSeriesExtremes")};
B.prototype.translate=function(c,a,k,e,b,l){var r=this.linkedParent||this,h=1,p=0,z=e?r.oldTransA:r.transA;e=e?r.oldMin:r.min;var m=r.minPixelPadding;b=(r.isOrdinal||r.brokenAxis&&r.brokenAxis.hasBreaks||r.logarithmic&&b)&&r.lin2val;z||(z=r.transA);k&&(h*=-1,p=r.len);r.reversed&&(h*=-1,p-=h*(r.sector||r.len));a?(c=(c*h+p-m)/z+e,b&&(c=r.lin2val(c))):(b&&(c=r.val2lin(c)),c=g(e)?h*(c-e)*z+p+h*m+(g(l)?z*l:0):void 0);return c};B.prototype.toPixels=function(c,a){return this.translate(c,!1,!this.horiz,null,
!0)+(a?0:this.pos)};B.prototype.toValue=function(c,a){return this.translate(c-(a?0:this.pos),!0,!this.horiz,null,!0)};B.prototype.getPlotLinePath=function(c){function a(a,c,k){if("pass"!==d&&a<c||a>k)d?a=x(a,c,k):B=!0;return a}var k=this,e=k.chart,b=k.left,h=k.top,p=c.old,m=c.value,u=c.translatedValue,v=c.lineWidth,d=c.force,y,O,f,I,G=p&&e.oldChartHeight||e.chartHeight,t=p&&e.oldChartWidth||e.chartWidth,B,w=k.transB;c={value:m,lineWidth:v,old:p,force:d,acrossPanes:c.acrossPanes,translatedValue:u};
n(this,"getPlotLinePath",c,function(c){u=l(u,k.translate(m,null,null,p));u=x(u,-1E5,1E5);y=f=Math.round(u+w);O=I=Math.round(G-u-w);g(u)?k.horiz?(O=h,I=G-k.bottom,y=f=a(y,b,b+k.width)):(y=b,f=t-k.right,O=I=a(O,h,h+k.height)):(B=!0,d=!1);c.path=B&&!d?null:e.renderer.crispLine([["M",y,O],["L",f,I]],v||1)});return c.path};B.prototype.getLinearTickPositions=function(c,a,k){var e=F(Math.floor(a/c)*c);k=F(Math.ceil(k/c)*c);var b=[],l;F(e+c)===e&&(l=20);if(this.single)return[a];for(a=e;a<=k;){b.push(a);a=
F(a+c,l);if(a===g)break;var g=a}return b};B.prototype.getMinorTickInterval=function(){var c=this.options;return!0===c.minorTicks?l(c.minorTickInterval,"auto"):!1===c.minorTicks?null:c.minorTickInterval};B.prototype.getMinorTickPositions=function(){var c=this.options,a=this.tickPositions,k=this.minorTickInterval,e=[],b=this.pointRangePadding||0,l=this.min-b;b=this.max+b;var g=b-l;if(g&&g/k<this.len/3){var h=this.logarithmic;if(h)this.paddedTicks.forEach(function(a,c,b){c&&e.push.apply(e,h.getLogTickPositions(k,
b[c-1],b[c],!0))});else if(this.dateTime&&"auto"===this.getMinorTickInterval())e=e.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(k),l,b,c.startOfWeek));else for(c=l+(a[0]-l)%k;c<=b&&c!==e[0];c+=k)e.push(c)}0!==e.length&&this.trimTicks(e);return e};B.prototype.adjustForMinRange=function(){var c=this.options,a=this.min,k=this.max,e=this.logarithmic,b,g,h,p,u;this.isXAxis&&"undefined"===typeof this.minRange&&!e&&(H(c.min)||H(c.max)?this.minRange=null:(this.series.forEach(function(a){p=
a.xData;for(g=u=a.xIncrement?1:p.length-1;0<g;g--)if(h=p[g]-p[g-1],"undefined"===typeof b||h<b)b=h}),this.minRange=Math.min(5*b,this.dataMax-this.dataMin)));if(k-a<this.minRange){var m=this.dataMax-this.dataMin>=this.minRange;var v=this.minRange;var d=(v-k+a)/2;d=[a-d,l(c.min,a-d)];m&&(d[2]=this.logarithmic?this.logarithmic.log2lin(this.dataMin):this.dataMin);a=J(d);k=[a+v,l(c.max,a+v)];m&&(k[2]=e?e.log2lin(this.dataMax):this.dataMax);k=L(k);k-a<v&&(d[0]=k-v,d[1]=l(c.min,k-v),a=J(d))}this.min=a;this.max=
k};B.prototype.getClosest=function(){var c;this.categories?c=1:this.series.forEach(function(a){var k=a.closestPointRange,e=a.visible||!a.chart.options.chart.ignoreHiddenSeries;!a.noSharedTooltip&&H(k)&&e&&(c=H(c)?Math.min(c,k):k)});return c};B.prototype.nameToX=function(c){var a=m(this.categories),k=a?this.categories:this.names,e=c.options.x;c.series.requireSorting=!1;H(e)||(e=!1===this.options.uniqueNames?c.series.autoIncrement():a?k.indexOf(c.name):l(k.keys[c.name],-1));if(-1===e){if(!a)var b=k.length}else b=
e;"undefined"!==typeof b&&(this.names[b]=c.name,this.names.keys[c.name]=b);return b};B.prototype.updateNames=function(){var c=this,a=this.names;0<a.length&&(Object.keys(a.keys).forEach(function(c){delete a.keys[c]}),a.length=0,this.minRange=this.userMinRange,(this.series||[]).forEach(function(a){a.xIncrement=null;if(!a.points||a.isDirtyData)c.max=Math.max(c.max,a.xData.length-1),a.processData(),a.generatePoints();a.data.forEach(function(e,k){if(e&&e.options&&"undefined"!==typeof e.name){var b=c.nameToX(e);
"undefined"!==typeof b&&b!==e.x&&(e.x=b,a.xData[k]=b)}})}))};B.prototype.setAxisTranslation=function(c){var a=this,e=a.max-a.min,b=a.axisPointRange||0,g=0,h=0,p=a.linkedParent,m=!!a.categories,u=a.transA,d=a.isXAxis;if(d||m||b){var y=a.getClosest();p?(g=p.minPointOffset,h=p.pointRangePadding):a.series.forEach(function(c){var e=m?1:d?l(c.options.pointRange,y,0):a.axisPointRange||0,k=c.options.pointPlacement;b=Math.max(b,e);if(!a.single||m)c=c.is("xrange")?!d:d,g=Math.max(g,c&&v(k)?0:e/2),h=Math.max(h,
c&&"on"===k?0:e)});p=a.ordinal&&a.ordinal.slope&&y?a.ordinal.slope/y:1;a.minPointOffset=g*=p;a.pointRangePadding=h*=p;a.pointRange=Math.min(b,a.single&&m?1:e);d&&(a.closestPointRange=y)}c&&(a.oldTransA=u);a.translationSlope=a.transA=u=a.staticScale||a.len/(e+h||1);a.transB=a.horiz?a.left:a.bottom;a.minPixelPadding=u*g;n(this,"afterSetAxisTranslation")};B.prototype.minFromRange=function(){return this.max-this.range};B.prototype.setTickInterval=function(c){var a=this,k=a.chart,b=a.logarithmic,h=a.options,
p=a.isXAxis,m=a.isLinked,u=h.maxPadding,v=h.minPadding,d=h.tickInterval,y=h.tickPixelInterval,f=a.categories,O=g(a.threshold)?a.threshold:null,I=a.softThreshold;a.dateTime||f||m||this.getTickAmount();var G=l(a.userMin,h.min);var t=l(a.userMax,h.max);if(m){a.linkedParent=k[a.coll][h.linkedTo];var B=a.linkedParent.getExtremes();a.min=l(B.min,B.dataMin);a.max=l(B.max,B.dataMax);h.type!==a.linkedParent.options.type&&D(11,1,k)}else{if(!I&&H(O))if(a.dataMin>=O)B=O,v=0;else if(a.dataMax<=O){var w=O;u=0}a.min=
l(G,B,a.dataMin);a.max=l(t,w,a.dataMax)}b&&(a.positiveValuesOnly&&!c&&0>=Math.min(a.min,l(a.dataMin,a.min))&&D(10,1,k),a.min=F(b.log2lin(a.min),16),a.max=F(b.log2lin(a.max),16));a.range&&H(a.max)&&(a.userMin=a.min=G=Math.max(a.dataMin,a.minFromRange()),a.userMax=t=a.max,a.range=null);n(a,"foundExtremes");a.beforePadding&&a.beforePadding();a.adjustForMinRange();!(f||a.axisPointRange||a.stacking&&a.stacking.usePercentage||m)&&H(a.min)&&H(a.max)&&(k=a.max-a.min)&&(!H(G)&&v&&(a.min-=k*v),!H(t)&&u&&(a.max+=
k*u));g(a.userMin)||(g(h.softMin)&&h.softMin<a.min&&(a.min=G=h.softMin),g(h.floor)&&(a.min=Math.max(a.min,h.floor)));g(a.userMax)||(g(h.softMax)&&h.softMax>a.max&&(a.max=t=h.softMax),g(h.ceiling)&&(a.max=Math.min(a.max,h.ceiling)));I&&H(a.dataMin)&&(O=O||0,!H(G)&&a.min<O&&a.dataMin>=O?a.min=a.options.minRange?Math.min(O,a.max-a.minRange):O:!H(t)&&a.max>O&&a.dataMax<=O&&(a.max=a.options.minRange?Math.max(O,a.min+a.minRange):O));a.tickInterval=a.min===a.max||"undefined"===typeof a.min||"undefined"===
typeof a.max?1:m&&!d&&y===a.linkedParent.options.tickPixelInterval?d=a.linkedParent.tickInterval:l(d,this.tickAmount?(a.max-a.min)/Math.max(this.tickAmount-1,1):void 0,f?1:(a.max-a.min)*y/Math.max(a.len,y));p&&!c&&a.series.forEach(function(c){c.processData(a.min!==a.oldMin||a.max!==a.oldMax)});a.setAxisTranslation(!0);a.beforeSetTickPositions&&a.beforeSetTickPositions();a.ordinal&&(a.tickInterval=a.ordinal.postProcessTickInterval(a.tickInterval));a.pointRange&&!d&&(a.tickInterval=Math.max(a.pointRange,
a.tickInterval));c=l(h.minTickInterval,a.dateTime&&a.closestPointRange);!d&&a.tickInterval<c&&(a.tickInterval=c);a.dateTime||a.logarithmic||d||(a.tickInterval=e(a.tickInterval,void 0,N(a.tickInterval),l(h.allowDecimals,.5>a.tickInterval||void 0!==this.tickAmount),!!this.tickAmount));this.tickAmount||(a.tickInterval=a.unsquish());this.setTickPositions()};B.prototype.setTickPositions=function(){var c=this.options,a=c.tickPositions;var e=this.getMinorTickInterval();var b=c.tickPositioner,l=this.hasVerticalPanning(),
g="colorAxis"===this.coll,h=(g||!l)&&c.startOnTick;l=(g||!l)&&c.endOnTick;this.tickmarkOffset=this.categories&&"between"===c.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval="auto"===e&&this.tickInterval?this.tickInterval/5:e;this.single=this.min===this.max&&H(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==c.allowDecimals);this.tickPositions=e=a&&a.slice();!e&&(this.ordinal&&this.ordinal.positions||!((this.max-this.min)/this.tickInterval>Math.max(2*this.len,
200))?e=this.dateTime?this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval,c.units),this.min,this.max,c.startOfWeek,this.ordinal&&this.ordinal.positions,this.closestPointRange,!0):this.logarithmic?this.logarithmic.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max):(e=[this.min,this.max],D(19,!1,this.chart)),e.length>this.len&&(e=[e[0],e.pop()],e[0]===e[1]&&(e.length=1)),this.tickPositions=e,b&&(b=b.apply(this,
[this.min,this.max])))&&(this.tickPositions=e=b);this.paddedTicks=e.slice(0);this.trimTicks(e,h,l);this.isLinked||(this.single&&2>e.length&&!this.categories&&!this.series.some(function(a){return a.is("heatmap")&&"between"===a.options.pointPlacement})&&(this.min-=.5,this.max+=.5),a||b||this.adjustTickAmount());n(this,"afterSetTickPositions")};B.prototype.trimTicks=function(c,a,e){var k=c[0],b=c[c.length-1],l=!this.isOrdinal&&this.minPointOffset||0;n(this,"trimTicks");if(!this.isLinked){if(a&&-Infinity!==
k)this.min=k;else for(;this.min-l>c[0];)c.shift();if(e)this.max=b;else for(;this.max+l<c[c.length-1];)c.pop();0===c.length&&H(k)&&!this.options.tickPositions&&c.push((b+k)/2)}};B.prototype.alignToOthers=function(){var c={},a,e=this.options;!1===this.chart.options.chart.alignTicks||!1===e.alignTicks||!1===e.startOnTick||!1===e.endOnTick||this.logarithmic||this.chart[this.coll].forEach(function(e){var k=e.options;k=[e.horiz?k.left:k.top,k.width,k.height,k.pane].join();e.series.length&&(c[k]?a=!0:c[k]=
1)});return a};B.prototype.getTickAmount=function(){var c=this.options,a=c.tickAmount,e=c.tickPixelInterval;!H(c.tickInterval)&&!a&&this.len<e&&!this.isRadial&&!this.logarithmic&&c.startOnTick&&c.endOnTick&&(a=2);!a&&this.alignToOthers()&&(a=Math.ceil(this.len/e)+1);4>a&&(this.finalTickAmt=a,a=5);this.tickAmount=a};B.prototype.adjustTickAmount=function(){var c=this.options,a=this.tickInterval,e=this.tickPositions,b=this.tickAmount,g=this.finalTickAmt,h=e&&e.length,p=l(this.threshold,this.softThreshold?
0:null),m;if(this.hasData()){if(h<b){for(m=this.min;e.length<b;)e.length%2||m===p?e.push(F(e[e.length-1]+a)):e.unshift(F(e[0]-a));this.transA*=(h-1)/(b-1);this.min=c.startOnTick?e[0]:Math.min(this.min,e[0]);this.max=c.endOnTick?e[e.length-1]:Math.max(this.max,e[e.length-1])}else h>b&&(this.tickInterval*=2,this.setTickPositions());if(H(g)){for(a=c=e.length;a--;)(3===g&&1===a%2||2>=g&&0<a&&a<c-1)&&e.splice(a,1);this.finalTickAmt=void 0}}};B.prototype.setScale=function(){var c,a=!1,e=!1;this.series.forEach(function(c){var k;
a=a||c.isDirtyData||c.isDirty;e=e||(null===(k=c.xAxis)||void 0===k?void 0:k.isDirty)||!1});this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();(c=this.len!==this.oldAxisLength)||a||e||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.stacking&&this.stacking.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,
this.isDirty||(this.isDirty=c||this.min!==this.oldMin||this.max!==this.oldMax)):this.stacking&&this.stacking.cleanStacks();a&&this.panningState&&(this.panningState.isDirty=!0);n(this,"afterSetScale")};B.prototype.setExtremes=function(c,a,e,b,g){var k=this,h=k.chart;e=l(e,!0);k.series.forEach(function(a){delete a.kdTree});g=w(g,{min:c,max:a});n(k,"setExtremes",g,function(){k.userMin=c;k.userMax=a;k.eventArgs=g;e&&h.redraw(b)})};B.prototype.zoom=function(c,a){var e=this,b=this.dataMin,g=this.dataMax,
h=this.options,p=Math.min(b,l(h.min,b)),m=Math.max(g,l(h.max,g));c={newMin:c,newMax:a};n(this,"zoom",c,function(a){var c=a.newMin,k=a.newMax;if(c!==e.min||k!==e.max)e.allowZoomOutside||(H(b)&&(c<p&&(c=p),c>m&&(c=m)),H(g)&&(k<p&&(k=p),k>m&&(k=m))),e.displayBtn="undefined"!==typeof c||"undefined"!==typeof k,e.setExtremes(c,k,!1,void 0,{trigger:"zoom"});a.zoomed=!0});return c.zoomed};B.prototype.setAxisSize=function(){var c=this.chart,a=this.options,e=a.offsets||[0,0,0,0],b=this.horiz,g=this.width=Math.round(I(l(a.width,
c.plotWidth-e[3]+e[1]),c.plotWidth)),h=this.height=Math.round(I(l(a.height,c.plotHeight-e[0]+e[2]),c.plotHeight)),p=this.top=Math.round(I(l(a.top,c.plotTop+e[0]),c.plotHeight,c.plotTop));a=this.left=Math.round(I(l(a.left,c.plotLeft+e[3]),c.plotWidth,c.plotLeft));this.bottom=c.chartHeight-h-p;this.right=c.chartWidth-g-a;this.len=Math.max(b?g:h,0);this.pos=b?a:p};B.prototype.getExtremes=function(){var c=this.logarithmic;return{min:c?F(c.lin2log(this.min)):this.min,max:c?F(c.lin2log(this.max)):this.max,
dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}};B.prototype.getThreshold=function(c){var a=this.logarithmic,e=a?a.lin2log(this.min):this.min;a=a?a.lin2log(this.max):this.max;null===c||-Infinity===c?c=e:Infinity===c?c=a:e>c?c=e:a<c&&(c=a);return this.translate(c,0,1,0,1)};B.prototype.autoLabelAlign=function(c){var a=(l(c,0)-90*this.side+720)%360;c={align:"center"};n(this,"autoLabelAlign",c,function(c){15<a&&165>a?c.align="right":195<a&&345>a&&(c.align="left")});
return c.align};B.prototype.tickSize=function(c){var a=this.options,e=a["tick"===c?"tickLength":"minorTickLength"],b=l(a["tick"===c?"tickWidth":"minorTickWidth"],"tick"===c&&this.isXAxis&&!this.categories?1:0);if(b&&e){"inside"===a[c+"Position"]&&(e=-e);var g=[e,b]}c={tickSize:g};n(this,"afterTickSize",c);return c.tickSize};B.prototype.labelMetrics=function(){var c=this.tickPositions&&this.tickPositions[0]||0;return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,
this.ticks[c]&&this.ticks[c].label)};B.prototype.unsquish=function(){var c=this.options.labels,a=this.horiz,e=this.tickInterval,b=e,g=this.len/(((this.categories?1:0)+this.max-this.min)/e),h,p=c.rotation,m=this.labelMetrics(),u,v=Number.MAX_VALUE,d,y=this.max-this.min,f=function(a){var c=a/(g||1);c=1<c?Math.ceil(c):1;c*e>y&&Infinity!==a&&Infinity!==g&&y&&(c=Math.ceil(y/e));return F(c*e)};a?(d=!c.staggerLines&&!c.step&&(H(p)?[p]:g<l(c.autoRotationLimit,80)&&c.autoRotation))&&d.forEach(function(a){if(a===
p||a&&-90<=a&&90>=a){u=f(Math.abs(m.h/Math.sin(R*a)));var c=u+Math.abs(a/360);c<v&&(v=c,h=a,b=u)}}):c.step||(b=f(m.h));this.autoRotation=d;this.labelRotation=l(h,p);return b};B.prototype.getSlotWidth=function(c){var a,e=this.chart,b=this.horiz,l=this.options.labels,h=Math.max(this.tickPositions.length-(this.categories?0:1),1),p=e.margin[3];if(c&&g(c.slotWidth))return c.slotWidth;if(b&&l&&2>(l.step||0))return l.rotation?0:(this.staggerLines||1)*this.len/h;if(!b){c=null===(a=null===l||void 0===l?void 0:
l.style)||void 0===a?void 0:a.width;if(void 0!==c)return parseInt(c,10);if(p)return p-e.spacing[3]}return.33*e.chartWidth};B.prototype.renderUnsquish=function(){var c=this.chart,a=c.renderer,e=this.tickPositions,b=this.ticks,l=this.options.labels,g=l&&l.style||{},h=this.horiz,p=this.getSlotWidth(),m=Math.max(1,Math.round(p-2*(l.padding||5))),u={},d=this.labelMetrics(),y=l.style&&l.style.textOverflow,f=0;v(l.rotation)||(u.rotation=l.rotation||0);e.forEach(function(a){a=b[a];a.movedLabel&&a.replaceMovedLabel();
a&&a.label&&a.label.textPxLength>f&&(f=a.label.textPxLength)});this.maxLabelLength=f;if(this.autoRotation)f>m&&f>d.h?u.rotation=this.labelRotation:this.labelRotation=0;else if(p){var n=m;if(!y){var I="clip";for(m=e.length;!h&&m--;){var G=e[m];if(G=b[G].label)G.styles&&"ellipsis"===G.styles.textOverflow?G.css({textOverflow:"clip"}):G.textPxLength>p&&G.css({width:p+"px"}),G.getBBox().height>this.len/e.length-(d.h-d.f)&&(G.specificTextOverflow="ellipsis")}}}u.rotation&&(n=f>.5*c.chartHeight?.33*c.chartHeight:
f,y||(I="ellipsis"));if(this.labelAlign=l.align||this.autoLabelAlign(this.labelRotation))u.align=this.labelAlign;e.forEach(function(a){var c=(a=b[a])&&a.label,e=g.width,k={};c&&(c.attr(u),a.shortenLabel?a.shortenLabel():n&&!e&&"nowrap"!==g.whiteSpace&&(n<c.textPxLength||"SPAN"===c.element.tagName)?(k.width=n+"px",y||(k.textOverflow=c.specificTextOverflow||I),c.css(k)):c.styles&&c.styles.width&&!k.width&&!e&&c.css({width:null}),delete c.specificTextOverflow,a.rotation=u.rotation)},this);this.tickRotCorr=
a.rotCorr(d.b,this.labelRotation||0,0!==this.side)};B.prototype.hasData=function(){return this.series.some(function(c){return c.hasData()})||this.options.showEmpty&&H(this.min)&&H(this.max)};B.prototype.addTitle=function(c){var a=this.chart.renderer,e=this.horiz,b=this.opposite,l=this.options.title,g,p=this.chart.styledMode;this.axisTitle||((g=l.textAlign)||(g=(e?{low:"left",middle:"center",high:"right"}:{low:b?"right":"left",middle:"center",high:b?"left":"right"})[l.align]),this.axisTitle=a.text(l.text,
0,0,l.useHTML).attr({zIndex:7,rotation:l.rotation||0,align:g}).addClass("highcharts-axis-title"),p||this.axisTitle.css(h(l.style)),this.axisTitle.add(this.axisGroup),this.axisTitle.isNew=!0);p||l.style.width||this.isRadial||this.axisTitle.css({width:this.len+"px"});this.axisTitle[c?"show":"hide"](c)};B.prototype.generateTick=function(c){var a=this.ticks;a[c]?a[c].addLabel():a[c]=new E(this,c)};B.prototype.getOffset=function(){var c=this,a=c.chart,e=a.renderer,b=c.options,g=c.tickPositions,h=c.ticks,
m=c.horiz,u=c.side,v=a.inverted&&!c.isZAxis?[1,0,3,2][u]:u,d,y=0,f=0,O=b.title,I=b.labels,G=0,t=a.axisOffset;a=a.clipOffset;var B=[-1,1,1,-1][u],w=b.className,S=c.axisParent;var R=c.hasData();c.showAxis=d=R||l(b.showEmpty,!0);c.staggerLines=c.horiz&&I.staggerLines;c.axisGroup||(c.gridGroup=e.g("grid").attr({zIndex:b.gridZIndex||1}).addClass("highcharts-"+this.coll.toLowerCase()+"-grid "+(w||"")).add(S),c.axisGroup=e.g("axis").attr({zIndex:b.zIndex||2}).addClass("highcharts-"+this.coll.toLowerCase()+
" "+(w||"")).add(S),c.labelGroup=e.g("axis-labels").attr({zIndex:I.zIndex||7}).addClass("highcharts-"+c.coll.toLowerCase()+"-labels "+(w||"")).add(S));R||c.isLinked?(g.forEach(function(a,e){c.generateTick(a,e)}),c.renderUnsquish(),c.reserveSpaceDefault=0===u||2===u||{1:"left",3:"right"}[u]===c.labelAlign,l(I.reserveSpace,"center"===c.labelAlign?!0:null,c.reserveSpaceDefault)&&g.forEach(function(a){G=Math.max(h[a].getLabelSize(),G)}),c.staggerLines&&(G*=c.staggerLines),c.labelOffset=G*(c.opposite?
-1:1)):p(h,function(a,c){a.destroy();delete h[c]});if(O&&O.text&&!1!==O.enabled&&(c.addTitle(d),d&&!1!==O.reserveSpace)){c.titleOffset=y=c.axisTitle.getBBox()[m?"height":"width"];var x=O.offset;f=H(x)?0:l(O.margin,m?5:10)}c.renderLine();c.offset=B*l(b.offset,t[u]?t[u]+(b.margin||0):0);c.tickRotCorr=c.tickRotCorr||{x:0,y:0};e=0===u?-c.labelMetrics().h:2===u?c.tickRotCorr.y:0;f=Math.abs(G)+f;G&&(f=f-e+B*(m?l(I.y,c.tickRotCorr.y+8*B):I.x));c.axisTitleMargin=l(x,f);c.getMaxLabelDimensions&&(c.maxLabelDimensions=
c.getMaxLabelDimensions(h,g));m=this.tickSize("tick");t[u]=Math.max(t[u],c.axisTitleMargin+y+B*c.offset,f,g&&g.length&&m?m[0]+B*c.offset:0);b=b.offset?0:2*Math.floor(c.axisLine.strokeWidth()/2);a[v]=Math.max(a[v],b);n(this,"afterGetOffset")};B.prototype.getLinePath=function(c){var a=this.chart,e=this.opposite,b=this.offset,l=this.horiz,g=this.left+(e?this.width:0)+b;b=a.chartHeight-this.bottom-(e?this.height:0)+b;e&&(c*=-1);return a.renderer.crispLine([["M",l?this.left:g,l?b:this.top],["L",l?a.chartWidth-
this.right:g,l?b:a.chartHeight-this.bottom]],c)};B.prototype.renderLine=function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.chart.styledMode||this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}))};B.prototype.getTitlePosition=function(){var c=this.horiz,a=this.left,e=this.top,b=this.len,l=this.options.title,g=c?a:e,h=this.opposite,p=this.offset,m=l.x||0,u=l.y||0,d=this.axisTitle,
v=this.chart.renderer.fontMetrics(l.style&&l.style.fontSize,d);d=Math.max(d.getBBox(null,0).height-v.h-1,0);b={low:g+(c?0:b),middle:g+b/2,high:g+(c?b:0)}[l.align];a=(c?e+this.height:a)+(c?1:-1)*(h?-1:1)*this.axisTitleMargin+[-d,d,v.f,-d][this.side];c={x:c?b+m:a+(h?this.width:0)+p+m,y:c?a+u-(h?this.height:0)+p:b+u};n(this,"afterGetTitlePosition",{titlePosition:c});return c};B.prototype.renderMinorTick=function(c){var a=this.chart.hasRendered&&g(this.oldMin),e=this.minorTicks;e[c]||(e[c]=new E(this,
c,"minor"));a&&e[c].isNew&&e[c].render(null,!0);e[c].render(null,!1,1)};B.prototype.renderTick=function(c,a){var e=this.isLinked,b=this.ticks,l=this.chart.hasRendered&&g(this.oldMin);if(!e||c>=this.min&&c<=this.max)b[c]||(b[c]=new E(this,c)),l&&b[c].isNew&&b[c].render(a,!0,-1),b[c].render(a)};B.prototype.render=function(){var c=this,a=c.chart,e=c.logarithmic,b=c.options,l=c.isLinked,h=c.tickPositions,m=c.axisTitle,u=c.ticks,d=c.minorTicks,v=c.alternateBands,y=b.stackLabels,I=b.alternateGridColor,
O=c.tickmarkOffset,t=c.axisLine,B=c.showAxis,w=K(a.renderer.globalAnimation),S,R;c.labelEdge.length=0;c.overlap=!1;[u,d,v].forEach(function(a){p(a,function(a){a.isActive=!1})});if(c.hasData()||l)c.minorTickInterval&&!c.categories&&c.getMinorTickPositions().forEach(function(a){c.renderMinorTick(a)}),h.length&&(h.forEach(function(a,e){c.renderTick(a,e)}),O&&(0===c.min||c.single)&&(u[-1]||(u[-1]=new E(c,-1,null,!0)),u[-1].render(-1))),I&&h.forEach(function(k,b){R="undefined"!==typeof h[b+1]?h[b+1]+O:
c.max-O;0===b%2&&k<c.max&&R<=c.max+(a.polar?-O:O)&&(v[k]||(v[k]=new f.PlotLineOrBand(c)),S=k+O,v[k].options={from:e?e.lin2log(S):S,to:e?e.lin2log(R):R,color:I},v[k].render(),v[k].isActive=!0)}),c._addedPlotLB||((b.plotLines||[]).concat(b.plotBands||[]).forEach(function(a){c.addPlotBandOrLine(a)}),c._addedPlotLB=!0);[u,d,v].forEach(function(c){var e,k=[],b=w.duration;p(c,function(a,c){a.isActive||(a.render(c,!1,0),a.isActive=!1,k.push(c))});G(function(){for(e=k.length;e--;)c[k[e]]&&!c[k[e]].isActive&&
(c[k[e]].destroy(),delete c[k[e]])},c!==v&&a.hasRendered&&b?b:0)});t&&(t[t.isPlaced?"animate":"attr"]({d:this.getLinePath(t.strokeWidth())}),t.isPlaced=!0,t[B?"show":"hide"](B));m&&B&&(b=c.getTitlePosition(),g(b.y)?(m[m.isNew?"attr":"animate"](b),m.isNew=!1):(m.attr("y",-9999),m.isNew=!0));y&&y.enabled&&c.stacking&&c.stacking.renderStackTotals();c.isDirty=!1;n(this,"afterRender")};B.prototype.redraw=function(){this.visible&&(this.render(),this.plotLinesAndBands.forEach(function(c){c.render()}));this.series.forEach(function(c){c.isDirty=
!0})};B.prototype.getKeepProps=function(){return this.keepProps||B.keepProps};B.prototype.destroy=function(c){var a=this,e=a.plotLinesAndBands,b;n(this,"destroy",{keepEvents:c});c||u(a);[a.ticks,a.minorTicks,a.alternateBands].forEach(function(a){C(a)});if(e)for(c=e.length;c--;)e[c].destroy();"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(c){a[c]&&(a[c]=a[c].destroy())});for(b in a.plotLinesAndBandsGroups)a.plotLinesAndBandsGroups[b]=a.plotLinesAndBandsGroups[b].destroy();
p(a,function(c,e){-1===a.getKeepProps().indexOf(e)&&delete a[e]})};B.prototype.drawCrosshair=function(c,a){var e=this.crosshair,b=l(e.snap,!0),g,h=this.cross,p=this.chart;n(this,"drawCrosshair",{e:c,point:a});c||(c=this.cross&&this.cross.e);if(this.crosshair&&!1!==(H(a)||!b)){b?H(a)&&(g=l("colorAxis"!==this.coll?a.crosshairPos:null,this.isXAxis?a.plotX:this.len-a.plotY)):g=c&&(this.horiz?c.chartX-this.pos:this.len-c.chartY+this.pos);if(H(g)){var m={value:a&&(this.isXAxis?a.x:l(a.stackY,a.y)),translatedValue:g};
p.polar&&w(m,{isCrosshair:!0,chartX:c&&c.chartX,chartY:c&&c.chartY,point:a});m=this.getPlotLinePath(m)||null}if(!H(m)){this.hideCrosshair();return}b=this.categories&&!this.isRadial;h||(this.cross=h=p.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(b?"category ":"thin ")+e.className).attr({zIndex:l(e.zIndex,2)}).add(),p.styledMode||(h.attr({stroke:e.color||(b?d.parse("#ccd6eb").setOpacity(.25).get():"#cccccc"),"stroke-width":l(e.width,1)}).css({"pointer-events":"none"}),e.dashStyle&&
h.attr({dashstyle:e.dashStyle})));h.show().attr({d:m});b&&!e.width&&h.attr({"stroke-width":this.transA});this.cross.e=c}else this.hideCrosshair();n(this,"afterDrawCrosshair",{e:c,point:a})};B.prototype.hideCrosshair=function(){this.cross&&this.cross.hide();n(this,"afterHideCrosshair")};B.prototype.hasVerticalPanning=function(){var c,a;return/y/.test((null===(a=null===(c=this.chart.options.chart)||void 0===c?void 0:c.panning)||void 0===a?void 0:a.type)||"")};B.defaultOptions={dateTimeLabelFormats:{millisecond:{main:"%H:%M:%S.%L",
range:!1},second:{main:"%H:%M:%S",range:!1},minute:{main:"%H:%M",range:!1},hour:{main:"%H:%M",range:!1},day:{main:"%e. %b"},week:{main:"%e. %b"},month:{main:"%b '%y"},year:{main:"%Y"}},endOnTick:!1,labels:{enabled:!0,indentation:10,x:0,style:{color:"#666666",cursor:"default",fontSize:"11px"}},maxPadding:.01,minorTickLength:2,minorTickPosition:"outside",minPadding:.01,showEmpty:!0,startOfWeek:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickmarkPlacement:"between",tickPosition:"outside",title:{align:"middle",
style:{color:"#666666"}},type:"linear",minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#ccd6eb",lineWidth:1,gridLineColor:"#e6e6e6",tickColor:"#ccd6eb"};B.defaultYAxisOptions={endOnTick:!0,maxPadding:.05,minPadding:.05,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{allowOverlap:!1,enabled:!1,crop:!0,overflow:"justify",formatter:function(){var c=this.axis.chart.numberFormatter;return c(this.total,
-1)},style:{color:"#000000",fontSize:"11px",fontWeight:"bold",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0};B.defaultLeftAxisOptions={labels:{x:-15},title:{rotation:270}};B.defaultRightAxisOptions={labels:{x:15},title:{rotation:90}};B.defaultBottomAxisOptions={labels:{autoRotation:[-45],x:0},margin:15,title:{rotation:0}};B.defaultTopAxisOptions={labels:{autoRotation:[-45],x:0},margin:15,title:{rotation:0}};B.keepProps="extKey hcEvents names series userMax userMin".split(" ");return B}();
f.Axis=q;return f.Axis});Q(A,"parts/DateTimeAxis.js",[A["parts/Axis.js"],A["parts/Utilities.js"]],function(d,f){var E=f.addEvent,q=f.getMagnitude,M=f.normalizeTickInterval,K=f.timeUnits,J=function(){function d(d){this.axis=d}d.prototype.normalizeTimeTickInterval=function(d,f){var x=f||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];f=x[x.length-1];var C=
K[f[0]],D=f[1],w;for(w=0;w<x.length&&!(f=x[w],C=K[f[0]],D=f[1],x[w+1]&&d<=(C*D[D.length-1]+K[x[w+1][0]])/2);w++);C===K.year&&d<5*C&&(D=[1,2,5]);d=M(d/C,D,"year"===f[0]?Math.max(q(d/C),1):1);return{unitRange:C,count:d,unitName:f[0]}};return d}();f=function(){function d(){}d.compose=function(d){d.keepProps.push("dateTime");d.prototype.getTimeTicks=function(){return this.chart.time.getTimeTicks.apply(this.chart.time,arguments)};E(d,"init",function(d){"datetime"!==d.userOptions.type?this.dateTime=void 0:
this.dateTime||(this.dateTime=new J(this))})};d.AdditionsClass=J;return d}();f.compose(d);return f});Q(A,"parts/LogarithmicAxis.js",[A["parts/Axis.js"],A["parts/Utilities.js"]],function(d,f){var E=f.addEvent,q=f.getMagnitude,M=f.normalizeTickInterval,K=f.pick,J=function(){function d(d){this.axis=d}d.prototype.getLogTickPositions=function(d,f,H,C){var x=this.axis,w=x.len,n=x.options,t=[];C||(this.minorAutoInterval=void 0);if(.5<=d)d=Math.round(d),t=x.getLinearTickPositions(d,f,H);else if(.08<=d){n=
Math.floor(f);var N,m;for(w=.3<d?[1,2,4]:.15<d?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];n<H+1&&!m;n++){var b=w.length;for(N=0;N<b&&!m;N++){var g=this.log2lin(this.lin2log(n)*w[N]);g>f&&(!C||v<=H)&&"undefined"!==typeof v&&t.push(v);v>H&&(m=!0);var v=g}}}else f=this.lin2log(f),H=this.lin2log(H),d=C?x.getMinorTickInterval():n.tickInterval,d=K("auto"===d?null:d,this.minorAutoInterval,n.tickPixelInterval/(C?5:1)*(H-f)/((C?w/x.tickPositions.length:w)||1)),d=M(d,void 0,q(d)),t=x.getLinearTickPositions(d,f,H).map(this.log2lin),
C||(this.minorAutoInterval=d/5);C||(x.tickInterval=d);return t};d.prototype.lin2log=function(d){return Math.pow(10,d)};d.prototype.log2lin=function(d){return Math.log(d)/Math.LN10};return d}();f=function(){function d(){}d.compose=function(d){d.keepProps.push("logarithmic");var f=d.prototype,x=J.prototype;f.log2lin=x.log2lin;f.lin2log=x.lin2log;E(d,"init",function(d){var f=this.logarithmic;"logarithmic"!==d.userOptions.type?this.logarithmic=void 0:(f||(f=this.logarithmic=new J(this)),this.log2lin!==
f.log2lin&&(f.log2lin=this.log2lin.bind(this)),this.lin2log!==f.lin2log&&(f.lin2log=this.lin2log.bind(this)))});E(d,"afterInit",function(){var d=this.logarithmic;d&&(this.lin2val=function(f){return d.lin2log(f)},this.val2lin=function(f){return d.log2lin(f)})})};return d}();f.compose(d);return f});Q(A,"parts/PlotLineOrBand.js",[A["parts/Globals.js"],A["parts/Axis.js"],A["parts/Utilities.js"]],function(d,f,E){var q=E.arrayMax,M=E.arrayMin,K=E.defined,J=E.destroyObjectProperties,L=E.erase,x=E.extend,
F=E.merge,H=E.objectEach,C=E.pick,D=function(){function f(d,f){this.axis=d;f&&(this.options=f,this.id=f.id)}f.prototype.render=function(){d.fireEvent(this,"render");var f=this,t=f.axis,w=t.horiz,m=t.logarithmic,b=f.options,g=b.label,v=f.label,h=b.to,e=b.from,p=b.value,l=K(e)&&K(h),I=K(p),u=f.svgElem,y=!u,G=[],S=b.color,R=C(b.zIndex,0),B=b.events;G={"class":"highcharts-plot-"+(l?"band ":"line ")+(b.className||"")};var c={},a=t.chart.renderer,k=l?"bands":"lines";m&&(e=m.log2lin(e),h=m.log2lin(h),p=
m.log2lin(p));t.chart.styledMode||(I?(G.stroke=S||"#999999",G["stroke-width"]=C(b.width,1),b.dashStyle&&(G.dashstyle=b.dashStyle)):l&&(G.fill=S||"#e6ebf5",b.borderWidth&&(G.stroke=b.borderColor,G["stroke-width"]=b.borderWidth)));c.zIndex=R;k+="-"+R;(m=t.plotLinesAndBandsGroups[k])||(t.plotLinesAndBandsGroups[k]=m=a.g("plot-"+k).attr(c).add());y&&(f.svgElem=u=a.path().attr(G).add(m));if(I)G=t.getPlotLinePath({value:p,lineWidth:u.strokeWidth(),acrossPanes:b.acrossPanes});else if(l)G=t.getPlotBandPath(e,
h,b);else return;(y||!u.d)&&G&&G.length?(u.attr({d:G}),B&&H(B,function(a,c){u.on(c,function(a){B[c].apply(f,[a])})})):u&&(G?(u.show(!0),u.animate({d:G})):u.d&&(u.hide(),v&&(f.label=v=v.destroy())));g&&(K(g.text)||K(g.formatter))&&G&&G.length&&0<t.width&&0<t.height&&!G.isFlat?(g=F({align:w&&l&&"center",x:w?!l&&4:10,verticalAlign:!w&&l&&"middle",y:w?l?16:10:l?6:-4,rotation:w&&!l&&90},g),this.renderLabel(g,G,l,R)):v&&v.hide();return f};f.prototype.renderLabel=function(d,f,w,m){var b=this.label,g=this.axis.chart.renderer;
b||(b={align:d.textAlign||d.align,rotation:d.rotation,"class":"highcharts-plot-"+(w?"band":"line")+"-label "+(d.className||"")},b.zIndex=m,m=this.getLabelText(d),this.label=b=g.text(m,0,0,d.useHTML).attr(b).add(),this.axis.chart.styledMode||b.css(d.style));g=f.xBounds||[f[0][1],f[1][1],w?f[2][1]:f[0][1]];f=f.yBounds||[f[0][2],f[1][2],w?f[2][2]:f[0][2]];w=M(g);m=M(f);b.align(d,!1,{x:w,y:m,width:q(g)-w,height:q(f)-m});b.show(!0)};f.prototype.getLabelText=function(d){return K(d.formatter)?d.formatter.call(this):
d.text};f.prototype.destroy=function(){L(this.axis.plotLinesAndBands,this);delete this.axis;J(this)};return f}();x(f.prototype,{getPlotBandPath:function(d,f){var n=this.getPlotLinePath({value:f,force:!0,acrossPanes:this.options.acrossPanes}),w=this.getPlotLinePath({value:d,force:!0,acrossPanes:this.options.acrossPanes}),m=[],b=this.horiz,g=1;d=d<this.min&&f<this.min||d>this.max&&f>this.max;if(w&&n){if(d){var v=w.toString()===n.toString();g=0}for(d=0;d<w.length;d+=2){f=w[d];var h=w[d+1],e=n[d],p=n[d+
1];"M"!==f[0]&&"L"!==f[0]||"M"!==h[0]&&"L"!==h[0]||"M"!==e[0]&&"L"!==e[0]||"M"!==p[0]&&"L"!==p[0]||(b&&e[1]===f[1]?(e[1]+=g,p[1]+=g):b||e[2]!==f[2]||(e[2]+=g,p[2]+=g),m.push(["M",f[1],f[2]],["L",h[1],h[2]],["L",p[1],p[2]],["L",e[1],e[2]],["Z"]));m.isFlat=v}}return m},addPlotBand:function(d){return this.addPlotBandOrLine(d,"plotBands")},addPlotLine:function(d){return this.addPlotBandOrLine(d,"plotLines")},addPlotBandOrLine:function(d,f){var n=(new D(this,d)).render(),w=this.userOptions;if(n){if(f){var m=
w[f]||[];m.push(d);w[f]=m}this.plotLinesAndBands.push(n)}return n},removePlotBandOrLine:function(d){for(var f=this.plotLinesAndBands,t=this.options,w=this.userOptions,m=f.length;m--;)f[m].id===d&&f[m].destroy();[t.plotLines||[],w.plotLines||[],t.plotBands||[],w.plotBands||[]].forEach(function(b){for(m=b.length;m--;)(b[m]||{}).id===d&&L(b,b[m])})},removePlotBand:function(d){this.removePlotBandOrLine(d)},removePlotLine:function(d){this.removePlotBandOrLine(d)}});d.PlotLineOrBand=D;return d.PlotLineOrBand});
Q(A,"parts/Tooltip.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.clamp,q=f.css,M=f.defined,K=f.discardElement,J=f.extend,L=f.fireEvent,x=f.format,F=f.isNumber,H=f.isString,C=f.merge,D=f.pick,w=f.splat,n=f.syncTimeout,t=f.timeUnits;"";var N=d.doc,m=function(){function b(b,d){this.crosshairs=[];this.distance=0;this.isHidden=!0;this.isSticky=!1;this.now={};this.options={};this.outside=!1;this.chart=b;this.init(b,d)}b.prototype.applyFilter=function(){var b=this.chart;b.renderer.definition({tagName:"filter",
id:"drop-shadow-"+b.index,opacity:.5,children:[{tagName:"feGaussianBlur","in":"SourceAlpha",stdDeviation:1},{tagName:"feOffset",dx:1,dy:1},{tagName:"feComponentTransfer",children:[{tagName:"feFuncA",type:"linear",slope:.3}]},{tagName:"feMerge",children:[{tagName:"feMergeNode"},{tagName:"feMergeNode","in":"SourceGraphic"}]}]});b.renderer.definition({tagName:"style",textContent:".highcharts-tooltip-"+b.index+"{filter:url(#drop-shadow-"+b.index+")}"})};b.prototype.bodyFormatter=function(b){return b.map(function(b){var g=
b.series.tooltipOptions;return(g[(b.point.formatPrefix||"point")+"Formatter"]||b.point.tooltipFormatter).call(b.point,g[(b.point.formatPrefix||"point")+"Format"]||"")})};b.prototype.cleanSplit=function(b){this.chart.series.forEach(function(g){var h=g&&g.tt;h&&(!h.isActive||b?g.tt=h.destroy():h.isActive=!1)})};b.prototype.defaultFormatter=function(b){var g=this.points||w(this);var h=[b.tooltipFooterHeaderFormatter(g[0])];h=h.concat(b.bodyFormatter(g));h.push(b.tooltipFooterHeaderFormatter(g[0],!0));
return h};b.prototype.destroy=function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());this.renderer&&(this.renderer=this.renderer.destroy(),K(this.container));f.clearTimeout(this.hideTimer);f.clearTimeout(this.tooltipTimeout)};b.prototype.getAnchor=function(b,d){var g=this.chart,e=g.pointer,p=g.inverted,l=g.plotTop,m=g.plotLeft,u=0,f=0,v,n;b=w(b);this.followPointer&&d?("undefined"===typeof d.chartX&&(d=e.normalize(d)),
b=[d.chartX-m,d.chartY-l]):b[0].tooltipPos?b=b[0].tooltipPos:(b.forEach(function(e){v=e.series.yAxis;n=e.series.xAxis;u+=e.plotX+(!p&&n?n.left-m:0);f+=(e.plotLow?(e.plotLow+e.plotHigh)/2:e.plotY)+(!p&&v?v.top-l:0)}),u/=b.length,f/=b.length,b=[p?g.plotWidth-f:u,this.shared&&!p&&1<b.length&&d?d.chartY-l:p?g.plotHeight-u:f]);return b.map(Math.round)};b.prototype.getDateFormat=function(b,d,h,e){var g=this.chart.time,l=g.dateFormat("%m-%d %H:%M:%S.%L",d),m={millisecond:15,second:12,minute:9,hour:6,day:3},
u="millisecond";for(f in t){if(b===t.week&&+g.dateFormat("%w",d)===h&&"00:00:00.000"===l.substr(6)){var f="week";break}if(t[f]>b){f=u;break}if(m[f]&&l.substr(m[f])!=="01-01 00:00:00.000".substr(m[f]))break;"week"!==f&&(u=f)}if(f)var v=g.resolveDTLFormat(e[f]).main;return v};b.prototype.getLabel=function(){var b,m,h=this,e=this.chart.renderer,p=this.chart.styledMode,l=this.options,f="tooltip"+(M(l.className)?" "+l.className:""),u=(null===(b=l.style)||void 0===b?void 0:b.pointerEvents)||(!this.followPointer&&
l.stickOnContact?"auto":"none"),y;b=function(){h.inContact=!0};var G=function(){var e=h.chart.hoverSeries;h.inContact=!1;if(e&&e.onMouseOut)e.onMouseOut()};if(!this.label){this.outside&&(this.container=y=d.doc.createElement("div"),y.className="highcharts-tooltip-container",q(y,{position:"absolute",top:"1px",pointerEvents:u,zIndex:3}),d.doc.body.appendChild(y),this.renderer=e=new d.Renderer(y,0,0,null===(m=this.chart.options.chart)||void 0===m?void 0:m.style,void 0,void 0,e.styledMode));this.split?
this.label=e.g(f):(this.label=e.label("",0,0,l.shape||"callout",null,null,l.useHTML,null,f).attr({padding:l.padding,r:l.borderRadius}),p||this.label.attr({fill:l.backgroundColor,"stroke-width":l.borderWidth}).css(l.style).css({pointerEvents:u}).shadow(l.shadow));p&&(this.applyFilter(),this.label.addClass("highcharts-tooltip-"+this.chart.index));if(h.outside&&!h.split){var n={x:this.label.xSetter,y:this.label.ySetter};this.label.xSetter=function(e,b){n[b].call(this.label,h.distance);y.style.left=e+
"px"};this.label.ySetter=function(e,b){n[b].call(this.label,h.distance);y.style.top=e+"px"}}this.label.on("mouseenter",b).on("mouseleave",G).attr({zIndex:8}).add()}return this.label};b.prototype.getPosition=function(b,d,h){var e=this.chart,g=this.distance,l={},m=e.inverted&&h.h||0,u,f=this.outside,v=f?N.documentElement.clientWidth-2*g:e.chartWidth,n=f?Math.max(N.body.scrollHeight,N.documentElement.scrollHeight,N.body.offsetHeight,N.documentElement.offsetHeight,N.documentElement.clientHeight):e.chartHeight,
t=e.pointer.getChartPosition(),B=e.containerScaling,c=function(a){return B?a*B.scaleX:a},a=function(a){return B?a*B.scaleY:a},k=function(k){var l="x"===k;return[k,l?v:n,l?b:d].concat(f?[l?c(b):a(d),l?t.left-g+c(h.plotX+e.plotLeft):t.top-g+a(h.plotY+e.plotTop),0,l?v:n]:[l?b:d,l?h.plotX+e.plotLeft:h.plotY+e.plotTop,l?e.plotLeft:e.plotTop,l?e.plotLeft+e.plotWidth:e.plotTop+e.plotHeight])},r=k("y"),z=k("x"),w=!this.followPointer&&D(h.ttBelow,!e.inverted===!!h.negative),x=function(e,b,k,h,p,r,d){var u=
"y"===e?a(g):c(g),f=(k-h)/2,v=h<p-g,y=p+g+h<b,z=p-u-k+f;p=p+u-f;if(w&&y)l[e]=p;else if(!w&&v)l[e]=z;else if(v)l[e]=Math.min(d-h,0>z-m?z:z-m);else if(y)l[e]=Math.max(r,p+m+k>b?p:p+m);else return!1},C=function(a,c,e,b,k){var h;k<g||k>c-g?h=!1:l[a]=k<e/2?1:k>c-b/2?c-b-2:k-e/2;return h},q=function(a){var c=r;r=z;z=c;u=a},T=function(){!1!==x.apply(0,r)?!1!==C.apply(0,z)||u||(q(!0),T()):u?l.x=l.y=0:(q(!0),T())};(e.inverted||1<this.len)&&q();T();return l};b.prototype.getXDateFormat=function(b,d,h){d=d.dateTimeLabelFormats;
var e=h&&h.closestPointRange;return(e?this.getDateFormat(e,b.x,h.options.startOfWeek,d):d.day)||d.year};b.prototype.hide=function(b){var g=this;f.clearTimeout(this.hideTimer);b=D(b,this.options.hideDelay,500);this.isHidden||(this.hideTimer=n(function(){g.getLabel().fadeOut(b?void 0:b);g.isHidden=!0},b))};b.prototype.init=function(b,d){this.chart=b;this.options=d;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.split=d.split&&!b.inverted&&!b.polar;this.shared=d.shared||this.split;this.outside=
D(d.outside,!(!b.scrollablePixelsX&&!b.scrollablePixelsY))};b.prototype.isStickyOnContact=function(){return!(this.followPointer||!this.options.stickOnContact||!this.inContact)};b.prototype.move=function(b,d,h,e){var g=this,l=g.now,m=!1!==g.options.animation&&!g.isHidden&&(1<Math.abs(b-l.x)||1<Math.abs(d-l.y)),u=g.followPointer||1<g.len;J(l,{x:m?(2*l.x+b)/3:b,y:m?(l.y+d)/2:d,anchorX:u?void 0:m?(2*l.anchorX+h)/3:h,anchorY:u?void 0:m?(l.anchorY+e)/2:e});g.getLabel().attr(l);g.drawTracker();m&&(f.clearTimeout(this.tooltipTimeout),
this.tooltipTimeout=setTimeout(function(){g&&g.move(b,d,h,e)},32))};b.prototype.refresh=function(b,d){var h=this.chart,e=this.options,g=b,l={},m=[],u=e.formatter||this.defaultFormatter;l=this.shared;var v=h.styledMode;if(e.enabled){f.clearTimeout(this.hideTimer);this.followPointer=w(g)[0].series.tooltipOptions.followPointer;var n=this.getAnchor(g,d);d=n[0];var t=n[1];!l||g.series&&g.series.noSharedTooltip?l=g.getLabelConfig():(h.pointer.applyInactiveState(g),g.forEach(function(e){e.setState("hover");
m.push(e.getLabelConfig())}),l={x:g[0].category,y:g[0].y},l.points=m,g=g[0]);this.len=m.length;h=u.call(l,this);u=g.series;this.distance=D(u.tooltipOptions.distance,16);!1===h?this.hide():(this.split?this.renderSplit(h,w(b)):(b=this.getLabel(),e.style.width&&!v||b.css({width:this.chart.spacingBox.width+"px"}),b.attr({text:h&&h.join?h.join(""):h}),b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+D(g.colorIndex,u.colorIndex)),v||b.attr({stroke:e.borderColor||g.color||u.color||"#666666"}),
this.updatePosition({plotX:d,plotY:t,negative:g.negative,ttBelow:g.ttBelow,h:n[2]||0})),this.isHidden&&this.label&&this.label.attr({opacity:1}).show(),this.isHidden=!1);L(this,"refresh")}};b.prototype.renderSplit=function(b,m){function g(a,c,e,b,k){void 0===k&&(k=!0);e?(c=C?0:F,a=E(a-b/2,x.left,x.right-b)):(c-=T,a=k?a-b-r:a+r,a=E(a,k?a:x.left,x.right));return{x:a,y:c}}var e=this,p=e.chart,l=e.chart,f=l.plotHeight,u=l.plotLeft,v=l.plotTop,n=l.pointer,t=l.renderer,w=l.scrollablePixelsY,B=void 0===w?
0:w;w=l.scrollingContainer;w=void 0===w?{scrollLeft:0,scrollTop:0}:w;var c=w.scrollLeft,a=w.scrollTop,k=l.styledMode,r=e.distance,z=e.options,P=e.options.positioner,x={left:c,right:c+l.chartWidth,top:a,bottom:a+l.chartHeight},q=e.getLabel(),C=!(!p.xAxis[0]||!p.xAxis[0].opposite),T=v+a,N=0,F=f-B;H(b)&&(b=[!1,b]);b=b.slice(0,m.length+1).reduce(function(c,b,l){if(!1!==b&&""!==b){l=m[l-1]||{isHeader:!0,plotX:m[0].plotX,plotY:f,series:{}};var h=l.isHeader,d=h?e:l.series,p=d.tt,y=l.isHeader;var n=l.series;
var G="highcharts-color-"+D(l.colorIndex,n.colorIndex,"none");p||(p={padding:z.padding,r:z.borderRadius},k||(p.fill=z.backgroundColor,p["stroke-width"]=z.borderWidth),p=t.label("",0,0,z[y?"headerShape":"shape"]||"callout",void 0,void 0,z.useHTML).addClass((y?"highcharts-tooltip-header ":"")+"highcharts-tooltip-box "+G).attr(p).add(q));p.isActive=!0;p.attr({text:b});k||p.css(z.style).shadow(z.shadow).attr({stroke:z.borderColor||l.color||n.color||"#333333"});b=d.tt=p;y=b.getBBox();d=y.width+b.strokeWidth();
h&&(N=y.height,F+=N,C&&(T-=N));n=l.plotX;n=void 0===n?0:n;G=l.plotY;G=void 0===G?0:G;var O=l.series;if(l.isHeader){n=u+n;var I=v+f/2}else p=O.xAxis,O=O.yAxis,n=p.pos+E(n,-r,p.len+r),O.pos+G>=a+v&&O.pos+G<=a+v+f-B&&(I=O.pos+G);n=E(n,x.left-r,x.right+r);"number"===typeof I?(y=y.height+1,G=P?P.call(e,d,y,l):g(n,I,h,d),c.push({align:P?0:void 0,anchorX:n,anchorY:I,boxWidth:d,point:l,rank:D(G.rank,h?1:0),size:y,target:G.y,tt:b,x:G.x})):b.isActive=!1}return c},[]);!P&&b.some(function(a){return a.x<x.left})&&
(b=b.map(function(a){var c=g(a.anchorX,a.anchorY,a.point.isHeader,a.boxWidth,!1);return J(a,{target:c.y,x:c.x})}));e.cleanSplit();d.distribute(b,F);b.forEach(function(a){var c=a.pos;a.tt.attr({visibility:"undefined"===typeof c?"hidden":"inherit",x:a.x,y:c+T,anchorX:a.anchorX,anchorY:a.anchorY})});b=e.container;p=e.renderer;e.outside&&b&&p&&(l=q.getBBox(),p.setSize(l.width+l.x,l.height+l.y,!1),n=n.getChartPosition(),b.style.left=n.left+"px",b.style.top=n.top+"px")};b.prototype.drawTracker=function(){if(this.followPointer||
!this.options.stickOnContact)this.tracker&&this.tracker.destroy();else{var b=this.chart,d=this.label,h=b.hoverPoint;if(d&&h){var e={x:0,y:0,width:0,height:0};h=this.getAnchor(h);var p=d.getBBox();h[0]+=b.plotLeft-d.translateX;h[1]+=b.plotTop-d.translateY;e.x=Math.min(0,h[0]);e.y=Math.min(0,h[1]);e.width=0>h[0]?Math.max(Math.abs(h[0]),p.width-h[0]):Math.max(Math.abs(h[0]),p.width);e.height=0>h[1]?Math.max(Math.abs(h[1]),p.height-Math.abs(h[1])):Math.max(Math.abs(h[1]),p.height);this.tracker?this.tracker.attr(e):
(this.tracker=d.renderer.rect(e).addClass("highcharts-tracker").add(d),b.styledMode||this.tracker.attr({fill:"rgba(0,0,0,0)"}))}}};b.prototype.styledModeFormat=function(b){return b.replace('style="font-size: 10px"','class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,'class="highcharts-color-{$1.colorIndex}"')};b.prototype.tooltipFooterHeaderFormatter=function(b,d){var h=d?"footer":"header",e=b.series,g=e.tooltipOptions,l=g.xDateFormat,m=e.xAxis,u=m&&"datetime"===m.options.type&&
F(b.key),f=g[h+"Format"];d={isFooter:d,labelConfig:b};L(this,"headerFormatter",d,function(h){u&&!l&&(l=this.getXDateFormat(b,g,m));u&&l&&(b.point&&b.point.tooltipDateKeys||["key"]).forEach(function(e){f=f.replace("{point."+e+"}","{point."+e+":"+l+"}")});e.chart.styledMode&&(f=this.styledModeFormat(f));h.text=x(f,{point:b,series:e},this.chart)});return d.text};b.prototype.update=function(b){this.destroy();C(!0,this.chart.options.tooltip.userOptions,b);this.init(this.chart,C(!0,this.options,b))};b.prototype.updatePosition=
function(b){var g=this.chart,h=g.pointer,e=this.getLabel(),d=b.plotX+g.plotLeft,l=b.plotY+g.plotTop;h=h.getChartPosition();b=(this.options.positioner||this.getPosition).call(this,e.width,e.height,b);if(this.outside){var m=(this.options.borderWidth||0)+2*this.distance;this.renderer.setSize(e.width+m,e.height+m,!1);if(g=g.containerScaling)q(this.container,{transform:"scale("+g.scaleX+", "+g.scaleY+")"}),d*=g.scaleX,l*=g.scaleY;d+=h.left-b.x;l+=h.top-b.y}this.move(Math.round(b.x),Math.round(b.y||0),
d,l)};return b}();d.Tooltip=m;return d.Tooltip});Q(A,"parts/Pointer.js",[A["parts/Globals.js"],A["parts/Utilities.js"],A["parts/Tooltip.js"],A["parts/Color.js"]],function(d,f,E,q){var M=f.addEvent,K=f.attr,J=f.css,L=f.defined,x=f.extend,F=f.find,H=f.fireEvent,C=f.isNumber,D=f.isObject,w=f.objectEach,n=f.offset,t=f.pick,N=f.splat,m=q.parse,b=d.charts,g=d.noop;f=function(){function f(b,e){this.lastValidTouch={};this.pinchDown=[];this.runChartClick=!1;this.chart=b;this.hasDragged=!1;this.options=e;this.unbindContainerMouseLeave=
function(){};this.init(b,e)}f.prototype.applyInactiveState=function(b){var e=[],h;(b||[]).forEach(function(b){h=b.series;e.push(h);h.linkedParent&&e.push(h.linkedParent);h.linkedSeries&&(e=e.concat(h.linkedSeries));h.navigatorSeries&&e.push(h.navigatorSeries)});this.chart.series.forEach(function(b){-1===e.indexOf(b)?b.setState("inactive",!0):b.options.inactiveOtherPoints&&b.setAllPointsToState("inactive")})};f.prototype.destroy=function(){var b=this;"undefined"!==typeof b.unDocMouseMove&&b.unDocMouseMove();
this.unbindContainerMouseLeave();d.chartCount||(d.unbindDocumentMouseUp&&(d.unbindDocumentMouseUp=d.unbindDocumentMouseUp()),d.unbindDocumentTouchEnd&&(d.unbindDocumentTouchEnd=d.unbindDocumentTouchEnd()));clearInterval(b.tooltipTimeout);w(b,function(e,h){b[h]=null})};f.prototype.drag=function(b){var e=this.chart,h=e.options.chart,l=b.chartX,g=b.chartY,d=this.zoomHor,f=this.zoomVert,v=e.plotLeft,n=e.plotTop,t=e.plotWidth,B=e.plotHeight,c=this.selectionMarker,a=this.mouseDownX||0,k=this.mouseDownY||
0,r=D(h.panning)?h.panning&&h.panning.enabled:h.panning,z=h.panKey&&b[h.panKey+"Key"];if(!c||!c.touch)if(l<v?l=v:l>v+t&&(l=v+t),g<n?g=n:g>n+B&&(g=n+B),this.hasDragged=Math.sqrt(Math.pow(a-l,2)+Math.pow(k-g,2)),10<this.hasDragged){var w=e.isInsidePlot(a-v,k-n);e.hasCartesianSeries&&(this.zoomX||this.zoomY)&&w&&!z&&!c&&(this.selectionMarker=c=e.renderer.rect(v,n,d?1:t,f?1:B,0).attr({"class":"highcharts-selection-marker",zIndex:7}).add(),e.styledMode||c.attr({fill:h.selectionMarkerFill||m("#335cad").setOpacity(.25).get()}));
c&&d&&(l-=a,c.attr({width:Math.abs(l),x:(0<l?0:l)+a}));c&&f&&(l=g-k,c.attr({height:Math.abs(l),y:(0<l?0:l)+k}));w&&!c&&r&&e.pan(b,h.panning)}};f.prototype.dragStart=function(b){var e=this.chart;e.mouseIsDown=b.type;e.cancelClick=!1;e.mouseDownX=this.mouseDownX=b.chartX;e.mouseDownY=this.mouseDownY=b.chartY};f.prototype.drop=function(b){var e=this,h=this.chart,l=this.hasPinched;if(this.selectionMarker){var g={originalEvent:b,xAxis:[],yAxis:[]},d=this.selectionMarker,m=d.attr?d.attr("x"):d.x,f=d.attr?
d.attr("y"):d.y,v=d.attr?d.attr("width"):d.width,n=d.attr?d.attr("height"):d.height,B;if(this.hasDragged||l)h.axes.forEach(function(c){if(c.zoomEnabled&&L(c.min)&&(l||e[{xAxis:"zoomX",yAxis:"zoomY"}[c.coll]])){var a=c.horiz,k="touchend"===b.type?c.minPixelPadding:0,h=c.toValue((a?m:f)+k);a=c.toValue((a?m+v:f+n)-k);g[c.coll].push({axis:c,min:Math.min(h,a),max:Math.max(h,a)});B=!0}}),B&&H(h,"selection",g,function(c){h.zoom(x(c,l?{animation:!1}:null))});C(h.index)&&(this.selectionMarker=this.selectionMarker.destroy());
l&&this.scaleGroups()}h&&C(h.index)&&(J(h.container,{cursor:h._cursor}),h.cancelClick=10<this.hasDragged,h.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[])};f.prototype.findNearestKDPoint=function(b,e,g){var l=this.chart,h=l.hoverPoint;l=l.tooltip;if(h&&l&&l.isStickyOnContact())return h;var d;b.forEach(function(b){var l=!(b.noSharedTooltip&&e)&&0>b.options.findNearestPointBy.indexOf("y");b=b.searchPoint(g,l);if((l=D(b,!0))&&!(l=!D(d,!0))){l=d.distX-b.distX;var h=d.dist-b.dist,p=(b.series.group&&
b.series.group.zIndex)-(d.series.group&&d.series.group.zIndex);l=0<(0!==l&&e?l:0!==h?h:0!==p?p:d.series.index>b.series.index?-1:1)}l&&(d=b)});return d};f.prototype.getChartCoordinatesFromPoint=function(b,e){var h=b.series,l=h.xAxis;h=h.yAxis;var g=t(b.clientX,b.plotX),d=b.shapeArgs;if(l&&h)return e?{chartX:l.len+l.pos-g,chartY:h.len+h.pos-b.plotY}:{chartX:g+l.pos,chartY:b.plotY+h.pos};if(d&&d.x&&d.y)return{chartX:d.x,chartY:d.y}};f.prototype.getChartPosition=function(){return this.chartPosition||
(this.chartPosition=n(this.chart.container))};f.prototype.getCoordinates=function(b){var e={xAxis:[],yAxis:[]};this.chart.axes.forEach(function(h){e[h.isXAxis?"xAxis":"yAxis"].push({axis:h,value:h.toValue(b[h.horiz?"chartX":"chartY"])})});return e};f.prototype.getHoverData=function(b,e,g,l,d,m){var h,p=[];l=!(!l||!b);var f=e&&!e.stickyTracking,u={chartX:m?m.chartX:void 0,chartY:m?m.chartY:void 0,shared:d};H(this,"beforeGetHoverData",u);f=f?[e]:g.filter(function(e){return u.filter?u.filter(e):e.visible&&
!(!d&&e.directTouch)&&t(e.options.enableMouseTracking,!0)&&e.stickyTracking});e=(h=l||!m?b:this.findNearestKDPoint(f,d,m))&&h.series;h&&(d&&!e.noSharedTooltip?(f=g.filter(function(e){return u.filter?u.filter(e):e.visible&&!(!d&&e.directTouch)&&t(e.options.enableMouseTracking,!0)&&!e.noSharedTooltip}),f.forEach(function(e){var c=F(e.points,function(a){return a.x===h.x&&!a.isNull});D(c)&&(e.chart.isBoosting&&(c=e.getPoint(c)),p.push(c))})):p.push(h));u={hoverPoint:h};H(this,"afterGetHoverData",u);return{hoverPoint:u.hoverPoint,
hoverSeries:e,hoverPoints:p}};f.prototype.getPointFromEvent=function(b){b=b.target;for(var e;b&&!e;)e=b.point,b=b.parentNode;return e};f.prototype.onTrackerMouseOut=function(b){b=b.relatedTarget||b.toElement;var e=this.chart.hoverSeries;this.isDirectTouch=!1;if(!(!e||!b||e.stickyTracking||this.inClass(b,"highcharts-tooltip")||this.inClass(b,"highcharts-series-"+e.index)&&this.inClass(b,"highcharts-tracker")))e.onMouseOut()};f.prototype.inClass=function(b,e){for(var g;b;){if(g=K(b,"class")){if(-1!==
g.indexOf(e))return!0;if(-1!==g.indexOf("highcharts-container"))return!1}b=b.parentNode}};f.prototype.init=function(b,e){this.options=e;this.chart=b;this.runChartClick=e.chart.events&&!!e.chart.events.click;this.pinchDown=[];this.lastValidTouch={};E&&(b.tooltip=new E(b,e.tooltip),this.followTouchMove=t(e.tooltip.followTouchMove,!0));this.setDOMEvents()};f.prototype.normalize=function(b,e){var g=b.touches,l=g?g.length?g.item(0):g.changedTouches[0]:b;e||(e=this.getChartPosition());g=l.pageX-e.left;
e=l.pageY-e.top;if(l=this.chart.containerScaling)g/=l.scaleX,e/=l.scaleY;return x(b,{chartX:Math.round(g),chartY:Math.round(e)})};f.prototype.onContainerClick=function(b){var e=this.chart,g=e.hoverPoint;b=this.normalize(b);var l=e.plotLeft,h=e.plotTop;e.cancelClick||(g&&this.inClass(b.target,"highcharts-tracker")?(H(g.series,"click",x(b,{point:g})),e.hoverPoint&&g.firePointEvent("click",b)):(x(b,this.getCoordinates(b)),e.isInsidePlot(b.chartX-l,b.chartY-h)&&H(e,"click",b)))};f.prototype.onContainerMouseDown=
function(b){b=this.normalize(b);if(d.isFirefox&&0!==b.button)this.onContainerMouseMove(b);if("undefined"===typeof b.button||1===((b.buttons||b.button)&1))this.zoomOption(b),this.dragStart(b)};f.prototype.onContainerMouseLeave=function(g){var e=b[t(d.hoverChartIndex,-1)],h=this.chart.tooltip;g=this.normalize(g);e&&(g.relatedTarget||g.toElement)&&(e.pointer.reset(),e.pointer.chartPosition=void 0);h&&!h.isHidden&&this.reset()};f.prototype.onContainerMouseMove=function(b){var e=this.chart;b=this.normalize(b);
this.setHoverChartIndex();b.preventDefault||(b.returnValue=!1);"mousedown"===e.mouseIsDown&&this.drag(b);e.openMenu||!this.inClass(b.target,"highcharts-tracker")&&!e.isInsidePlot(b.chartX-e.plotLeft,b.chartY-e.plotTop)||this.runPointActions(b)};f.prototype.onDocumentTouchEnd=function(g){b[d.hoverChartIndex]&&b[d.hoverChartIndex].pointer.drop(g)};f.prototype.onContainerTouchMove=function(b){this.touch(b)};f.prototype.onContainerTouchStart=function(b){this.zoomOption(b);this.touch(b,!0)};f.prototype.onDocumentMouseMove=
function(b){var e=this.chart,g=this.chartPosition;b=this.normalize(b,g);var l=e.tooltip;!g||l&&l.isStickyOnContact()||e.isInsidePlot(b.chartX-e.plotLeft,b.chartY-e.plotTop)||this.inClass(b.target,"highcharts-tracker")||this.reset()};f.prototype.onDocumentMouseUp=function(g){var e=b[t(d.hoverChartIndex,-1)];e&&e.pointer.drop(g)};f.prototype.pinch=function(b){var e=this,h=e.chart,l=e.pinchDown,d=b.touches||[],m=d.length,f=e.lastValidTouch,v=e.hasZoom,n=e.selectionMarker,w={},B=1===m&&(e.inClass(b.target,
"highcharts-tracker")&&h.runTrackerClick||e.runChartClick),c={};1<m&&(e.initiated=!0);v&&e.initiated&&!B&&b.preventDefault();[].map.call(d,function(a){return e.normalize(a)});"touchstart"===b.type?([].forEach.call(d,function(a,c){l[c]={chartX:a.chartX,chartY:a.chartY}}),f.x=[l[0].chartX,l[1]&&l[1].chartX],f.y=[l[0].chartY,l[1]&&l[1].chartY],h.axes.forEach(function(a){if(a.zoomEnabled){var c=h.bounds[a.horiz?"h":"v"],e=a.minPixelPadding,b=a.toPixels(Math.min(t(a.options.min,a.dataMin),a.dataMin)),
l=a.toPixels(Math.max(t(a.options.max,a.dataMax),a.dataMax)),g=Math.max(b,l);c.min=Math.min(a.pos,Math.min(b,l)-e);c.max=Math.max(a.pos+a.len,g+e)}}),e.res=!0):e.followTouchMove&&1===m?this.runPointActions(e.normalize(b)):l.length&&(n||(e.selectionMarker=n=x({destroy:g,touch:!0},h.plotBox)),e.pinchTranslate(l,d,w,n,c,f),e.hasPinched=v,e.scaleGroups(w,c),e.res&&(e.res=!1,this.reset(!1,0)))};f.prototype.pinchTranslate=function(b,e,g,l,d,m){this.zoomHor&&this.pinchTranslateDirection(!0,b,e,g,l,d,m);
this.zoomVert&&this.pinchTranslateDirection(!1,b,e,g,l,d,m)};f.prototype.pinchTranslateDirection=function(b,e,g,l,d,m,f,v){var h=this.chart,p=b?"x":"y",u=b?"X":"Y",c="chart"+u,a=b?"width":"height",k=h["plot"+(b?"Left":"Top")],r,z,y=v||1,n=h.inverted,G=h.bounds[b?"h":"v"],t=1===e.length,w=e[0][c],I=g[0][c],x=!t&&e[1][c],O=!t&&g[1][c];g=function(){"number"===typeof O&&20<Math.abs(w-x)&&(y=v||Math.abs(I-O)/Math.abs(w-x));z=(k-I)/y+w;r=h["plot"+(b?"Width":"Height")]/y};g();e=z;if(e<G.min){e=G.min;var V=
!0}else e+r>G.max&&(e=G.max-r,V=!0);V?(I-=.8*(I-f[p][0]),"number"===typeof O&&(O-=.8*(O-f[p][1])),g()):f[p]=[I,O];n||(m[p]=z-k,m[a]=r);m=n?1/y:y;d[a]=r;d[p]=e;l[n?b?"scaleY":"scaleX":"scale"+u]=y;l["translate"+u]=m*k+(I-m*w)};f.prototype.reset=function(b,e){var g=this.chart,l=g.hoverSeries,d=g.hoverPoint,h=g.hoverPoints,m=g.tooltip,f=m&&m.shared?h:d;b&&f&&N(f).forEach(function(e){e.series.isCartesian&&"undefined"===typeof e.plotX&&(b=!1)});if(b)m&&f&&N(f).length&&(m.refresh(f),m.shared&&h?h.forEach(function(e){e.setState(e.state,
!0);e.series.isCartesian&&(e.series.xAxis.crosshair&&e.series.xAxis.drawCrosshair(null,e),e.series.yAxis.crosshair&&e.series.yAxis.drawCrosshair(null,e))}):d&&(d.setState(d.state,!0),g.axes.forEach(function(e){e.crosshair&&d.series[e.coll]===e&&e.drawCrosshair(null,d)})));else{if(d)d.onMouseOut();h&&h.forEach(function(e){e.setState()});if(l)l.onMouseOut();m&&m.hide(e);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());g.axes.forEach(function(e){e.hideCrosshair()});this.hoverX=g.hoverPoints=
g.hoverPoint=null}};f.prototype.runPointActions=function(g,e){var h=this.chart,l=h.tooltip&&h.tooltip.options.enabled?h.tooltip:void 0,m=l?l.shared:!1,f=e||h.hoverPoint,y=f&&f.series||h.hoverSeries;y=this.getHoverData(f,y,h.series,(!g||"touchmove"!==g.type)&&(!!e||y&&y.directTouch&&this.isDirectTouch),m,g);f=y.hoverPoint;var v=y.hoverPoints;e=(y=y.hoverSeries)&&y.tooltipOptions.followPointer;m=m&&y&&!y.noSharedTooltip;if(f&&(f!==h.hoverPoint||l&&l.isHidden)){(h.hoverPoints||[]).forEach(function(e){-1===
v.indexOf(e)&&e.setState()});if(h.hoverSeries!==y)y.onMouseOver();this.applyInactiveState(v);(v||[]).forEach(function(e){e.setState("hover")});h.hoverPoint&&h.hoverPoint.firePointEvent("mouseOut");if(!f.series)return;f.firePointEvent("mouseOver");h.hoverPoints=v;h.hoverPoint=f;l&&l.refresh(m?v:f,g)}else e&&l&&!l.isHidden&&(f=l.getAnchor([{}],g),l.updatePosition({plotX:f[0],plotY:f[1]}));this.unDocMouseMove||(this.unDocMouseMove=M(h.container.ownerDocument,"mousemove",function(e){var l=b[d.hoverChartIndex];
if(l)l.pointer.onDocumentMouseMove(e)}));h.axes.forEach(function(e){var b=t((e.crosshair||{}).snap,!0),l;b&&((l=h.hoverPoint)&&l.series[e.coll]===e||(l=F(v,function(c){return c.series[e.coll]===e})));l||!b?e.drawCrosshair(g,l):e.hideCrosshair()})};f.prototype.scaleGroups=function(b,e){var g=this.chart,l;g.series.forEach(function(d){l=b||d.getPlotBox();d.xAxis&&d.xAxis.zoomEnabled&&d.group&&(d.group.attr(l),d.markerGroup&&(d.markerGroup.attr(l),d.markerGroup.clip(e?g.clipRect:null)),d.dataLabelsGroup&&
d.dataLabelsGroup.attr(l))});g.clipRect.attr(e||g.clipBox)};f.prototype.setDOMEvents=function(){var b=this.chart.container,e=b.ownerDocument;b.onmousedown=this.onContainerMouseDown.bind(this);b.onmousemove=this.onContainerMouseMove.bind(this);b.onclick=this.onContainerClick.bind(this);this.unbindContainerMouseLeave=M(b,"mouseleave",this.onContainerMouseLeave.bind(this));d.unbindDocumentMouseUp||(d.unbindDocumentMouseUp=M(e,"mouseup",this.onDocumentMouseUp.bind(this)));d.hasTouch&&(M(b,"touchstart",
this.onContainerTouchStart.bind(this)),M(b,"touchmove",this.onContainerTouchMove.bind(this)),d.unbindDocumentTouchEnd||(d.unbindDocumentTouchEnd=M(e,"touchend",this.onDocumentTouchEnd.bind(this))))};f.prototype.setHoverChartIndex=function(){var b=this.chart,e=d.charts[t(d.hoverChartIndex,-1)];if(e&&e!==b)e.pointer.onContainerMouseLeave({relatedTarget:!0});e&&e.mouseIsDown||(d.hoverChartIndex=b.index)};f.prototype.touch=function(b,e){var g=this.chart,l;this.setHoverChartIndex();if(1===b.touches.length)if(b=
this.normalize(b),(l=g.isInsidePlot(b.chartX-g.plotLeft,b.chartY-g.plotTop))&&!g.openMenu){e&&this.runPointActions(b);if("touchmove"===b.type){e=this.pinchDown;var d=e[0]?4<=Math.sqrt(Math.pow(e[0].chartX-b.chartX,2)+Math.pow(e[0].chartY-b.chartY,2)):!1}t(d,!0)&&this.pinch(b)}else e&&this.reset();else 2===b.touches.length&&this.pinch(b)};f.prototype.zoomOption=function(b){var e=this.chart,g=e.options.chart,l=g.zoomType||"";e=e.inverted;/touch/.test(b.type)&&(l=t(g.pinchType,l));this.zoomX=b=/x/.test(l);
this.zoomY=l=/y/.test(l);this.zoomHor=b&&!e||l&&e;this.zoomVert=l&&!e||b&&e;this.hasZoom=b||l};return f}();d.Pointer=f;return d.Pointer});Q(A,"parts/MSPointer.js",[A["parts/Globals.js"],A["parts/Pointer.js"],A["parts/Utilities.js"]],function(d,f,E){function q(){var d=[];d.item=function(d){return this[d]};x(w,function(f){d.push({pageX:f.pageX,pageY:f.pageY,target:f.target})});return d}function M(f,n,m,b){"touch"!==f.pointerType&&f.pointerType!==f.MSPOINTER_TYPE_TOUCH||!H[d.hoverChartIndex]||(b(f),
b=H[d.hoverChartIndex].pointer,b[n]({type:m,target:f.currentTarget,preventDefault:D,touches:q()}))}var K=this&&this.__extends||function(){var d=function(f,m){d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(b,g){b.__proto__=g}||function(b,g){for(var d in g)g.hasOwnProperty(d)&&(b[d]=g[d])};return d(f,m)};return function(f,m){function b(){this.constructor=f}d(f,m);f.prototype=null===m?Object.create(m):(b.prototype=m.prototype,new b)}}(),J=E.addEvent,L=E.css,x=E.objectEach,F=E.removeEvent,
H=d.charts,C=d.doc,D=d.noop,w={},n=!!d.win.PointerEvent;return function(d){function f(){return null!==d&&d.apply(this,arguments)||this}K(f,d);f.prototype.batchMSEvents=function(d){d(this.chart.container,n?"pointerdown":"MSPointerDown",this.onContainerPointerDown);d(this.chart.container,n?"pointermove":"MSPointerMove",this.onContainerPointerMove);d(C,n?"pointerup":"MSPointerUp",this.onDocumentPointerUp)};f.prototype.destroy=function(){this.batchMSEvents(F);d.prototype.destroy.call(this)};f.prototype.init=
function(m,b){d.prototype.init.call(this,m,b);this.hasZoom&&L(m.container,{"-ms-touch-action":"none","touch-action":"none"})};f.prototype.onContainerPointerDown=function(d){M(d,"onContainerTouchStart","touchstart",function(b){w[b.pointerId]={pageX:b.pageX,pageY:b.pageY,target:b.currentTarget}})};f.prototype.onContainerPointerMove=function(d){M(d,"onContainerTouchMove","touchmove",function(b){w[b.pointerId]={pageX:b.pageX,pageY:b.pageY};w[b.pointerId].target||(w[b.pointerId].target=b.currentTarget)})};
f.prototype.onDocumentPointerUp=function(d){M(d,"onDocumentTouchEnd","touchend",function(b){delete w[b.pointerId]})};f.prototype.setDOMEvents=function(){d.prototype.setDOMEvents.call(this);(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(J)};return f}(f)});Q(A,"parts/Legend.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.addEvent,q=f.animObject,M=f.css,K=f.defined,J=f.discardElement,L=f.find,x=f.fireEvent,F=f.format,H=f.isNumber,C=f.merge,D=f.pick,w=f.relativeLength,
n=f.setAnimation,t=f.stableSort,N=f.syncTimeout;f=f.wrap;var m=d.isFirefox,b=d.marginNames,g=d.win,v=function(){function g(e,b){this.allItems=[];this.contentGroup=this.box=void 0;this.display=!1;this.group=void 0;this.offsetWidth=this.maxLegendWidth=this.maxItemWidth=this.legendWidth=this.legendHeight=this.lastLineHeight=this.lastItemY=this.itemY=this.itemX=this.itemMarginTop=this.itemMarginBottom=this.itemHeight=this.initialItemY=0;this.options={};this.padding=0;this.pages=[];this.proximate=!1;this.scrollGroup=
void 0;this.widthOption=this.totalItemWidth=this.titleHeight=this.symbolWidth=this.symbolHeight=0;this.chart=e;this.init(e,b)}g.prototype.init=function(e,b){this.chart=e;this.setOptions(b);b.enabled&&(this.render(),E(this.chart,"endResize",function(){this.legend.positionCheckboxes()}),this.proximate?this.unchartrender=E(this.chart,"render",function(){this.legend.proximatePositions();this.legend.positionItems()}):this.unchartrender&&this.unchartrender())};g.prototype.setOptions=function(e){var b=D(e.padding,
8);this.options=e;this.chart.styledMode||(this.itemStyle=e.itemStyle,this.itemHiddenStyle=C(this.itemStyle,e.itemHiddenStyle));this.itemMarginTop=e.itemMarginTop||0;this.itemMarginBottom=e.itemMarginBottom||0;this.padding=b;this.initialItemY=b-5;this.symbolWidth=D(e.symbolWidth,16);this.pages=[];this.proximate="proximate"===e.layout&&!this.chart.inverted;this.baseline=void 0};g.prototype.update=function(e,b){var g=this.chart;this.setOptions(C(!0,this.options,e));this.destroy();g.isDirtyLegend=g.isDirtyBox=
!0;D(b,!0)&&g.redraw();x(this,"afterUpdate")};g.prototype.colorizeItem=function(e,b){e.legendGroup[b?"removeClass":"addClass"]("highcharts-legend-item-hidden");if(!this.chart.styledMode){var g=this.options,d=e.legendItem,h=e.legendLine,m=e.legendSymbol,f=this.itemHiddenStyle.color;g=b?g.itemStyle.color:f;var p=b?e.color||f:f,v=e.options&&e.options.marker,n={fill:p};d&&d.css({fill:g,color:g});h&&h.attr({stroke:p});m&&(v&&m.isMarker&&(n=e.pointAttribs(),b||(n.stroke=n.fill=f)),m.attr(n))}x(this,"afterColorizeItem",
{item:e,visible:b})};g.prototype.positionItems=function(){this.allItems.forEach(this.positionItem,this);this.chart.isResizing||this.positionCheckboxes()};g.prototype.positionItem=function(e){var b=this.options,g=b.symbolPadding;b=!b.rtl;var d=e._legendItemPos,h=d[0];d=d[1];var m=e.checkbox;if((e=e.legendGroup)&&e.element)e[K(e.translateY)?"animate":"attr"]({translateX:b?h:this.legendWidth-h-2*g-4,translateY:d});m&&(m.x=h,m.y=d)};g.prototype.destroyItem=function(e){var b=e.checkbox;["legendItem","legendLine",
"legendSymbol","legendGroup"].forEach(function(b){e[b]&&(e[b]=e[b].destroy())});b&&J(e.checkbox)};g.prototype.destroy=function(){function b(b){this[b]&&(this[b]=this[b].destroy())}this.getAllItems().forEach(function(e){["legendItem","legendGroup"].forEach(b,e)});"clipRect up down pager nav box title group".split(" ").forEach(b,this);this.display=null};g.prototype.positionCheckboxes=function(){var b=this.group&&this.group.alignAttr,g=this.clipHeight||this.legendHeight,l=this.titleHeight;if(b){var d=
b.translateY;this.allItems.forEach(function(e){var h=e.checkbox;if(h){var m=d+l+h.y+(this.scrollOffset||0)+3;M(h,{left:b.translateX+e.checkboxOffset+h.x-20+"px",top:m+"px",display:this.proximate||m>d-6&&m<d+g-6?"":"none"})}},this)}};g.prototype.renderTitle=function(){var b=this.options,g=this.padding,l=b.title,d=0;l.text&&(this.title||(this.title=this.chart.renderer.label(l.text,g-3,g-4,null,null,null,b.useHTML,null,"legend-title").attr({zIndex:1}),this.chart.styledMode||this.title.css(l.style),this.title.add(this.group)),
l.width||this.title.css({width:this.maxLegendWidth+"px"}),b=this.title.getBBox(),d=b.height,this.offsetWidth=b.width,this.contentGroup.attr({translateY:d}));this.titleHeight=d};g.prototype.setText=function(b){var e=this.options;b.legendItem.attr({text:e.labelFormat?F(e.labelFormat,b,this.chart):e.labelFormatter.call(b)})};g.prototype.renderItem=function(b){var e=this.chart,g=e.renderer,d=this.options,h=this.symbolWidth,m=d.symbolPadding,f=this.itemStyle,v=this.itemHiddenStyle,n="horizontal"===d.layout?
D(d.itemDistance,20):0,w=!d.rtl,c=b.legendItem,a=!b.series,k=!a&&b.series.drawLegendSymbol?b.series:b,r=k.options;r=this.createCheckboxForItem&&r&&r.showCheckbox;n=h+m+n+(r?20:0);var z=d.useHTML,t=b.options.className;c||(b.legendGroup=g.g("legend-item").addClass("highcharts-"+k.type+"-series highcharts-color-"+b.colorIndex+(t?" "+t:"")+(a?" highcharts-series-"+b.index:"")).attr({zIndex:1}).add(this.scrollGroup),b.legendItem=c=g.text("",w?h+m:-m,this.baseline||0,z),e.styledMode||c.css(C(b.visible?
f:v)),c.attr({align:w?"left":"right",zIndex:2}).add(b.legendGroup),this.baseline||(this.fontMetrics=g.fontMetrics(e.styledMode?12:f.fontSize,c),this.baseline=this.fontMetrics.f+3+this.itemMarginTop,c.attr("y",this.baseline)),this.symbolHeight=d.symbolHeight||this.fontMetrics.f,k.drawLegendSymbol(this,b),this.setItemEvents&&this.setItemEvents(b,c,z));r&&!b.checkbox&&this.createCheckboxForItem&&this.createCheckboxForItem(b);this.colorizeItem(b,b.visible);!e.styledMode&&f.width||c.css({width:(d.itemWidth||
this.widthOption||e.spacingBox.width)-n+"px"});this.setText(b);e=c.getBBox();b.itemWidth=b.checkboxOffset=d.itemWidth||b.legendItemWidth||e.width+n;this.maxItemWidth=Math.max(this.maxItemWidth,b.itemWidth);this.totalItemWidth+=b.itemWidth;this.itemHeight=b.itemHeight=Math.round(b.legendItemHeight||e.height||this.symbolHeight)};g.prototype.layoutItem=function(b){var e=this.options,g=this.padding,d="horizontal"===e.layout,h=b.itemHeight,m=this.itemMarginBottom,f=this.itemMarginTop,v=d?D(e.itemDistance,
20):0,n=this.maxLegendWidth;e=e.alignColumns&&this.totalItemWidth>n?this.maxItemWidth:b.itemWidth;d&&this.itemX-g+e>n&&(this.itemX=g,this.lastLineHeight&&(this.itemY+=f+this.lastLineHeight+m),this.lastLineHeight=0);this.lastItemY=f+this.itemY+m;this.lastLineHeight=Math.max(h,this.lastLineHeight);b._legendItemPos=[this.itemX,this.itemY];d?this.itemX+=e:(this.itemY+=f+h+m,this.lastLineHeight=h);this.offsetWidth=this.widthOption||Math.max((d?this.itemX-g-(b.checkbox?0:v):e)+g,this.offsetWidth)};g.prototype.getAllItems=
function(){var b=[];this.chart.series.forEach(function(e){var g=e&&e.options;e&&D(g.showInLegend,K(g.linkedTo)?!1:void 0,!0)&&(b=b.concat(e.legendItems||("point"===g.legendType?e.data:e)))});x(this,"afterGetAllItems",{allItems:b});return b};g.prototype.getAlignment=function(){var b=this.options;return this.proximate?b.align.charAt(0)+"tv":b.floating?"":b.align.charAt(0)+b.verticalAlign.charAt(0)+b.layout.charAt(0)};g.prototype.adjustMargins=function(e,g){var l=this.chart,d=this.options,h=this.getAlignment();
h&&[/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/].forEach(function(m,f){m.test(h)&&!K(e[f])&&(l[b[f]]=Math.max(l[b[f]],l.legend[(f+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][f]*d[f%2?"x":"y"]+D(d.margin,12)+g[f]+(l.titleOffset[f]||0)))})};g.prototype.proximatePositions=function(){var b=this.chart,g=[],l="left"===this.options.align;this.allItems.forEach(function(e){var d=l;if(e.yAxis&&e.points){e.xAxis.options.reversed&&(d=!d);var h=L(d?e.points:e.points.slice(0).reverse(),function(b){return H(b.plotY)});
d=this.itemMarginTop+e.legendItem.getBBox().height+this.itemMarginBottom;var m=e.yAxis.top-b.plotTop;e.visible?(h=h?h.plotY:e.yAxis.height,h+=m-.3*d):h=m+e.yAxis.height;g.push({target:h,size:d,item:e})}},this);d.distribute(g,b.plotHeight);g.forEach(function(e){e.item._legendItemPos[1]=b.plotTop-b.spacing[0]+e.pos})};g.prototype.render=function(){var b=this.chart,g=b.renderer,l=this.group,d=this.box,h=this.options,m=this.padding;this.itemX=m;this.itemY=this.initialItemY;this.lastItemY=this.offsetWidth=
0;this.widthOption=w(h.width,b.spacingBox.width-m);var f=b.spacingBox.width-2*m-h.x;-1<["rm","lm"].indexOf(this.getAlignment().substring(0,2))&&(f/=2);this.maxLegendWidth=this.widthOption||f;l||(this.group=l=g.g("legend").attr({zIndex:7}).add(),this.contentGroup=g.g().attr({zIndex:1}).add(l),this.scrollGroup=g.g().add(this.contentGroup));this.renderTitle();var v=this.getAllItems();t(v,function(b,c){return(b.options&&b.options.legendIndex||0)-(c.options&&c.options.legendIndex||0)});h.reversed&&v.reverse();
this.allItems=v;this.display=f=!!v.length;this.itemHeight=this.totalItemWidth=this.maxItemWidth=this.lastLineHeight=0;v.forEach(this.renderItem,this);v.forEach(this.layoutItem,this);v=(this.widthOption||this.offsetWidth)+m;var n=this.lastItemY+this.lastLineHeight+this.titleHeight;n=this.handleOverflow(n);n+=m;d||(this.box=d=g.rect().addClass("highcharts-legend-box").attr({r:h.borderRadius}).add(l),d.isNew=!0);b.styledMode||d.attr({stroke:h.borderColor,"stroke-width":h.borderWidth||0,fill:h.backgroundColor||
"none"}).shadow(h.shadow);0<v&&0<n&&(d[d.isNew?"attr":"animate"](d.crisp.call({},{x:0,y:0,width:v,height:n},d.strokeWidth())),d.isNew=!1);d[f?"show":"hide"]();b.styledMode&&"none"===l.getStyle("display")&&(v=n=0);this.legendWidth=v;this.legendHeight=n;f&&this.align();this.proximate||this.positionItems();x(this,"afterRender")};g.prototype.align=function(b){void 0===b&&(b=this.chart.spacingBox);var e=this.chart,g=this.options,d=b.y;/(lth|ct|rth)/.test(this.getAlignment())&&0<e.titleOffset[0]?d+=e.titleOffset[0]:
/(lbh|cb|rbh)/.test(this.getAlignment())&&0<e.titleOffset[2]&&(d-=e.titleOffset[2]);d!==b.y&&(b=C(b,{y:d}));this.group.align(C(g,{width:this.legendWidth,height:this.legendHeight,verticalAlign:this.proximate?"top":g.verticalAlign}),!0,b)};g.prototype.handleOverflow=function(b){var e=this,g=this.chart,d=g.renderer,h=this.options,m=h.y,f=this.padding;m=g.spacingBox.height+("top"===h.verticalAlign?-m:m)-f;var v=h.maxHeight,n,w=this.clipRect,c=h.navigation,a=D(c.animation,!0),k=c.arrowSize||12,r=this.nav,
z=this.pages,t,x=this.allItems,q=function(a){"number"===typeof a?w.attr({height:a}):w&&(e.clipRect=w.destroy(),e.contentGroup.clip());e.contentGroup.div&&(e.contentGroup.div.style.clip=a?"rect("+f+"px,9999px,"+(f+a)+"px,0)":"auto")},C=function(a){e[a]=d.circle(0,0,1.3*k).translate(k/2,k/2).add(r);g.styledMode||e[a].attr("fill","rgba(0,0,0,0.0001)");return e[a]};"horizontal"!==h.layout||"middle"===h.verticalAlign||h.floating||(m/=2);v&&(m=Math.min(m,v));z.length=0;b>m&&!1!==c.enabled?(this.clipHeight=
n=Math.max(m-20-this.titleHeight-f,0),this.currentPage=D(this.currentPage,1),this.fullHeight=b,x.forEach(function(a,c){var b=a._legendItemPos[1],e=Math.round(a.legendItem.getBBox().height),k=z.length;if(!k||b-z[k-1]>n&&(t||b)!==z[k-1])z.push(t||b),k++;a.pageIx=k-1;t&&(x[c-1].pageIx=k-1);c===x.length-1&&b+e-z[k-1]>n&&b!==t&&(z.push(b),a.pageIx=k);b!==t&&(t=b)}),w||(w=e.clipRect=d.clipRect(0,f,9999,0),e.contentGroup.clip(w)),q(n),r||(this.nav=r=d.g().attr({zIndex:1}).add(this.group),this.up=d.symbol("triangle",
0,0,k,k).add(r),C("upTracker").on("click",function(){e.scroll(-1,a)}),this.pager=d.text("",15,10).addClass("highcharts-legend-navigation"),g.styledMode||this.pager.css(c.style),this.pager.add(r),this.down=d.symbol("triangle-down",0,0,k,k).add(r),C("downTracker").on("click",function(){e.scroll(1,a)})),e.scroll(0),b=m):r&&(q(),this.nav=r.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);return b};g.prototype.scroll=function(b,g){var e=this,d=this.chart,h=this.pages,m=h.length,f=this.currentPage+
b;b=this.clipHeight;var p=this.options.navigation,v=this.pager,w=this.padding;f>m&&(f=m);0<f&&("undefined"!==typeof g&&n(g,d),this.nav.attr({translateX:w,translateY:b+this.padding+7+this.titleHeight,visibility:"visible"}),[this.up,this.upTracker].forEach(function(c){c.attr({"class":1===f?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})}),v.attr({text:f+"/"+m}),[this.down,this.downTracker].forEach(function(c){c.attr({x:18+this.pager.getBBox().width,"class":f===m?"highcharts-legend-nav-inactive":
"highcharts-legend-nav-active"})},this),d.styledMode||(this.up.attr({fill:1===f?p.inactiveColor:p.activeColor}),this.upTracker.css({cursor:1===f?"default":"pointer"}),this.down.attr({fill:f===m?p.inactiveColor:p.activeColor}),this.downTracker.css({cursor:f===m?"default":"pointer"})),this.scrollOffset=-h[f-1]+this.initialItemY,this.scrollGroup.animate({translateY:this.scrollOffset}),this.currentPage=f,this.positionCheckboxes(),g=q(D(g,d.renderer.globalAnimation,!0)),N(function(){x(e,"afterScroll",
{currentPage:f})},g.duration||0))};return g}();(/Trident\/7\.0/.test(g.navigator&&g.navigator.userAgent)||m)&&f(v.prototype,"positionItem",function(b,e){var g=this,d=function(){e._legendItemPos&&b.call(g,e)};d();g.bubbleLegend||setTimeout(d)});d.Legend=v;return d.Legend});Q(A,"parts/Chart.js",[A["parts/Globals.js"],A["parts/Legend.js"],A["parts/MSPointer.js"],A["parts/Pointer.js"],A["parts/Time.js"],A["parts/Utilities.js"]],function(d,f,E,q,M,K){var J=K.addEvent,L=K.animate,x=K.animObject,F=K.attr,
H=K.createElement,C=K.css,D=K.defined,w=K.discardElement,n=K.erase,t=K.error,N=K.extend,m=K.find,b=K.fireEvent,g=K.getStyle,v=K.isArray,h=K.isFunction,e=K.isNumber,p=K.isObject,l=K.isString,I=K.merge,u=K.numberFormat,y=K.objectEach,G=K.pick,S=K.pInt,R=K.relativeLength,B=K.removeEvent,c=K.setAnimation,a=K.splat,k=K.syncTimeout,r=K.uniqueKey,z=d.doc,P=d.Axis,U=d.defaultOptions,W=d.charts,Y=d.marginNames,T=d.seriesTypes,A=d.win,aa=d.Chart=function(){this.getArgs.apply(this,arguments)};d.chart=function(a,
c,b){return new aa(a,c,b)};N(aa.prototype,{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);if(l(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(a,c){var e,k=a.series,g=a.plotOptions||{};b(this,"init",{args:arguments},function(){a.series=null;e=I(U,a);var l=e.chart||{};y(e.plotOptions,function(a,c){p(a)&&(a.tooltip=g[c]&&I(g[c].tooltip)||void 0)});e.tooltip.userOptions=a.chart&&a.chart.forExport&&a.tooltip.userOptions||a.tooltip;e.series=a.series=k;this.userOptions=
a;var m=l.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.labelCollectors=[];this.callback=c;this.isResizing=0;this.options=e;this.axes=[];this.series=[];this.time=a.time&&Object.keys(a.time).length?new M(a.time):d.time;this.numberFormatter=l.numberFormatter||u;this.styledMode=l.styledMode;this.hasCartesianSeries=l.showAxes;var f=this;f.index=W.length;W.push(f);d.chartCount++;m&&y(m,function(a,c){h(a)&&J(f,c,a)});f.xAxis=[];f.yAxis=[];f.pointCount=f.colorCounter=f.symbolCounter=
0;b(f,"afterInit");f.firstRender()})},initSeries:function(a){var c=this.options.chart;c=a.type||c.type||c.defaultSeriesType;var b=T[c];b||t(17,!0,this,{missingModuleFor:c});c=new b;c.init(this,a);return c},setSeriesData:function(){this.getSeriesOrderByLinks().forEach(function(a){a.points||a.data||!a.enabledDataSorting||a.setData(a.options.data,!1)})},getSeriesOrderByLinks:function(){return this.series.concat().sort(function(a,c){return a.linkedSeries.length||c.linkedSeries.length?c.linkedSeries.length-
a.linkedSeries.length:0})},orderSeries:function(a){var c=this.series;for(a=a||0;a<c.length;a++)c[a]&&(c[a].index=a,c[a].name=c[a].getName())},isInsidePlot:function(a,c,e){var k=e?c:a;a=e?a:c;k={x:k,y:a,isInsidePlot:0<=k&&k<=this.plotWidth&&0<=a&&a<=this.plotHeight};b(this,"afterIsInsidePlot",k);return k.isInsidePlot},redraw:function(a){b(this,"beforeRedraw");var e=this.axes,k=this.series,g=this.pointer,d=this.legend,l=this.userOptions.legend,h=this.isDirtyLegend,f=this.hasCartesianSeries,m=this.isDirtyBox,
r=this.renderer,u=r.isHidden(),p=[];this.setResponsive&&this.setResponsive(!1);c(this.hasRendered?a:!1,this);u&&this.temporaryDisplay();this.layOutTitles();for(a=k.length;a--;){var v=k[a];if(v.options.stacking){var z=!0;if(v.isDirty){var n=!0;break}}}if(n)for(a=k.length;a--;)v=k[a],v.options.stacking&&(v.isDirty=!0);k.forEach(function(a){a.isDirty&&("point"===a.options.legendType?(a.updateTotals&&a.updateTotals(),h=!0):l&&(l.labelFormatter||l.labelFormat)&&(h=!0));a.isDirtyData&&b(a,"updatedData")});
h&&d&&d.options.enabled&&(d.render(),this.isDirtyLegend=!1);z&&this.getStacks();f&&e.forEach(function(a){a.updateNames();a.setScale()});this.getMargins();f&&(e.forEach(function(a){a.isDirty&&(m=!0)}),e.forEach(function(a){var c=a.min+","+a.max;a.extKey!==c&&(a.extKey=c,p.push(function(){b(a,"afterSetExtremes",N(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(m||z)&&a.redraw()}));m&&this.drawChartBox();b(this,"predraw");k.forEach(function(a){(m||a.isDirty)&&a.visible&&a.redraw();a.isDirtyData=
!1});g&&g.reset(!0);r.draw();b(this,"redraw");b(this,"render");u&&this.temporaryDisplay(!0);p.forEach(function(a){a.call()})},get:function(a){function c(c){return c.id===a||c.options&&c.options.id===a}var b=this.series,e;var k=m(this.axes,c)||m(this.series,c);for(e=0;!k&&e<b.length;e++)k=m(b[e].points||[],c);return k},getAxes:function(){var c=this,e=this.options,k=e.xAxis=a(e.xAxis||{});e=e.yAxis=a(e.yAxis||{});b(this,"getAxes");k.forEach(function(a,c){a.index=c;a.isX=!0});e.forEach(function(a,c){a.index=
c});k.concat(e).forEach(function(a){new P(c,a)});b(this,"afterGetAxes")},getSelectedPoints:function(){var a=[];this.series.forEach(function(c){a=a.concat(c.getPointsCollection().filter(function(a){return G(a.selectedStaging,a.selected)}))});return a},getSelectedSeries:function(){return this.series.filter(function(a){return a.selected})},setTitle:function(a,c,b){this.applyDescription("title",a);this.applyDescription("subtitle",c);this.applyDescription("caption",void 0);this.layOutTitles(b)},applyDescription:function(a,
c){var b=this,e="title"===a?{color:"#333333",fontSize:this.options.isStock?"16px":"18px"}:{color:"#666666"};e=this.options[a]=I(!this.styledMode&&{style:e},this.options[a],c);var k=this[a];k&&c&&(this[a]=k=k.destroy());e&&!k&&(k=this.renderer.text(e.text,0,0,e.useHTML).attr({align:e.align,"class":"highcharts-"+a,zIndex:e.zIndex||4}).add(),k.update=function(c){b[{title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"}[a]](c)},this.styledMode||k.css(e.style),this[a]=k)},layOutTitles:function(a){var c=
[0,0,0],e=this.renderer,k=this.spacingBox;["title","subtitle","caption"].forEach(function(a){var b=this[a],g=this.options[a],d=g.verticalAlign||"top";a="title"===a?-3:"top"===d?c[0]+2:0;if(b){if(!this.styledMode)var l=g.style.fontSize;l=e.fontMetrics(l,b).b;b.css({width:(g.width||k.width+(g.widthAdjust||0))+"px"});var h=Math.round(b.getBBox(g.useHTML).height);b.align(N({y:"bottom"===d?l:a+l,height:h},g),!1,"spacingBox");g.floating||("top"===d?c[0]=Math.ceil(c[0]+h):"bottom"===d&&(c[2]=Math.ceil(c[2]+
h)))}},this);c[0]&&"top"===(this.options.title.verticalAlign||"top")&&(c[0]+=this.options.title.margin);c[2]&&"bottom"===this.options.caption.verticalAlign&&(c[2]+=this.options.caption.margin);var g=!this.titleOffset||this.titleOffset.join(",")!==c.join(",");this.titleOffset=c;b(this,"afterLayOutTitles");!this.isDirtyBox&&g&&(this.isDirtyBox=this.isDirtyLegend=g,this.hasRendered&&G(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var a=this.options.chart,c=a.width;a=a.height;var b=
this.renderTo;D(c)||(this.containerWidth=g(b,"width"));D(a)||(this.containerHeight=g(b,"height"));this.chartWidth=Math.max(0,c||this.containerWidth||600);this.chartHeight=Math.max(0,R(a,this.chartWidth)||(1<this.containerHeight?this.containerHeight:400))},temporaryDisplay:function(a){var c=this.renderTo;if(a)for(;c&&c.style;)c.hcOrigStyle&&(C(c,c.hcOrigStyle),delete c.hcOrigStyle),c.hcOrigDetached&&(z.body.removeChild(c),c.hcOrigDetached=!1),c=c.parentNode;else for(;c&&c.style;){z.body.contains(c)||
c.parentNode||(c.hcOrigDetached=!0,z.body.appendChild(c));if("none"===g(c,"display",!1)||c.hcOricDetached)c.hcOrigStyle={display:c.style.display,height:c.style.height,overflow:c.style.overflow},a={display:"block",overflow:"hidden"},c!==this.renderTo&&(a.height=0),C(c,a),c.offsetWidth||c.style.setProperty("display","block","important");c=c.parentNode;if(c===z.body)break}},setClassName:function(a){this.container.className="highcharts-container "+(a||"")},getContainer:function(){var a=this.options,k=
a.chart;var g=this.renderTo;var h=r(),m,f;g||(this.renderTo=g=k.renderTo);l(g)&&(this.renderTo=g=z.getElementById(g));g||t(13,!0,this);var u=S(F(g,"data-highcharts-chart"));e(u)&&W[u]&&W[u].hasRendered&&W[u].destroy();F(g,"data-highcharts-chart",this.index);g.innerHTML="";k.skipClone||g.offsetWidth||this.temporaryDisplay();this.getChartSize();u=this.chartWidth;var p=this.chartHeight;C(g,{overflow:"hidden"});this.styledMode||(m=N({position:"relative",overflow:"hidden",width:u+"px",height:p+"px",textAlign:"left",
lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},k.style));this.container=g=H("div",{id:h},m,g);this._cursor=g.style.cursor;this.renderer=new (d[k.renderer]||d.Renderer)(g,u,p,null,k.forExport,a.exporting&&a.exporting.allowHTML,this.styledMode);c(void 0,this);this.setClassName(k.className);if(this.styledMode)for(f in a.defs)this.renderer.definition(a.defs[f]);else this.renderer.setStyle(k.style);this.renderer.chartIndex=this.index;b(this,"afterGetContainer")},getMargins:function(a){var c=
this.spacing,e=this.margin,k=this.titleOffset;this.resetMargins();k[0]&&!D(e[0])&&(this.plotTop=Math.max(this.plotTop,k[0]+c[0]));k[2]&&!D(e[2])&&(this.marginBottom=Math.max(this.marginBottom,k[2]+c[2]));this.legend&&this.legend.display&&this.legend.adjustMargins(e,c);b(this,"getMargins");a||this.getAxisMargins()},getAxisMargins:function(){var a=this,c=a.axisOffset=[0,0,0,0],b=a.colorAxis,e=a.margin,k=function(a){a.forEach(function(a){a.visible&&a.getOffset()})};a.hasCartesianSeries?k(a.axes):b&&
b.length&&k(b);Y.forEach(function(b,k){D(e[k])||(a[b]+=c[k])});a.setChartSize()},reflow:function(a){var c=this,b=c.options.chart,e=c.renderTo,d=D(b.width)&&D(b.height),l=b.width||g(e,"width");b=b.height||g(e,"height");e=a?a.target:A;if(!d&&!c.isPrinting&&l&&b&&(e===A||e===z)){if(l!==c.containerWidth||b!==c.containerHeight)K.clearTimeout(c.reflowTimeout),c.reflowTimeout=k(function(){c.container&&c.setSize(void 0,void 0,!1)},a?100:0);c.containerWidth=l;c.containerHeight=b}},setReflow:function(a){var c=
this;!1===a||this.unbindReflow?!1===a&&this.unbindReflow&&(this.unbindReflow=this.unbindReflow()):(this.unbindReflow=J(A,"resize",function(a){c.options&&c.reflow(a)}),J(this,"destroy",this.unbindReflow))},setSize:function(a,e,g){var d=this,l=d.renderer;d.isResizing+=1;c(g,d);g=l.globalAnimation;d.oldChartHeight=d.chartHeight;d.oldChartWidth=d.chartWidth;"undefined"!==typeof a&&(d.options.chart.width=a);"undefined"!==typeof e&&(d.options.chart.height=e);d.getChartSize();d.styledMode||(g?L:C)(d.container,
{width:d.chartWidth+"px",height:d.chartHeight+"px"},g);d.setChartSize(!0);l.setSize(d.chartWidth,d.chartHeight,g);d.axes.forEach(function(a){a.isDirty=!0;a.setScale()});d.isDirtyLegend=!0;d.isDirtyBox=!0;d.layOutTitles();d.getMargins();d.redraw(g);d.oldChartHeight=null;b(d,"resize");k(function(){d&&b(d,"endResize",null,function(){--d.isResizing})},x(g).duration||0)},setChartSize:function(a){var c=this.inverted,e=this.renderer,k=this.chartWidth,g=this.chartHeight,d=this.options.chart,l=this.spacing,
h=this.clipOffset,m,f,r,u;this.plotLeft=m=Math.round(this.plotLeft);this.plotTop=f=Math.round(this.plotTop);this.plotWidth=r=Math.max(0,Math.round(k-m-this.marginRight));this.plotHeight=u=Math.max(0,Math.round(g-f-this.marginBottom));this.plotSizeX=c?u:r;this.plotSizeY=c?r:u;this.plotBorderWidth=d.plotBorderWidth||0;this.spacingBox=e.spacingBox={x:l[3],y:l[0],width:k-l[3]-l[1],height:g-l[0]-l[2]};this.plotBox=e.plotBox={x:m,y:f,width:r,height:u};k=2*Math.floor(this.plotBorderWidth/2);c=Math.ceil(Math.max(k,
h[3])/2);e=Math.ceil(Math.max(k,h[0])/2);this.clipBox={x:c,y:e,width:Math.floor(this.plotSizeX-Math.max(k,h[1])/2-c),height:Math.max(0,Math.floor(this.plotSizeY-Math.max(k,h[2])/2-e))};a||this.axes.forEach(function(a){a.setAxisSize();a.setAxisTranslation()});b(this,"afterSetChartSize",{skipAxes:a})},resetMargins:function(){b(this,"resetMargins");var a=this,c=a.options.chart;["margin","spacing"].forEach(function(b){var e=c[b],k=p(e)?e:[e,e,e,e];["Top","Right","Bottom","Left"].forEach(function(e,g){a[b][g]=
G(c[b+e],k[g])})});Y.forEach(function(c,b){a[c]=G(a.margin[b],a.spacing[b])});a.axisOffset=[0,0,0,0];a.clipOffset=[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,c=this.renderer,e=this.chartWidth,k=this.chartHeight,g=this.chartBackground,d=this.plotBackground,l=this.plotBorder,h=this.styledMode,m=this.plotBGImage,f=a.backgroundColor,r=a.plotBackgroundColor,u=a.plotBackgroundImage,p,v=this.plotLeft,z=this.plotTop,n=this.plotWidth,y=this.plotHeight,w=this.plotBox,t=this.clipRect,B=this.clipBox,
P="animate";g||(this.chartBackground=g=c.rect().addClass("highcharts-background").add(),P="attr");if(h)var G=p=g.strokeWidth();else{G=a.borderWidth||0;p=G+(a.shadow?8:0);f={fill:f||"none"};if(G||g["stroke-width"])f.stroke=a.borderColor,f["stroke-width"]=G;g.attr(f).shadow(a.shadow)}g[P]({x:p/2,y:p/2,width:e-p-G%2,height:k-p-G%2,r:a.borderRadius});P="animate";d||(P="attr",this.plotBackground=d=c.rect().addClass("highcharts-plot-background").add());d[P](w);h||(d.attr({fill:r||"none"}).shadow(a.plotShadow),
u&&(m?(u!==m.attr("href")&&m.attr("href",u),m.animate(w)):this.plotBGImage=c.image(u,v,z,n,y).add()));t?t.animate({width:B.width,height:B.height}):this.clipRect=c.clipRect(B);P="animate";l||(P="attr",this.plotBorder=l=c.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());h||l.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||0,fill:"none"});l[P](l.crisp({x:v,y:z,width:n,height:y},-l.strokeWidth()));this.isDirtyBox=!1;b(this,"afterDrawChartBox")},propFromSeries:function(){var a=
this,c=a.options.chart,b,e=a.options.series,k,g;["inverted","angular","polar"].forEach(function(d){b=T[c.type||c.defaultSeriesType];g=c[d]||b&&b.prototype[d];for(k=e&&e.length;!g&&k--;)(b=T[e[k].type])&&b.prototype[d]&&(g=!0);a[d]=g})},linkSeries:function(){var a=this,c=a.series;c.forEach(function(a){a.linkedSeries.length=0});c.forEach(function(c){var b=c.options.linkedTo;l(b)&&(b=":previous"===b?a.series[c.index-1]:a.get(b))&&b.linkedParent!==c&&(b.linkedSeries.push(c),c.linkedParent=b,b.enabledDataSorting&&
c.setDataSortingOptions(),c.visible=G(c.options.visible,b.options.visible,c.visible))});b(this,"afterLinkSeries")},renderSeries:function(){this.series.forEach(function(a){a.translate();a.render()})},renderLabels:function(){var a=this,c=a.options.labels;c.items&&c.items.forEach(function(b){var e=N(c.style,b.style),k=S(e.left)+a.plotLeft,g=S(e.top)+a.plotTop+12;delete e.left;delete e.top;a.renderer.text(b.html,k,g).attr({zIndex:2}).css(e).add()})},render:function(){var a=this.axes,c=this.colorAxis,
b=this.renderer,e=this.options,k=0,g=function(a){a.forEach(function(a){a.visible&&a.render()})};this.setTitle();this.legend=new f(this,e.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();e=this.plotWidth;a.some(function(a){if(a.horiz&&a.visible&&a.options.labels.enabled&&a.series.length)return k=21,!0});var d=this.plotHeight=Math.max(this.plotHeight-k,0);a.forEach(function(a){a.setScale()});this.getAxisMargins();var l=1.1<e/this.plotWidth;var h=1.05<d/this.plotHeight;
if(l||h)a.forEach(function(a){(a.horiz&&l||!a.horiz&&h)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries?g(a):c&&c.length&&g(c);this.seriesGroup||(this.seriesGroup=b.g("series-group").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.updateContainerScaling();this.hasRendered=!0},addCredits:function(a){var c=this;a=I(!0,this.options.credits,a);a.enabled&&!this.credits&&(this.credits=
this.renderer.text(a.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){a.href&&(A.location.href=a.href)}).attr({align:a.position.align,zIndex:8}),c.styledMode||this.credits.css(a.style),this.credits.add().align(a.position),this.credits.update=function(a){c.credits=c.credits.destroy();c.addCredits(a)})},updateContainerScaling:function(){var a=this.container;if(a.offsetWidth&&a.offsetHeight&&a.getBoundingClientRect){var c=a.getBoundingClientRect(),b=c.width/a.offsetWidth;
a=c.height/a.offsetHeight;1!==b||1!==a?this.containerScaling={scaleX:b,scaleY:a}:delete this.containerScaling}},destroy:function(){var a=this,c=a.axes,e=a.series,k=a.container,g,l=k&&k.parentNode;b(a,"destroy");a.renderer.forExport?n(W,a):W[a.index]=void 0;d.chartCount--;a.renderTo.removeAttribute("data-highcharts-chart");B(a);for(g=c.length;g--;)c[g]=c[g].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(g=e.length;g--;)e[g]=e[g].destroy();"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(c){var b=
a[c];b&&b.destroy&&(a[c]=b.destroy())});k&&(k.innerHTML="",B(k),l&&w(k));y(a,function(c,b){delete a[b]})},firstRender:function(){var a=this,c=a.options;if(!a.isReadyToRender||a.isReadyToRender()){a.getContainer();a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();(v(c.series)?c.series:[]).forEach(function(c){a.initSeries(c)});a.linkSeries();a.setSeriesData();b(a,"beforeRender");q&&(a.pointer=d.hasTouch||!A.PointerEvent&&!A.MSPointerEvent?new q(a,c):new E(a,c));a.render();if(!a.renderer.imgCount&&
!a.hasLoaded)a.onload();a.temporaryDisplay(!0)}},onload:function(){this.callbacks.concat([this.callback]).forEach(function(a){a&&"undefined"!==typeof this.index&&a.apply(this,[this])},this);b(this,"load");b(this,"render");D(this.index)&&this.setReflow(this.options.chart.reflow);this.hasLoaded=!0}})});Q(A,"parts/ScrollablePlotArea.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.addEvent,q=f.createElement,A=f.pick,K=f.stop;f=d.Chart;"";E(f,"afterSetChartSize",function(f){var q=
this.options.chart.scrollablePlotArea,x=q&&q.minWidth;q=q&&q.minHeight;if(!this.renderer.forExport){if(x){if(this.scrollablePixelsX=x=Math.max(0,x-this.chartWidth)){this.plotWidth+=x;this.inverted?(this.clipBox.height+=x,this.plotBox.height+=x):(this.clipBox.width+=x,this.plotBox.width+=x);var F={1:{name:"right",value:x}}}}else q&&(this.scrollablePixelsY=x=Math.max(0,q-this.chartHeight))&&(this.plotHeight+=x,this.inverted?(this.clipBox.width+=x,this.plotBox.width+=x):(this.clipBox.height+=x,this.plotBox.height+=
x),F={2:{name:"bottom",value:x}});F&&!f.skipAxes&&this.axes.forEach(function(f){F[f.side]?f.getPlotLinePath=function(){var x=F[f.side].name,q=this[x];this[x]=q-F[f.side].value;var w=d.Axis.prototype.getPlotLinePath.apply(this,arguments);this[x]=q;return w}:(f.setAxisSize(),f.setAxisTranslation())})}});E(f,"render",function(){this.scrollablePixelsX||this.scrollablePixelsY?(this.setUpScrolling&&this.setUpScrolling(),this.applyFixed()):this.fixedDiv&&this.applyFixed()});f.prototype.setUpScrolling=function(){var d=
this,f={WebkitOverflowScrolling:"touch",overflowX:"hidden",overflowY:"hidden"};this.scrollablePixelsX&&(f.overflowX="auto");this.scrollablePixelsY&&(f.overflowY="auto");this.scrollingContainer=q("div",{className:"highcharts-scrolling"},f,this.renderTo);E(this.scrollingContainer,"scroll",function(){d.pointer&&delete d.pointer.chartPosition});this.innerContainer=q("div",{className:"highcharts-inner-container"},null,this.scrollingContainer);this.innerContainer.appendChild(this.container);this.setUpScrolling=
null};f.prototype.moveFixedElements=function(){var d=this.container,f=this.fixedRenderer,x=".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),q;this.scrollablePixelsX&&!this.inverted?q=".highcharts-yaxis":this.scrollablePixelsX&&this.inverted?q=".highcharts-xaxis":
this.scrollablePixelsY&&!this.inverted?q=".highcharts-xaxis":this.scrollablePixelsY&&this.inverted&&(q=".highcharts-yaxis");x.push(q,q+"-labels");x.forEach(function(x){[].forEach.call(d.querySelectorAll(x),function(d){(d.namespaceURI===f.SVG_NS?f.box:f.box.parentNode).appendChild(d);d.style.pointerEvents="auto"})})};f.prototype.applyFixed=function(){var f,L,x=!this.fixedDiv,F=this.options.chart.scrollablePlotArea;x?(this.fixedDiv=q("div",{className:"highcharts-fixed"},{position:"absolute",overflow:"hidden",
pointerEvents:"none",zIndex:2},null,!0),this.renderTo.insertBefore(this.fixedDiv,this.renderTo.firstChild),this.renderTo.style.overflow="visible",this.fixedRenderer=L=new d.Renderer(this.fixedDiv,this.chartWidth,this.chartHeight,null===(f=this.options.chart)||void 0===f?void 0:f.style),this.scrollableMask=L.path().attr({fill:this.options.chart.backgroundColor||"#fff","fill-opacity":A(F.opacity,.85),zIndex:-1}).addClass("highcharts-scrollable-mask").add(),this.moveFixedElements(),E(this,"afterShowResetZoom",
this.moveFixedElements),E(this,"afterLayOutTitles",this.moveFixedElements)):this.fixedRenderer.setSize(this.chartWidth,this.chartHeight);f=this.chartWidth+(this.scrollablePixelsX||0);L=this.chartHeight+(this.scrollablePixelsY||0);K(this.container);this.container.style.width=f+"px";this.container.style.height=L+"px";this.renderer.boxWrapper.attr({width:f,height:L,viewBox:[0,0,f,L].join(" ")});this.chartBackground.attr({width:f,height:L});this.scrollingContainer.style.height=this.chartHeight+"px";x&&
(F.scrollPositionX&&(this.scrollingContainer.scrollLeft=this.scrollablePixelsX*F.scrollPositionX),F.scrollPositionY&&(this.scrollingContainer.scrollTop=this.scrollablePixelsY*F.scrollPositionY));L=this.axisOffset;x=this.plotTop-L[0]-1;F=this.plotLeft-L[3]-1;f=this.plotTop+this.plotHeight+L[2]+1;L=this.plotLeft+this.plotWidth+L[1]+1;var H=this.plotLeft+this.plotWidth-(this.scrollablePixelsX||0),C=this.plotTop+this.plotHeight-(this.scrollablePixelsY||0);x=this.scrollablePixelsX?[["M",0,x],["L",this.plotLeft-
1,x],["L",this.plotLeft-1,f],["L",0,f],["Z"],["M",H,x],["L",this.chartWidth,x],["L",this.chartWidth,f],["L",H,f],["Z"]]:this.scrollablePixelsY?[["M",F,0],["L",F,this.plotTop-1],["L",L,this.plotTop-1],["L",L,0],["Z"],["M",F,C],["L",F,this.chartHeight],["L",L,this.chartHeight],["L",L,C],["Z"]]:[["M",0,0]];"adjustHeight"!==this.redrawTrigger&&this.scrollableMask.attr({d:x})}});Q(A,"parts/StackingAxis.js",[A["parts/Utilities.js"]],function(d){var f=d.addEvent,E=d.destroyObjectProperties,q=d.fireEvent,
A=d.objectEach,K=d.pick,J=function(){function d(d){this.oldStacks={};this.stacks={};this.stacksTouched=0;this.axis=d}d.prototype.buildStacks=function(){var d=this.axis,f=d.series,H=K(d.options.reversedStacks,!0),C=f.length,D;if(!d.isXAxis){this.usePercentage=!1;for(D=C;D--;){var w=f[H?D:C-D-1];w.setStackedPoints()}for(D=0;D<C;D++)f[D].modifyStacks();q(d,"afterBuildStacks")}};d.prototype.cleanStacks=function(){if(!this.axis.isXAxis){if(this.oldStacks)var d=this.stacks=this.oldStacks;A(d,function(d){A(d,
function(d){d.cumulative=d.total})})}};d.prototype.resetStacks=function(){var d=this,f=d.stacks;d.axis.isXAxis||A(f,function(f){A(f,function(q,x){q.touched<d.stacksTouched?(q.destroy(),delete f[x]):(q.total=null,q.cumulative=null)})})};d.prototype.renderStackTotals=function(){var d=this.axis.chart,f=d.renderer,q=this.stacks,C=this.stackTotalGroup=this.stackTotalGroup||f.g("stack-labels").attr({visibility:"visible",zIndex:6}).add();C.translate(d.plotLeft,d.plotTop);A(q,function(d){A(d,function(d){d.render(C)})})};
return d}();return function(){function d(){}d.compose=function(q){f(q,"init",d.onInit);f(q,"destroy",d.onDestroy)};d.onDestroy=function(){var d=this.stacking;if(d){var f=d.stacks;A(f,function(d,q){E(d);f[q]=null});d&&d.stackTotalGroup&&d.stackTotalGroup.destroy()}};d.onInit=function(){this.stacking||(this.stacking=new J(this))};return d}()});Q(A,"mixins/legend-symbol.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var E=f.merge,q=f.pick;d.LegendSymbolMixin={drawRectangle:function(d,
f){var E=d.symbolHeight,A=d.options.squareSymbol;f.legendSymbol=this.chart.renderer.rect(A?(d.symbolWidth-E)/2:0,d.baseline-E+1,A?E:d.symbolWidth,E,q(d.options.symbolRadius,E/2)).addClass("highcharts-point").attr({zIndex:3}).add(f.legendGroup)},drawLineMarker:function(d){var f=this.options,A=f.marker,L=d.symbolWidth,x=d.symbolHeight,F=x/2,H=this.chart.renderer,C=this.legendGroup;d=d.baseline-Math.round(.3*d.fontMetrics.b);var D={};this.chart.styledMode||(D={"stroke-width":f.lineWidth||0},f.dashStyle&&
(D.dashstyle=f.dashStyle));this.legendLine=H.path(["M",0,d,"L",L,d]).addClass("highcharts-graph").attr(D).add(C);A&&!1!==A.enabled&&L&&(f=Math.min(q(A.radius,F),F),0===this.symbol.indexOf("url")&&(A=E(A,{width:x,height:x}),f=0),this.legendSymbol=A=H.symbol(this.symbol,L/2-f,d-f,2*f,2*f,A).addClass("highcharts-point").add(C),A.isMarker=!0)}};return d.LegendSymbolMixin});Q(A,"parts/Point.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){"";var A=f.animObject,q=f.defined,M=f.erase,K=
f.extend,J=f.fireEvent,L=f.format,x=f.getNestedProperty,F=f.isArray,H=f.isNumber,C=f.isObject,D=f.syncTimeout,w=f.pick,n=f.removeEvent,t=f.uniqueKey;f=function(){function d(){this.colorIndex=this.category=void 0;this.formatPrefix="point";this.id=void 0;this.isNull=!1;this.percentage=this.options=this.name=void 0;this.selected=!1;this.total=this.series=void 0;this.visible=!0;this.x=void 0}d.prototype.animateBeforeDestroy=function(){var d=this,b={x:d.startXPos,opacity:0},g,f=d.getGraphicalProps();f.singular.forEach(function(f){g=
"dataLabel"===f;d[f]=d[f].animate(g?{x:d[f].startXPos,y:d[f].startYPos,opacity:0}:b)});f.plural.forEach(function(b){d[b].forEach(function(b){b.element&&b.animate(K({x:d.startXPos},b.startYPos?{x:b.startXPos,y:b.startYPos}:{}))})})};d.prototype.applyOptions=function(f,b){var g=this.series,m=g.options.pointValKey||g.pointValKey;f=d.prototype.optionsToObject.call(this,f);K(this,f);this.options=this.options?K(this.options,f):f;f.group&&delete this.group;f.dataLabels&&delete this.dataLabels;m&&(this.y=
d.prototype.getNestedProperty.call(this,m));this.formatPrefix=(this.isNull=w(this.isValid&&!this.isValid(),null===this.x||!H(this.y)))?"null":"point";this.selected&&(this.state="select");"name"in this&&"undefined"===typeof b&&g.xAxis&&g.xAxis.hasNames&&(this.x=g.xAxis.nameToX(this));"undefined"===typeof this.x&&g&&(this.x="undefined"===typeof b?g.autoIncrement(this):b);return this};d.prototype.destroy=function(){function d(){if(b.graphic||b.dataLabel||b.dataLabels)n(b),b.destroyElements();for(p in b)b[p]=
null}var b=this,g=b.series,f=g.chart;g=g.options.dataSorting;var h=f.hoverPoints,e=A(b.series.chart.renderer.globalAnimation),p;b.legendItem&&f.legend.destroyItem(b);h&&(b.setState(),M(h,b),h.length||(f.hoverPoints=null));if(b===f.hoverPoint)b.onMouseOut();g&&g.enabled?(this.animateBeforeDestroy(),D(d,e.duration)):d();f.pointCount--};d.prototype.destroyElements=function(d){var b=this;d=b.getGraphicalProps(d);d.singular.forEach(function(d){b[d]=b[d].destroy()});d.plural.forEach(function(d){b[d].forEach(function(b){b.element&&
b.destroy()});delete b[d]})};d.prototype.firePointEvent=function(d,b,g){var f=this,h=this.series.options;(h.point.events[d]||f.options&&f.options.events&&f.options.events[d])&&f.importEvents();"click"===d&&h.allowPointSelect&&(g=function(b){f.select&&f.select(null,b.ctrlKey||b.metaKey||b.shiftKey)});J(f,d,b,g)};d.prototype.getClassName=function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":"")+
("undefined"!==typeof this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")};d.prototype.getGraphicalProps=function(d){var b=this,g=[],f,h={singular:[],plural:[]};d=d||{graphic:1,dataLabel:1};d.graphic&&g.push("graphic","shadowGroup");d.dataLabel&&g.push("dataLabel","dataLabelUpper","connector");for(f=g.length;f--;){var e=g[f];b[e]&&h.singular.push(e)}["dataLabel",
"connector"].forEach(function(e){var g=e+"s";d[e]&&b[g]&&h.plural.push(g)});return h};d.prototype.getLabelConfig=function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}};d.prototype.getNestedProperty=function(d){if(d)return 0===d.indexOf("custom.")?x(d,this.options):this[d]};d.prototype.getZone=function(){var d=this.series,b=d.zones;d=d.zoneAxis||
"y";var g=0,f;for(f=b[g];this[d]>=f.value;)f=b[++g];this.nonZonedColor||(this.nonZonedColor=this.color);this.color=f&&f.color&&!this.options.color?f.color:this.nonZonedColor;return f};d.prototype.hasNewShapeType=function(){return(this.graphic&&(this.graphic.symbolName||this.graphic.element.nodeName))!==this.shapeType};d.prototype.init=function(d,b,g){this.series=d;this.applyOptions(b,g);this.id=q(this.id)?this.id:t();this.resolveColor();d.chart.pointCount++;J(this,"afterInit");return this};d.prototype.optionsToObject=
function(f){var b={},g=this.series,m=g.options.keys,h=m||g.pointArrayMap||["y"],e=h.length,p=0,l=0;if(H(f)||null===f)b[h[0]]=f;else if(F(f))for(!m&&f.length>e&&(g=typeof f[0],"string"===g?b.name=f[0]:"number"===g&&(b.x=f[0]),p++);l<e;)m&&"undefined"===typeof f[p]||(0<h[l].indexOf(".")?d.prototype.setNestedProperty(b,f[p],h[l]):b[h[l]]=f[p]),p++,l++;else"object"===typeof f&&(b=f,f.dataLabels&&(g._hasPointLabels=!0),f.marker&&(g._hasPointMarkers=!0));return b};d.prototype.resolveColor=function(){var d=
this.series;var b=d.chart.options.chart.colorCount;var g=d.chart.styledMode;delete this.nonZonedColor;g||this.options.color||(this.color=d.color);d.options.colorByPoint?(g||(b=d.options.colors||d.chart.options.colors,this.color=this.color||b[d.colorCounter],b=b.length),g=d.colorCounter,d.colorCounter++,d.colorCounter===b&&(d.colorCounter=0)):g=d.colorIndex;this.colorIndex=w(this.colorIndex,g)};d.prototype.setNestedProperty=function(d,b,g){g.split(".").reduce(function(d,g,e,f){d[g]=f.length-1===e?
b:C(d[g],!0)?d[g]:{};return d[g]},d);return d};d.prototype.tooltipFormatter=function(d){var b=this.series,g=b.tooltipOptions,f=w(g.valueDecimals,""),h=g.valuePrefix||"",e=g.valueSuffix||"";b.chart.styledMode&&(d=b.chart.tooltip.styledModeFormat(d));(b.pointArrayMap||["y"]).forEach(function(b){b="{point."+b;if(h||e)d=d.replace(RegExp(b+"}","g"),h+b+"}"+e);d=d.replace(RegExp(b+"}","g"),b+":,."+f+"f}")});return L(d,{point:this,series:this.series},b.chart)};return d}();d.Point=f;return d.Point});Q(A,
"parts/Series.js",[A["mixins/legend-symbol.js"],A["parts/Globals.js"],A["parts/Point.js"],A["parts/Utilities.js"]],function(d,f,A,q){"";var E=q.addEvent,K=q.animObject,J=q.arrayMax,L=q.arrayMin,x=q.clamp,F=q.correctFloat,H=q.defined,C=q.erase,D=q.error,w=q.extend,n=q.find,t=q.fireEvent,N=q.getNestedProperty,m=q.isArray,b=q.isFunction,g=q.isNumber,v=q.isString,h=q.merge,e=q.objectEach,p=q.pick,l=q.removeEvent,I=q.seriesType,u=q.splat,y=q.syncTimeout,G=f.defaultOptions,S=f.defaultPlotOptions,R=f.seriesTypes,
B=f.SVGElement,c=f.win;f.Series=I("line",null,{lineWidth:2,allowPointSelect:!1,crisp:!0,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{enabledThreshold:2,lineColor:"#ffffff",lineWidth:0,radius:4,states:{normal:{animation:!0},hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){var a=this.series.chart.numberFormatter;return"number"!==typeof this.y?
"":a(this.y,-1)},padding:5,style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0},cropThreshold:300,opacity:1,pointRange:0,softThreshold:!0,states:{normal:{animation:!0},hover:{animation:{duration:50},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},inactive:{animation:{duration:50},opacity:.2}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:"x"},{axisTypes:["xAxis","yAxis"],coll:"series",
colorCounter:0,cropShoulder:1,directTouch:!1,eventsToUnbind:[],isCartesian:!0,parallelArrays:["x","y"],pointClass:A,requireSorting:!0,sorted:!0,init:function(a,c){t(this,"init",{options:c});var d=this,k=a.series,g;this.eventOptions=this.eventOptions||{};d.chart=a;d.options=c=d.setOptions(c);d.linkedSeries=[];d.bindAxes();w(d,{name:c.name,state:"",visible:!1!==c.visible,selected:!0===c.selected});var f=c.events;e(f,function(a,c){b(a)&&d.eventOptions[c]!==a&&(b(d.eventOptions[c])&&l(d,c,d.eventOptions[c]),
d.eventOptions[c]=a,E(d,c,a))});if(f&&f.click||c.point&&c.point.events&&c.point.events.click||c.allowPointSelect)a.runTrackerClick=!0;d.getColor();d.getSymbol();d.parallelArrays.forEach(function(a){d[a+"Data"]||(d[a+"Data"]=[])});d.isCartesian&&(a.hasCartesianSeries=!0);k.length&&(g=k[k.length-1]);d._i=p(g&&g._i,-1)+1;a.orderSeries(this.insert(k));c.dataSorting&&c.dataSorting.enabled?d.setDataSortingOptions():d.points||d.data||d.setData(c.data,!1);t(this,"afterInit")},is:function(a){return R[a]&&
this instanceof R[a]},insert:function(a){var c=this.options.index,b;if(g(c)){for(b=a.length;b--;)if(c>=p(a[b].options.index,a[b]._i)){a.splice(b+1,0,this);break}-1===b&&a.unshift(this);b+=1}else a.push(this);return p(b,a.length-1)},bindAxes:function(){var a=this,c=a.options,b=a.chart,e;t(this,"bindAxes",null,function(){(a.axisTypes||[]).forEach(function(d){b[d].forEach(function(b){e=b.options;if(c[d]===e.index||"undefined"!==typeof c[d]&&c[d]===e.id||"undefined"===typeof c[d]&&0===e.index)a.insert(b.series),
a[d]=b,b.isDirty=!0});a[d]||a.optionalAxis===d||D(18,!0,b)})});t(this,"afterBindAxes")},updateParallelArrays:function(a,c){var b=a.series,e=arguments,d=g(c)?function(e){var d="y"===e&&b.toYData?b.toYData(a):a[e];b[e+"Data"][c]=d}:function(a){Array.prototype[c].apply(b[a+"Data"],Array.prototype.slice.call(e,2))};b.parallelArrays.forEach(d)},hasData:function(){return this.visible&&"undefined"!==typeof this.dataMax&&"undefined"!==typeof this.dataMin||this.visible&&this.yData&&0<this.yData.length},autoIncrement:function(){var a=
this.options,c=this.xIncrement,b,e=a.pointIntervalUnit,d=this.chart.time;c=p(c,a.pointStart,0);this.pointInterval=b=p(this.pointInterval,a.pointInterval,1);e&&(a=new d.Date(c),"day"===e?d.set("Date",a,d.get("Date",a)+b):"month"===e?d.set("Month",a,d.get("Month",a)+b):"year"===e&&d.set("FullYear",a,d.get("FullYear",a)+b),b=a.getTime()-c);this.xIncrement=c+b;return c},setDataSortingOptions:function(){var a=this.options;w(this,{requireSorting:!1,sorted:!1,enabledDataSorting:!0,allowDG:!1});H(a.pointRange)||
(a.pointRange=1)},setOptions:function(a){var c=this.chart,b=c.options,e=b.plotOptions,d=c.userOptions||{};a=h(a);c=c.styledMode;var g={plotOptions:e,userOptions:a};t(this,"setOptions",g);var l=g.plotOptions[this.type],f=d.plotOptions||{};this.userOptions=g.userOptions;d=h(l,e.series,d.plotOptions&&d.plotOptions[this.type],a);this.tooltipOptions=h(G.tooltip,G.plotOptions.series&&G.plotOptions.series.tooltip,G.plotOptions[this.type].tooltip,b.tooltip.userOptions,e.series&&e.series.tooltip,e[this.type].tooltip,
a.tooltip);this.stickyTracking=p(a.stickyTracking,f[this.type]&&f[this.type].stickyTracking,f.series&&f.series.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?!0:d.stickyTracking);null===l.marker&&delete d.marker;this.zoneAxis=d.zoneAxis;b=this.zones=(d.zones||[]).slice();!d.negativeColor&&!d.negativeFillColor||d.zones||(e={value:d[this.zoneAxis+"Threshold"]||d.threshold||0,className:"highcharts-negative"},c||(e.color=d.negativeColor,e.fillColor=d.negativeFillColor),b.push(e));b.length&&
H(b[b.length-1].value)&&b.push(c?{}:{color:this.color,fillColor:this.fillColor});t(this,"afterSetOptions",{options:d});return d},getName:function(){return p(this.options.name,"Series "+(this.index+1))},getCyclic:function(a,c,b){var e=this.chart,d=this.userOptions,k=a+"Index",g=a+"Counter",l=b?b.length:p(e.options.chart[a+"Count"],e[a+"Count"]);if(!c){var f=p(d[k],d["_"+k]);H(f)||(e.series.length||(e[g]=0),d["_"+k]=f=e[g]%l,e[g]+=1);b&&(c=b[f])}"undefined"!==typeof f&&(this[k]=f);this[a]=c},getColor:function(){this.chart.styledMode?
this.getCyclic("color"):this.options.colorByPoint?this.options.color=null:this.getCyclic("color",this.options.color||S[this.type].color,this.chart.options.colors)},getPointsCollection:function(){return(this.hasGroupedData?this.points:this.data)||[]},getSymbol:function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)},findPointIndex:function(a,c){var b=a.id,e=a.x,d=this.points,k,l=this.options.dataSorting;if(b)var f=this.chart.get(b);else if(this.linkedParent||this.enabledDataSorting){var h=
l&&l.matchByName?"name":"index";f=n(d,function(c){return!c.touched&&c[h]===a[h]});if(!f)return}if(f){var m=f&&f.index;"undefined"!==typeof m&&(k=!0)}"undefined"===typeof m&&g(e)&&(m=this.xData.indexOf(e,c));-1!==m&&"undefined"!==typeof m&&this.cropped&&(m=m>=this.cropStart?m-this.cropStart:m);!k&&d[m]&&d[m].touched&&(m=void 0);return m},drawLegendSymbol:d.drawLineMarker,updateData:function(a,c){var b=this.options,e=b.dataSorting,d=this.points,k=[],l,f,h,m=this.requireSorting,u=a.length===d.length,
p=!0;this.xIncrement=null;a.forEach(function(a,c){var f=H(a)&&this.pointClass.prototype.optionsToObject.call({series:this},a)||{};var r=f.x;if(f.id||g(r)){if(r=this.findPointIndex(f,h),-1===r||"undefined"===typeof r?k.push(a):d[r]&&a!==b.data[r]?(d[r].update(a,!1,null,!1),d[r].touched=!0,m&&(h=r+1)):d[r]&&(d[r].touched=!0),!u||c!==r||e&&e.enabled||this.hasDerivedData)l=!0}else k.push(a)},this);if(l)for(a=d.length;a--;)(f=d[a])&&!f.touched&&f.remove&&f.remove(!1,c);else!u||e&&e.enabled?p=!1:(a.forEach(function(a,
c){d[c].update&&a!==d[c].y&&d[c].update(a,!1,null,!1)}),k.length=0);d.forEach(function(a){a&&(a.touched=!1)});if(!p)return!1;k.forEach(function(a){this.addPoint(a,!1,null,null,!1)},this);null===this.xIncrement&&this.xData&&this.xData.length&&(this.xIncrement=J(this.xData),this.autoIncrement());return!0},setData:function(a,c,b,e){var d=this,k=d.points,l=k&&k.length||0,f,h=d.options,r=d.chart,u=h.dataSorting,n=null,z=d.xAxis;n=h.turboThreshold;var y=this.xData,w=this.yData,t=(f=d.pointArrayMap)&&f.length,
B=h.keys,G=0,q=1,x;a=a||[];f=a.length;c=p(c,!0);u&&u.enabled&&(a=this.sortData(a));!1!==e&&f&&l&&!d.cropped&&!d.hasGroupedData&&d.visible&&!d.isSeriesBoosting&&(x=this.updateData(a,b));if(!x){d.xIncrement=null;d.colorCounter=0;this.parallelArrays.forEach(function(a){d[a+"Data"].length=0});if(n&&f>n)if(n=d.getFirstValidPoint(a),g(n))for(b=0;b<f;b++)y[b]=this.autoIncrement(),w[b]=a[b];else if(m(n))if(t)for(b=0;b<f;b++)e=a[b],y[b]=e[0],w[b]=e.slice(1,t+1);else for(B&&(G=B.indexOf("x"),q=B.indexOf("y"),
G=0<=G?G:0,q=0<=q?q:1),b=0;b<f;b++)e=a[b],y[b]=e[G],w[b]=e[q];else D(12,!1,r);else for(b=0;b<f;b++)"undefined"!==typeof a[b]&&(e={series:d},d.pointClass.prototype.applyOptions.apply(e,[a[b]]),d.updateParallelArrays(e,b));w&&v(w[0])&&D(14,!0,r);d.data=[];d.options.data=d.userOptions.data=a;for(b=l;b--;)k[b]&&k[b].destroy&&k[b].destroy();z&&(z.minRange=z.userMinRange);d.isDirty=r.isDirtyBox=!0;d.isDirtyData=!!k;b=!1}"point"===h.legendType&&(this.processData(),this.generatePoints());c&&r.redraw(b)},
sortData:function(a){var c=this,b=c.options.dataSorting.sortKey||"y",e=function(a,c){return H(c)&&a.pointClass.prototype.optionsToObject.call({series:a},c)||{}};a.forEach(function(b,d){a[d]=e(c,b);a[d].index=d},this);a.concat().sort(function(a,c){a=N(b,a);c=N(b,c);return c<a?-1:c>a?1:0}).forEach(function(a,c){a.x=c},this);c.linkedSeries&&c.linkedSeries.forEach(function(c){var b=c.options,d=b.data;b.dataSorting&&b.dataSorting.enabled||!d||(d.forEach(function(b,k){d[k]=e(c,b);a[k]&&(d[k].x=a[k].x,d[k].index=
k)}),c.setData(d,!1))});return a},getProcessedData:function(a){var c=this.xData,b=this.yData,e=c.length;var d=0;var g=this.xAxis,f=this.options;var l=f.cropThreshold;var h=a||this.getExtremesFromAll||f.getExtremesFromAll,m=this.isCartesian;a=g&&g.val2lin;f=!(!g||!g.logarithmic);var u=this.requireSorting;if(g){g=g.getExtremes();var p=g.min;var n=g.max}if(m&&this.sorted&&!h&&(!l||e>l||this.forceCrop))if(c[e-1]<p||c[0]>n)c=[],b=[];else if(this.yData&&(c[0]<p||c[e-1]>n)){d=this.cropData(this.xData,this.yData,
p,n);c=d.xData;b=d.yData;d=d.start;var v=!0}for(l=c.length||1;--l;)if(e=f?a(c[l])-a(c[l-1]):c[l]-c[l-1],0<e&&("undefined"===typeof y||e<y))var y=e;else 0>e&&u&&(D(15,!1,this.chart),u=!1);return{xData:c,yData:b,cropped:v,cropStart:d,closestPointRange:y}},processData:function(a){var c=this.xAxis;if(this.isCartesian&&!this.isDirty&&!c.isDirty&&!this.yAxis.isDirty&&!a)return!1;a=this.getProcessedData();this.cropped=a.cropped;this.cropStart=a.cropStart;this.processedXData=a.xData;this.processedYData=a.yData;
this.closestPointRange=this.basePointRange=a.closestPointRange},cropData:function(a,c,b,e,d){var g=a.length,k=0,l=g,f;d=p(d,this.cropShoulder);for(f=0;f<g;f++)if(a[f]>=b){k=Math.max(0,f-d);break}for(b=f;b<g;b++)if(a[b]>e){l=b+d;break}return{xData:a.slice(k,l),yData:c.slice(k,l),start:k,end:l}},generatePoints:function(){var a=this.options,c=a.data,b=this.data,e,d=this.processedXData,g=this.processedYData,f=this.pointClass,l=d.length,h=this.cropStart||0,m=this.hasGroupedData;a=a.keys;var p=[],n;b||
m||(b=[],b.length=c.length,b=this.data=b);a&&m&&(this.options.keys=!1);for(n=0;n<l;n++){var v=h+n;if(m){var y=(new f).init(this,[d[n]].concat(u(g[n])));y.dataGroup=this.groupMap[n];y.dataGroup.options&&(y.options=y.dataGroup.options,w(y,y.dataGroup.options),delete y.dataLabels)}else(y=b[v])||"undefined"===typeof c[v]||(b[v]=y=(new f).init(this,c[v],d[n]));y&&(y.index=v,p[n]=y)}this.options.keys=a;if(b&&(l!==(e=b.length)||m))for(n=0;n<e;n++)n!==h||m||(n+=l),b[n]&&(b[n].destroyElements(),b[n].plotX=
void 0);this.data=b;this.points=p;t(this,"afterGeneratePoints")},getXExtremes:function(a){return{min:L(a),max:J(a)}},getExtremes:function(a,c){var b=this.xAxis,e=this.yAxis,d=this.processedXData||this.xData,k=[],l=0,f=0;var h=0;var u=this.requireSorting?this.cropShoulder:0,n=e?e.positiveValuesOnly:!1,p;a=a||this.stackedYData||this.processedYData||[];e=a.length;b&&(h=b.getExtremes(),f=h.min,h=h.max);for(p=0;p<e;p++){var v=d[p];var y=a[p];var w=(g(y)||m(y))&&(y.length||0<y||!n);v=c||this.getExtremesFromAll||
this.options.getExtremesFromAll||this.cropped||!b||(d[p+u]||v)>=f&&(d[p-u]||v)<=h;if(w&&v)if(w=y.length)for(;w--;)g(y[w])&&(k[l++]=y[w]);else k[l++]=y}a={dataMin:L(k),dataMax:J(k)};t(this,"afterGetExtremes",{dataExtremes:a});return a},applyExtremes:function(){var a=this.getExtremes();this.dataMin=a.dataMin;this.dataMax=a.dataMax;return a},getFirstValidPoint:function(a){for(var c=null,b=a.length,e=0;null===c&&e<b;)c=a[e],e++;return c},translate:function(){this.processedXData||this.processData();this.generatePoints();
var a=this.options,c=a.stacking,b=this.xAxis,e=b.categories,d=this.enabledDataSorting,l=this.yAxis,f=this.points,h=f.length,u=!!this.modifyValue,n,v=this.pointPlacementToXValue(),y=!!v,w=a.threshold,B=a.startFromThreshold?w:0,G,q=this.zoneAxis||"y",I=Number.MAX_VALUE;for(n=0;n<h;n++){var C=f[n],D=C.x,R=C.y,S=C.low,A=c&&l.stacking&&l.stacking.stacks[(this.negStacks&&R<(B?0:w)?"-":"")+this.stackKey];l.positiveValuesOnly&&null!==R&&0>=R&&(C.isNull=!0);C.plotX=G=F(x(b.translate(D,0,0,0,1,v,"flags"===
this.type),-1E5,1E5));if(c&&this.visible&&A&&A[D]){var E=this.getStackIndicator(E,D,this.index);if(!C.isNull){var N=A[D];var L=N.points[E.key]}}m(L)&&(S=L[0],R=L[1],S===B&&E.key===A[D].base&&(S=p(g(w)&&w,l.min)),l.positiveValuesOnly&&0>=S&&(S=null),C.total=C.stackTotal=N.total,C.percentage=N.total&&C.y/N.total*100,C.stackY=R,this.irregularWidths||N.setOffset(this.pointXOffset||0,this.barW||0));C.yBottom=H(S)?x(l.translate(S,0,1,0,1),-1E5,1E5):null;u&&(R=this.modifyValue(R,C));C.plotY="number"===typeof R&&
Infinity!==R?x(l.translate(R,0,1,0,1),-1E5,1E5):void 0;C.isInside=this.isPointInside(C);C.clientX=y?F(b.translate(D,0,0,0,1,v)):G;C.negative=C[q]<(a[q+"Threshold"]||w||0);C.category=e&&"undefined"!==typeof e[C.x]?e[C.x]:C.x;if(!C.isNull&&!1!==C.visible){"undefined"!==typeof J&&(I=Math.min(I,Math.abs(G-J)));var J=G}C.zone=this.zones.length&&C.getZone();!C.graphic&&this.group&&d&&(C.isNew=!0)}this.closestPointRangePx=I;t(this,"afterTranslate")},getValidPoints:function(a,c,b){var e=this.chart;return(a||
this.points||[]).filter(function(a){return c&&!e.isInsidePlot(a.plotX,a.plotY,e.inverted)?!1:!1!==a.visible&&(b||!a.isNull)})},getClipBox:function(a,c){var b=this.options,e=this.chart,d=e.inverted,g=this.xAxis,k=g&&this.yAxis;a&&!1===b.clip&&k?a=d?{y:-e.chartWidth+k.len+k.pos,height:e.chartWidth,width:e.chartHeight,x:-e.chartHeight+g.len+g.pos}:{y:-k.pos,height:e.chartHeight,width:e.chartWidth,x:-g.pos}:(a=this.clipBox||e.clipBox,c&&(a.width=e.plotSizeX,a.x=0));return c?{width:a.width,x:a.x}:a},setClip:function(a){var c=
this.chart,b=this.options,e=c.renderer,d=c.inverted,g=this.clipBox,l=this.getClipBox(a),f=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,l.height,b.xAxis,b.yAxis].join(),h=c[f],m=c[f+"m"];a&&(l.width=0,d&&(l.x=c.plotHeight+(!1!==b.clip?0:c.plotTop)));h?c.hasLoaded||h.attr(l):(a&&(c[f+"m"]=m=e.clipRect(d?c.plotSizeX+99:-99,d?-c.plotLeft:-c.plotTop,99,d?c.chartWidth:c.chartHeight)),c[f]=h=e.clipRect(l),h.count={length:0});a&&!h.count[this.index]&&(h.count[this.index]=!0,h.count.length+=
1);if(!1!==b.clip||a)this.group.clip(a||g?h:c.clipRect),this.markerGroup.clip(m),this.sharedClipKey=f;a||(h.count[this.index]&&(delete h.count[this.index],--h.count.length),0===h.count.length&&f&&c[f]&&(g||(c[f]=c[f].destroy()),c[f+"m"]&&(c[f+"m"]=c[f+"m"].destroy())))},animate:function(a){var c=this.chart,b=K(this.options.animation);if(!c.hasRendered)if(a)this.setClip(b);else{var e=this.sharedClipKey;a=c[e];var d=this.getClipBox(b,!0);a&&a.animate(d,b);c[e+"m"]&&c[e+"m"].animate({width:d.width+99,
x:d.x-(c.inverted?0:99)},b)}},afterAnimate:function(){this.setClip();t(this,"afterAnimate");this.finishedAnimating=!0},drawPoints:function(){var a=this.points,c=this.chart,b,e,d=this.options.marker,g=this[this.specialGroup]||this.markerGroup,f=this.xAxis,l=p(d.enabled,!f||f.isRadial?!0:null,this.closestPointRangePx>=d.enabledThreshold*d.radius);if(!1!==d.enabled||this._hasPointMarkers)for(b=0;b<a.length;b++){var h=a[b];var m=(e=h.graphic)?"animate":"attr";var u=h.marker||{};var n=!!h.marker;if((l&&
"undefined"===typeof u.enabled||u.enabled)&&!h.isNull&&!1!==h.visible){var v=p(u.symbol,this.symbol);var y=this.markerAttribs(h,h.selected&&"select");this.enabledDataSorting&&(h.startXPos=f.reversed?-y.width:f.width);var w=!1!==h.isInside;e?e[w?"show":"hide"](w).animate(y):w&&(0<y.width||h.hasImage)&&(h.graphic=e=c.renderer.symbol(v,y.x,y.y,y.width,y.height,n?u:d).add(g),this.enabledDataSorting&&c.hasRendered&&(e.attr({x:h.startXPos}),m="animate"));e&&"animate"===m&&e[w?"show":"hide"](w).animate(y);
if(e&&!c.styledMode)e[m](this.pointAttribs(h,h.selected&&"select"));e&&e.addClass(h.getClassName(),!0)}else e&&(h.graphic=e.destroy())}},markerAttribs:function(a,c){var b=this.options,e=b.marker,d=a.marker||{},g=d.symbol||e.symbol,k=p(d.radius,e.radius);c&&(e=e.states[c],c=d.states&&d.states[c],k=p(c&&c.radius,e&&e.radius,k+(e&&e.radiusPlus||0)));a.hasImage=g&&0===g.indexOf("url");a.hasImage&&(k=0);a={x:b.crisp?Math.floor(a.plotX)-k:a.plotX-k,y:a.plotY-k};k&&(a.width=a.height=2*k);return a},pointAttribs:function(a,
c){var b=this.options.marker,e=a&&a.options,d=e&&e.marker||{},g=this.color,k=e&&e.color,f=a&&a.color;e=p(d.lineWidth,b.lineWidth);var l=a&&a.zone&&a.zone.color;a=1;g=k||l||f||g;k=d.fillColor||b.fillColor||g;g=d.lineColor||b.lineColor||g;c=c||"normal";b=b.states[c];c=d.states&&d.states[c]||{};e=p(c.lineWidth,b.lineWidth,e+p(c.lineWidthPlus,b.lineWidthPlus,0));k=c.fillColor||b.fillColor||k;g=c.lineColor||b.lineColor||g;a=p(c.opacity,b.opacity,a);return{stroke:g,"stroke-width":e,fill:k,opacity:a}},destroy:function(a){var b=
this,d=b.chart,g=/AppleWebKit\/533/.test(c.navigator.userAgent),f,l,h=b.data||[],m,u;t(b,"destroy");this.removeEvents(a);(b.axisTypes||[]).forEach(function(a){(u=b[a])&&u.series&&(C(u.series,b),u.isDirty=u.forceRedraw=!0)});b.legendItem&&b.chart.legend.destroyItem(b);for(l=h.length;l--;)(m=h[l])&&m.destroy&&m.destroy();b.points=null;q.clearTimeout(b.animationTimeout);e(b,function(a,c){a instanceof B&&!a.survive&&(f=g&&"group"===c?"hide":"destroy",a[f]())});d.hoverSeries===b&&(d.hoverSeries=null);
C(d.series,b);d.orderSeries();e(b,function(c,e){a&&"hcEvents"===e||delete b[e]})},getGraphPath:function(a,c,b){var e=this,d=e.options,g=d.step,k,f=[],l=[],h;a=a||e.points;(k=a.reversed)&&a.reverse();(g={right:1,center:2}[g]||g&&3)&&k&&(g=4-g);a=this.getValidPoints(a,!1,!(d.connectNulls&&!c&&!b));a.forEach(function(k,m){var u=k.plotX,r=k.plotY,n=a[m-1];(k.leftCliff||n&&n.rightCliff)&&!b&&(h=!0);k.isNull&&!H(c)&&0<m?h=!d.connectNulls:k.isNull&&!c?h=!0:(0===m||h?m=[["M",k.plotX,k.plotY]]:e.getPointSpline?
m=[e.getPointSpline(a,k,m)]:g?(m=1===g?[["L",n.plotX,r]]:2===g?[["L",(n.plotX+u)/2,n.plotY],["L",(n.plotX+u)/2,r]]:[["L",u,n.plotY]],m.push(["L",u,r])):m=[["L",u,r]],l.push(k.x),g&&(l.push(k.x),2===g&&l.push(k.x)),f.push.apply(f,m),h=!1)});f.xMap=l;return e.graphPath=f},drawGraph:function(){var a=this,c=this.options,b=(this.gappedPath||this.getGraphPath).call(this),e=this.chart.styledMode,d=[["graph","highcharts-graph"]];e||d[0].push(c.lineColor||this.color||"#cccccc",c.dashStyle);d=a.getZonesGraphs(d);
d.forEach(function(d,g){var k=d[0],f=a[k],l=f?"animate":"attr";f?(f.endX=a.preventGraphAnimation?null:b.xMap,f.animate({d:b})):b.length&&(a[k]=f=a.chart.renderer.path(b).addClass(d[1]).attr({zIndex:1}).add(a.group));f&&!e&&(k={stroke:d[2],"stroke-width":c.lineWidth,fill:a.fillGraph&&a.color||"none"},d[3]?k.dashstyle=d[3]:"square"!==c.linecap&&(k["stroke-linecap"]=k["stroke-linejoin"]="round"),f[l](k).shadow(2>g&&c.shadow));f&&(f.startX=b.xMap,f.isArea=b.isArea)})},getZonesGraphs:function(a){this.zones.forEach(function(c,
b){b=["zone-graph-"+b,"highcharts-graph highcharts-zone-graph-"+b+" "+(c.className||"")];this.chart.styledMode||b.push(c.color||this.color,c.dashStyle||this.options.dashStyle);a.push(b)},this);return a},applyZones:function(){var a=this,c=this.chart,b=c.renderer,e=this.zones,d,g,f=this.clips||[],l,h=this.graph,m=this.area,u=Math.max(c.chartWidth,c.chartHeight),n=this[(this.zoneAxis||"y")+"Axis"],v=c.inverted,y,w,t,B=!1,G,q;if(e.length&&(h||m)&&n&&"undefined"!==typeof n.min){var C=n.reversed;var I=
n.horiz;h&&!this.showLine&&h.hide();m&&m.hide();var D=n.getExtremes();e.forEach(function(e,k){d=C?I?c.plotWidth:0:I?0:n.toPixels(D.min)||0;d=x(p(g,d),0,u);g=x(Math.round(n.toPixels(p(e.value,D.max),!0)||0),0,u);B&&(d=g=n.toPixels(D.max));y=Math.abs(d-g);w=Math.min(d,g);t=Math.max(d,g);n.isXAxis?(l={x:v?t:w,y:0,width:y,height:u},I||(l.x=c.plotHeight-l.x)):(l={x:0,y:v?t:w,width:u,height:y},I&&(l.y=c.plotWidth-l.y));v&&b.isVML&&(l=n.isXAxis?{x:0,y:C?w:t,height:l.width,width:c.chartWidth}:{x:l.y-c.plotLeft-
c.spacingBox.x,y:0,width:l.height,height:c.chartHeight});f[k]?f[k].animate(l):f[k]=b.clipRect(l);G=a["zone-area-"+k];q=a["zone-graph-"+k];h&&q&&q.clip(f[k]);m&&G&&G.clip(f[k]);B=e.value>D.max;a.resetZones&&0===g&&(g=void 0)});this.clips=f}else a.visible&&(h&&h.show(!0),m&&m.show(!0))},invertGroups:function(a){function c(){["group","markerGroup"].forEach(function(c){b[c]&&(e.renderer.isVML&&b[c].attr({width:b.yAxis.len,height:b.xAxis.len}),b[c].width=b.yAxis.len,b[c].height=b.xAxis.len,b[c].invert(b.isRadialSeries?
!1:a))})}var b=this,e=b.chart;b.xAxis&&(b.eventsToUnbind.push(E(e,"resize",c)),c(),b.invertGroups=c)},plotGroup:function(a,c,b,e,d){var g=this[a],k=!g;k&&(this[a]=g=this.chart.renderer.g().attr({zIndex:e||.1}).add(d));g.addClass("highcharts-"+c+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(H(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(g.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0);g.attr({visibility:b})[k?"attr":
"animate"](this.getPlotBox());return g},getPlotBox:function(){var a=this.chart,c=this.xAxis,b=this.yAxis;a.inverted&&(c=b,b=this.xAxis);return{translateX:c?c.left:a.plotLeft,translateY:b?b.top:a.plotTop,scaleX:1,scaleY:1}},removeEvents:function(a){a?this.eventsToUnbind.length&&(this.eventsToUnbind.forEach(function(a){a()}),this.eventsToUnbind.length=0):l(this)},render:function(){var a=this,c=a.chart,b=a.options,e=!a.finishedAnimating&&c.renderer.isSVG&&K(b.animation).duration,d=a.visible?"inherit":
"hidden",g=b.zIndex,f=a.hasRendered,l=c.seriesGroup,h=c.inverted;t(this,"render");var m=a.plotGroup("group","series",d,g,l);a.markerGroup=a.plotGroup("markerGroup","markers",d,g,l);e&&a.animate&&a.animate(!0);m.inverted=a.isCartesian||a.invertable?h:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.visible&&a.drawPoints();a.drawDataLabels&&a.drawDataLabels();a.redrawPoints&&a.redrawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(h);!1===b.clip||a.sharedClipKey||
f||m.clip(c.clipRect);e&&a.animate&&a.animate();f||(a.animationTimeout=y(function(){a.afterAnimate()},e||0));a.isDirty=!1;a.hasRendered=!0;t(a,"afterRender")},redraw:function(){var a=this.chart,c=this.isDirty||this.isDirtyData,b=this.group,e=this.xAxis,d=this.yAxis;b&&(a.inverted&&b.attr({width:a.plotWidth,height:a.plotHeight}),b.animate({translateX:p(e&&e.left,a.plotLeft),translateY:p(d&&d.top,a.plotTop)}));this.translate();this.render();c&&delete this.kdTree},kdAxisArray:["clientX","plotY"],searchPoint:function(a,
c){var b=this.xAxis,e=this.yAxis,d=this.chart.inverted;return this.searchKDTree({clientX:d?b.len-a.chartY+b.pos:a.chartX-b.pos,plotY:d?e.len-a.chartX+e.pos:a.chartY-e.pos},c,a)},buildKDTree:function(a){function c(a,e,d){var g;if(g=a&&a.length){var k=b.kdAxisArray[e%d];a.sort(function(a,c){return a[k]-c[k]});g=Math.floor(g/2);return{point:a[g],left:c(a.slice(0,g),e+1,d),right:c(a.slice(g+1),e+1,d)}}}this.buildingKdTree=!0;var b=this,e=-1<b.options.findNearestPointBy.indexOf("y")?2:1;delete b.kdTree;
y(function(){b.kdTree=c(b.getValidPoints(null,!b.directTouch),e,e);b.buildingKdTree=!1},b.options.kdNow||a&&"touchstart"===a.type?0:1)},searchKDTree:function(a,c,b){function e(a,c,b,l){var h=c.point,m=d.kdAxisArray[b%l],u=h;var n=H(a[g])&&H(h[g])?Math.pow(a[g]-h[g],2):null;var p=H(a[k])&&H(h[k])?Math.pow(a[k]-h[k],2):null;p=(n||0)+(p||0);h.dist=H(p)?Math.sqrt(p):Number.MAX_VALUE;h.distX=H(n)?Math.sqrt(n):Number.MAX_VALUE;m=a[m]-h[m];p=0>m?"left":"right";n=0>m?"right":"left";c[p]&&(p=e(a,c[p],b+1,
l),u=p[f]<u[f]?p:h);c[n]&&Math.sqrt(m*m)<u[f]&&(a=e(a,c[n],b+1,l),u=a[f]<u[f]?a:u);return u}var d=this,g=this.kdAxisArray[0],k=this.kdAxisArray[1],f=c?"distX":"dist";c=-1<d.options.findNearestPointBy.indexOf("y")?2:1;this.kdTree||this.buildingKdTree||this.buildKDTree(b);if(this.kdTree)return e(a,this.kdTree,c,c)},pointPlacementToXValue:function(){var a=this.options,c=a.pointRange,b=this.xAxis;a=a.pointPlacement;"between"===a&&(a=b.reversed?-.5:.5);return g(a)?a*p(c,b.pointRange):0},isPointInside:function(a){return"undefined"!==
typeof a.plotY&&"undefined"!==typeof a.plotX&&0<=a.plotY&&a.plotY<=this.yAxis.len&&0<=a.plotX&&a.plotX<=this.xAxis.len}});""});Q(A,"parts/Stacking.js",[A["parts/Axis.js"],A["parts/Globals.js"],A["parts/StackingAxis.js"],A["parts/Utilities.js"]],function(d,f,A,q){var E=q.correctFloat,K=q.defined,J=q.destroyObjectProperties,L=q.format,x=q.pick;"";q=f.Chart;var F=f.Series,H=function(){function d(d,f,n,t,q){var m=d.chart.inverted;this.axis=d;this.isNegative=n;this.options=f=f||{};this.x=t;this.total=
null;this.points={};this.stack=q;this.rightCliff=this.leftCliff=0;this.alignOptions={align:f.align||(m?n?"left":"right":"center"),verticalAlign:f.verticalAlign||(m?"middle":n?"bottom":"top"),y:f.y,x:f.x};this.textAlign=f.textAlign||(m?n?"right":"left":"center")}d.prototype.destroy=function(){J(this,this.axis)};d.prototype.render=function(d){var f=this.axis.chart,n=this.options,t=n.format;t=t?L(t,this,f):n.formatter.call(this);this.label?this.label.attr({text:t,visibility:"hidden"}):(this.label=f.renderer.label(t,
null,null,n.shape,null,null,n.useHTML,!1,"stack-labels"),t={r:n.borderRadius||0,text:t,rotation:n.rotation,padding:x(n.padding,5),visibility:"hidden"},f.styledMode||(t.fill=n.backgroundColor,t.stroke=n.borderColor,t["stroke-width"]=n.borderWidth,this.label.css(n.style)),this.label.attr(t),this.label.added||this.label.add(d));this.label.labelrank=f.plotHeight};d.prototype.setOffset=function(d,f,n,t,q){var m=this.axis,b=m.chart;t=m.translate(m.stacking.usePercentage?100:t?t:this.total,0,0,0,1);n=m.translate(n?
n:0);n=K(t)&&Math.abs(t-n);d=x(q,b.xAxis[0].translate(this.x))+d;m=K(t)&&this.getStackBox(b,this,d,t,f,n,m);f=this.label;n=this.isNegative;d="justify"===x(this.options.overflow,"justify");var g=this.textAlign;f&&m&&(q=f.getBBox(),t=f.padding,g="left"===g?b.inverted?-t:t:"right"===g?q.width:b.inverted&&"center"===g?q.width/2:b.inverted?n?q.width+t:-t:q.width/2,n=b.inverted?q.height/2:n?-t:q.height,this.alignOptions.x=x(this.options.x,0),this.alignOptions.y=x(this.options.y,0),m.x-=g,m.y-=n,f.align(this.alignOptions,
null,m),b.isInsidePlot(f.alignAttr.x+g-this.alignOptions.x,f.alignAttr.y+n-this.alignOptions.y)?f.show():(f.alignAttr.y=-9999,d=!1),d&&F.prototype.justifyDataLabel.call(this.axis,f,this.alignOptions,f.alignAttr,q,m),f.attr({x:f.alignAttr.x,y:f.alignAttr.y}),x(!d&&this.options.crop,!0)&&((b=b.isInsidePlot(f.x-t+f.width,f.y)&&b.isInsidePlot(f.x+t,f.y))||f.hide()))};d.prototype.getStackBox=function(d,f,n,t,q,m,b){var g=f.axis.reversed,v=d.inverted,h=b.height+b.pos-(v?d.plotLeft:d.plotTop);f=f.isNegative&&
!g||!f.isNegative&&g;return{x:v?f?t-b.right:t-m+b.pos-d.plotLeft:n+d.xAxis[0].transB-d.plotLeft,y:v?b.height-n-q:f?h-t-m:h-t,width:v?m:q,height:v?q:m}};return d}();q.prototype.getStacks=function(){var d=this,f=d.inverted;d.yAxis.forEach(function(d){d.stacking&&d.stacking.stacks&&d.hasVisibleSeries&&(d.stacking.oldStacks=d.stacking.stacks)});d.series.forEach(function(w){var n=w.xAxis&&w.xAxis.options||{};!w.options.stacking||!0!==w.visible&&!1!==d.options.chart.ignoreHiddenSeries||(w.stackKey=[w.type,
x(w.options.stack,""),f?n.top:n.left,f?n.height:n.width].join())})};A.compose(d);F.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var d=this.processedXData,f=this.processedYData,w=[],n=f.length,t=this.options,q=t.threshold,m=x(t.startFromThreshold&&q,0),b=t.stack;t=t.stacking;var g=this.stackKey,v="-"+g,h=this.negStacks,e=this.yAxis,p=e.stacking.stacks,l=e.stacking.oldStacks,I,u;e.stacking.stacksTouched+=1;for(u=
0;u<n;u++){var y=d[u];var G=f[u];var S=this.getStackIndicator(S,y,this.index);var R=S.key;var B=(I=h&&G<(m?0:q))?v:g;p[B]||(p[B]={});p[B][y]||(l[B]&&l[B][y]?(p[B][y]=l[B][y],p[B][y].total=null):p[B][y]=new H(e,e.options.stackLabels,I,y,b));B=p[B][y];null!==G?(B.points[R]=B.points[this.index]=[x(B.cumulative,m)],K(B.cumulative)||(B.base=R),B.touched=e.stacking.stacksTouched,0<S.index&&!1===this.singleStacks&&(B.points[R][0]=B.points[this.index+","+y+",0"][0])):B.points[R]=B.points[this.index]=null;
"percent"===t?(I=I?g:v,h&&p[I]&&p[I][y]?(I=p[I][y],B.total=I.total=Math.max(I.total,B.total)+Math.abs(G)||0):B.total=E(B.total+(Math.abs(G)||0))):B.total=E(B.total+(G||0));B.cumulative=x(B.cumulative,m)+(G||0);null!==G&&(B.points[R].push(B.cumulative),w[u]=B.cumulative)}"percent"===t&&(e.stacking.usePercentage=!0);this.stackedYData=w;e.stacking.oldStacks={}}};F.prototype.modifyStacks=function(){var d=this,f=d.stackKey,w=d.yAxis.stacking.stacks,n=d.processedXData,t,q=d.options.stacking;d[q+"Stacker"]&&
[f,"-"+f].forEach(function(f){for(var b=n.length,g,m;b--;)if(g=n[b],t=d.getStackIndicator(t,g,d.index,f),m=(g=w[f]&&w[f][g])&&g.points[t.key])d[q+"Stacker"](m,g,b)})};F.prototype.percentStacker=function(d,f,w){f=f.total?100/f.total:0;d[0]=E(d[0]*f);d[1]=E(d[1]*f);this.stackedYData[w]=d[1]};F.prototype.getStackIndicator=function(d,f,w,n){!K(d)||d.x!==f||n&&d.key!==n?d={x:f,index:0,key:n}:d.index++;d.key=[w,f,d.index].join();return d};f.StackItem=H;return f.StackItem});Q(A,"parts/Dynamics.js",[A["parts/Globals.js"],
A["parts/Point.js"],A["parts/Time.js"],A["parts/Utilities.js"]],function(d,f,A,q){var E=q.addEvent,K=q.animate,J=q.createElement,L=q.css,x=q.defined,F=q.erase,H=q.error,C=q.extend,D=q.fireEvent,w=q.isArray,n=q.isNumber,t=q.isObject,N=q.isString,m=q.merge,b=q.objectEach,g=q.pick,v=q.relativeLength,h=q.setAnimation,e=q.splat,p=d.Axis;q=d.Chart;var l=d.Series,I=d.seriesTypes;d.cleanRecursively=function(e,g){var f={};b(e,function(b,l){if(t(e[l],!0)&&!e.nodeType&&g[l])b=d.cleanRecursively(e[l],g[l]),Object.keys(b).length&&
(f[l]=b);else if(t(e[l])||e[l]!==g[l])f[l]=e[l]});return f};C(q.prototype,{addSeries:function(b,e,d){var f,l=this;b&&(e=g(e,!0),D(l,"addSeries",{options:b},function(){f=l.initSeries(b);l.isDirtyLegend=!0;l.linkSeries();f.enabledDataSorting&&f.setData(b.data,!1);D(l,"afterAddSeries",{series:f});e&&l.redraw(d)}));return f},addAxis:function(b,e,d,g){return this.createAxis(e?"xAxis":"yAxis",{axis:b,redraw:d,animation:g})},addColorAxis:function(b,e,d){return this.createAxis("colorAxis",{axis:b,redraw:e,
animation:d})},createAxis:function(b,f){var l=this.options,h="colorAxis"===b,u=f.redraw,n=f.animation;f=m(f.axis,{index:this[b].length,isX:"xAxis"===b});var c=h?new d.ColorAxis(this,f):new p(this,f);l[b]=e(l[b]||{});l[b].push(f);h&&(this.isDirtyLegend=!0,this.axes.forEach(function(a){a.series=[]}),this.series.forEach(function(a){a.bindAxes();a.isDirtyData=!0}));g(u,!0)&&this.redraw(n);return c},showLoading:function(b){var e=this,d=e.options,f=e.loadingDiv,l=d.loading,h=function(){f&&L(f,{left:e.plotLeft+
"px",top:e.plotTop+"px",width:e.plotWidth+"px",height:e.plotHeight+"px"})};f||(e.loadingDiv=f=J("div",{className:"highcharts-loading highcharts-loading-hidden"},null,e.container),e.loadingSpan=J("span",{className:"highcharts-loading-inner"},null,f),E(e,"redraw",h));f.className="highcharts-loading";e.loadingSpan.innerHTML=g(b,d.lang.loading,"");e.styledMode||(L(f,C(l.style,{zIndex:10})),L(e.loadingSpan,l.labelStyle),e.loadingShown||(L(f,{opacity:0,display:""}),K(f,{opacity:l.style.opacity||.5},{duration:l.showDuration||
0})));e.loadingShown=!0;h()},hideLoading:function(){var b=this.options,e=this.loadingDiv;e&&(e.className="highcharts-loading highcharts-loading-hidden",this.styledMode||K(e,{opacity:0},{duration:b.loading.hideDuration||100,complete:function(){L(e,{display:"none"})}}));this.loadingShown=!1},propsRequireDirtyBox:"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),propsRequireReflow:"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),collectionsWithUpdate:["xAxis","yAxis","zAxis","series"],update:function(f,l,h,p){var u=this,y={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"},c,a,k,r=f.isResponsiveOptions,t=[];D(u,"update",{options:f});r||u.setResponsive(!1,!0);f=d.cleanRecursively(f,u.options);m(!0,u.userOptions,f);if(c=f.chart){m(!0,u.options.chart,c);"className"in
c&&u.setClassName(c.className);"reflow"in c&&u.setReflow(c.reflow);if("inverted"in c||"polar"in c||"type"in c){u.propFromSeries();var w=!0}"alignTicks"in c&&(w=!0);b(c,function(c,b){-1!==u.propsRequireUpdateSeries.indexOf("chart."+b)&&(a=!0);-1!==u.propsRequireDirtyBox.indexOf(b)&&(u.isDirtyBox=!0);r||-1===u.propsRequireReflow.indexOf(b)||(k=!0)});!u.styledMode&&"style"in c&&u.renderer.setStyle(c.style)}!u.styledMode&&f.colors&&(this.options.colors=f.colors);f.plotOptions&&m(!0,this.options.plotOptions,
f.plotOptions);f.time&&this.time===d.time&&(this.time=new A(f.time));b(f,function(c,b){if(u[b]&&"function"===typeof u[b].update)u[b].update(c,!1);else if("function"===typeof u[y[b]])u[y[b]](c);"chart"!==b&&-1!==u.propsRequireUpdateSeries.indexOf(b)&&(a=!0)});this.collectionsWithUpdate.forEach(function(a){if(f[a]){if("series"===a){var c=[];u[a].forEach(function(a,b){a.options.isInternal||c.push(g(a.options.index,b))})}e(f[a]).forEach(function(b,e){(e=x(b.id)&&u.get(b.id)||u[a][c?c[e]:e])&&e.coll===
a&&(e.update(b,!1),h&&(e.touched=!0));!e&&h&&u.collectionsWithInit[a]&&(u.collectionsWithInit[a][0].apply(u,[b].concat(u.collectionsWithInit[a][1]||[]).concat([!1])).touched=!0)});h&&u[a].forEach(function(a){a.touched||a.options.isInternal?delete a.touched:t.push(a)})}});t.forEach(function(a){a.remove&&a.remove(!1)});w&&u.axes.forEach(function(a){a.update({},!1)});a&&u.getSeriesOrderByLinks().forEach(function(a){a.chart&&a.update({},!1)},this);f.loading&&m(!0,u.options.loading,f.loading);w=c&&c.width;
c=c&&c.height;N(c)&&(c=v(c,w||u.chartWidth));k||n(w)&&w!==u.chartWidth||n(c)&&c!==u.chartHeight?u.setSize(w,c,p):g(l,!0)&&u.redraw(p);D(u,"afterUpdate",{options:f,redraw:l,animation:p})},setSubtitle:function(b,e){this.applyDescription("subtitle",b);this.layOutTitles(e)},setCaption:function(b,e){this.applyDescription("caption",b);this.layOutTitles(e)}});q.prototype.collectionsWithInit={xAxis:[q.prototype.addAxis,[!0]],yAxis:[q.prototype.addAxis,[!1]],series:[q.prototype.addSeries]};C(f.prototype,{update:function(b,
e,d,f){function l(){h.applyOptions(b);var f=a&&h.hasDummyGraphic;f=null===h.y?!f:f;a&&f&&(h.graphic=a.destroy(),delete h.hasDummyGraphic);t(b,!0)&&(a&&a.element&&b&&b.marker&&"undefined"!==typeof b.marker.symbol&&(h.graphic=a.destroy()),b&&b.dataLabels&&h.dataLabel&&(h.dataLabel=h.dataLabel.destroy()),h.connector&&(h.connector=h.connector.destroy()));k=h.index;c.updateParallelArrays(h,k);u.data[k]=t(u.data[k],!0)||t(b,!0)?h.options:g(b,u.data[k]);c.isDirty=c.isDirtyData=!0;!c.fixedBox&&c.hasCartesianSeries&&
(m.isDirtyBox=!0);"point"===u.legendType&&(m.isDirtyLegend=!0);e&&m.redraw(d)}var h=this,c=h.series,a=h.graphic,k,m=c.chart,u=c.options;e=g(e,!0);!1===f?l():h.firePointEvent("update",{options:b},l)},remove:function(b,e){this.series.removePoint(this.series.data.indexOf(this),b,e)}});C(l.prototype,{addPoint:function(b,e,d,f,l){var h=this.options,c=this.data,a=this.chart,k=this.xAxis;k=k&&k.hasNames&&k.names;var m=h.data,u=this.xData,n;e=g(e,!0);var p={series:this};this.pointClass.prototype.applyOptions.apply(p,
[b]);var v=p.x;var y=u.length;if(this.requireSorting&&v<u[y-1])for(n=!0;y&&u[y-1]>v;)y--;this.updateParallelArrays(p,"splice",y,0,0);this.updateParallelArrays(p,y);k&&p.name&&(k[v]=p.name);m.splice(y,0,b);n&&(this.data.splice(y,0,null),this.processData());"point"===h.legendType&&this.generatePoints();d&&(c[0]&&c[0].remove?c[0].remove(!1):(c.shift(),this.updateParallelArrays(p,"shift"),m.shift()));!1!==l&&D(this,"addPoint",{point:p});this.isDirtyData=this.isDirty=!0;e&&a.redraw(f)},removePoint:function(b,
e,d){var f=this,l=f.data,m=l[b],c=f.points,a=f.chart,k=function(){c&&c.length===l.length&&c.splice(b,1);l.splice(b,1);f.options.data.splice(b,1);f.updateParallelArrays(m||{series:f},"splice",b,1);m&&m.destroy();f.isDirty=!0;f.isDirtyData=!0;e&&a.redraw()};h(d,a);e=g(e,!0);m?m.firePointEvent("remove",null,k):k()},remove:function(b,e,d,f){function l(){h.destroy(f);h.remove=null;c.isDirtyLegend=c.isDirtyBox=!0;c.linkSeries();g(b,!0)&&c.redraw(e)}var h=this,c=h.chart;!1!==d?D(h,"remove",null,l):l()},
update:function(b,e){b=d.cleanRecursively(b,this.userOptions);D(this,"update",{options:b});var f=this,l=f.chart,h=f.userOptions,n=f.initialType||f.type,c=b.type||h.type||l.options.chart.type,a=!(this.hasDerivedData||b.dataGrouping||c&&c!==this.type||"undefined"!==typeof b.pointStart||b.pointInterval||b.pointIntervalUnit||b.keys),k=I[n].prototype,p,u=["group","markerGroup","dataLabelsGroup","transformGroup"],v=["eventOptions","navigatorSeries","baseSeries"],y=f.finishedAnimating&&{animation:!1},t=
{};a&&(v.push("data","isDirtyData","points","processedXData","processedYData","xIncrement","_hasPointMarkers","_hasPointLabels","mapMap","mapData","minY","maxY","minX","maxX"),!1!==b.visible&&v.push("area","graph"),f.parallelArrays.forEach(function(a){v.push(a+"Data")}),b.data&&(b.dataSorting&&C(f.options.dataSorting,b.dataSorting),this.setData(b.data,!1)));b=m(h,y,{index:"undefined"===typeof h.index?f.index:h.index,pointStart:g(h.pointStart,f.xData[0])},!a&&{data:f.options.data},b);a&&b.data&&(b.data=
f.options.data);v=u.concat(v);v.forEach(function(a){v[a]=f[a];delete f[a]});f.remove(!1,null,!1,!0);for(p in k)f[p]=void 0;I[c||n]?C(f,I[c||n].prototype):H(17,!0,l,{missingModuleFor:c||n});v.forEach(function(a){f[a]=v[a]});f.init(l,b);if(a&&this.points){var w=f.options;!1===w.visible?(t.graphic=1,t.dataLabel=1):f._hasPointLabels||(c=w.marker,k=w.dataLabels,c&&(!1===c.enabled||"symbol"in c)&&(t.graphic=1),k&&!1===k.enabled&&(t.dataLabel=1));this.points.forEach(function(a){a&&a.series&&(a.resolveColor(),
Object.keys(t).length&&a.destroyElements(t),!1===w.showInLegend&&a.legendItem&&l.legend.destroyItem(a))},this)}b.zIndex!==h.zIndex&&u.forEach(function(a){f[a]&&f[a].attr({zIndex:b.zIndex})});f.initialType=n;l.linkSeries();D(this,"afterUpdate");g(e,!0)&&l.redraw(a?void 0:!1)},setName:function(b){this.name=this.options.name=this.userOptions.name=b;this.chart.isDirtyLegend=!0}});C(p.prototype,{update:function(e,d){var f=this.chart,l=e&&e.events||{};e=m(this.userOptions,e);f.options[this.coll].indexOf&&
(f.options[this.coll][f.options[this.coll].indexOf(this.userOptions)]=e);b(f.options[this.coll].events,function(b,e){"undefined"===typeof l[e]&&(l[e]=void 0)});this.destroy(!0);this.init(f,C(e,{events:l}));f.isDirtyBox=!0;g(d,!0)&&f.redraw()},remove:function(b){for(var e=this.chart,d=this.coll,f=this.series,l=f.length;l--;)f[l]&&f[l].remove(!1);F(e.axes,this);F(e[d],this);w(e.options[d])?e.options[d].splice(this.options.index,1):delete e.options[d];e[d].forEach(function(b,c){b.options.index=b.userOptions.index=
c});this.destroy();e.isDirtyBox=!0;g(b,!0)&&e.redraw()},setTitle:function(b,e){this.update({title:b},e)},setCategories:function(b,e){this.update({categories:b},e)}})});Q(A,"parts/AreaSeries.js",[A["parts/Globals.js"],A["parts/Color.js"],A["mixins/legend-symbol.js"],A["parts/Utilities.js"]],function(d,f,A,q){var E=f.parse,K=q.objectEach,J=q.pick;f=q.seriesType;var L=d.Series;f("area","line",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(d){var f=[],q=[],x=this.xAxis,D=this.yAxis,
w=D.stacking.stacks[this.stackKey],n={},t=this.index,A=D.series,m=A.length,b=J(D.options.reversedStacks,!0)?1:-1,g;d=d||this.points;if(this.options.stacking){for(g=0;g<d.length;g++)d[g].leftNull=d[g].rightNull=void 0,n[d[g].x]=d[g];K(w,function(b,e){null!==b.total&&q.push(e)});q.sort(function(b,e){return b-e});var v=A.map(function(b){return b.visible});q.forEach(function(d,e){var h=0,l,I;if(n[d]&&!n[d].isNull)f.push(n[d]),[-1,1].forEach(function(f){var h=1===f?"rightNull":"leftNull",p=0,u=w[q[e+f]];
if(u)for(g=t;0<=g&&g<m;)l=u.points[g],l||(g===t?n[d][h]=!0:v[g]&&(I=w[d].points[g])&&(p-=I[1]-I[0])),g+=b;n[d][1===f?"rightCliff":"leftCliff"]=p});else{for(g=t;0<=g&&g<m;){if(l=w[d].points[g]){h=l[1];break}g+=b}h=D.translate(h,0,1,0,1);f.push({isNull:!0,plotX:x.translate(d,0,0,0,1),x:d,plotY:h,yBottom:h})}})}return f},getGraphPath:function(d){var f=L.prototype.getGraphPath,q=this.options,x=q.stacking,D=this.yAxis,w,n=[],t=[],A=this.index,m=D.stacking.stacks[this.stackKey],b=q.threshold,g=Math.round(D.getThreshold(q.threshold));
q=J(q.connectNulls,"percent"===x);var v=function(f,h,p){var l=d[f];f=x&&m[l.x].points[A];var u=l[p+"Null"]||0;p=l[p+"Cliff"]||0;l=!0;if(p||u){var v=(u?f[0]:f[1])+p;var w=f[0]+p;l=!!u}else!x&&d[h]&&d[h].isNull&&(v=w=b);"undefined"!==typeof v&&(t.push({plotX:e,plotY:null===v?g:D.getThreshold(v),isNull:l,isCliff:!0}),n.push({plotX:e,plotY:null===w?g:D.getThreshold(w),doCurve:!1}))};d=d||this.points;x&&(d=this.getStackPoints(d));for(w=0;w<d.length;w++){x||(d[w].leftCliff=d[w].rightCliff=d[w].leftNull=
d[w].rightNull=void 0);var h=d[w].isNull;var e=J(d[w].rectPlotX,d[w].plotX);var p=J(d[w].yBottom,g);if(!h||q)q||v(w,w-1,"left"),h&&!x&&q||(t.push(d[w]),n.push({x:w,plotX:e,plotY:p})),q||v(w,w+1,"right")}w=f.call(this,t,!0,!0);n.reversed=!0;h=f.call(this,n,!0,!0);(p=h[0])&&"M"===p[0]&&(h[0]=["L",p[1],p[2]]);h=w.concat(h);f=f.call(this,t,!1,q);h.xMap=w.xMap;this.areaPath=h;return f},drawGraph:function(){this.areaPath=[];L.prototype.drawGraph.apply(this);var d=this,f=this.areaPath,q=this.options,C=[["area",
"highcharts-area",this.color,q.fillColor]];this.zones.forEach(function(f,w){C.push(["zone-area-"+w,"highcharts-area highcharts-zone-area-"+w+" "+f.className,f.color||d.color,f.fillColor||q.fillColor])});C.forEach(function(x){var w=x[0],n=d[w],t=n?"animate":"attr",C={};n?(n.endX=d.preventGraphAnimation?null:f.xMap,n.animate({d:f})):(C.zIndex=0,n=d[w]=d.chart.renderer.path(f).addClass(x[1]).add(d.group),n.isArea=!0);d.chart.styledMode||(C.fill=J(x[3],E(x[2]).setOpacity(J(q.fillOpacity,.75)).get()));
n[t](C);n.startX=f.xMap;n.shiftUnit=q.step?2:1})},drawLegendSymbol:A.drawRectangle});""});Q(A,"parts/SplineSeries.js",[A["parts/Utilities.js"]],function(d){var f=d.pick;d=d.seriesType;d("spline","line",{},{getPointSpline:function(d,q,A){var E=q.plotX||0,J=q.plotY||0,L=d[A-1];A=d[A+1];if(L&&!L.isNull&&!1!==L.doCurve&&!q.isCliff&&A&&!A.isNull&&!1!==A.doCurve&&!q.isCliff){d=L.plotY||0;var x=A.plotX||0;A=A.plotY||0;var F=0;var H=(1.5*E+(L.plotX||0))/2.5;var C=(1.5*J+d)/2.5;x=(1.5*E+x)/2.5;var D=(1.5*
J+A)/2.5;x!==H&&(F=(D-C)*(x-E)/(x-H)+J-D);C+=F;D+=F;C>d&&C>J?(C=Math.max(d,J),D=2*J-C):C<d&&C<J&&(C=Math.min(d,J),D=2*J-C);D>A&&D>J?(D=Math.max(A,J),C=2*J-D):D<A&&D<J&&(D=Math.min(A,J),C=2*J-D);q.rightContX=x;q.rightContY=D}q=["C",f(L.rightContX,L.plotX,0),f(L.rightContY,L.plotY,0),f(H,E,0),f(C,J,0),E,J];L.rightContX=L.rightContY=void 0;return q}});""});Q(A,"parts/AreaSplineSeries.js",[A["parts/Globals.js"],A["mixins/legend-symbol.js"],A["parts/Utilities.js"]],function(d,f,A){A=A.seriesType;var q=
d.seriesTypes.area.prototype;A("areaspline","spline",d.defaultPlotOptions.area,{getStackPoints:q.getStackPoints,getGraphPath:q.getGraphPath,drawGraph:q.drawGraph,drawLegendSymbol:f.drawRectangle});""});Q(A,"parts/ColumnSeries.js",[A["parts/Globals.js"],A["parts/Color.js"],A["mixins/legend-symbol.js"],A["parts/Utilities.js"]],function(d,f,A,q){"";var E=f.parse,K=q.animObject,J=q.clamp,L=q.defined,x=q.extend,F=q.isNumber,H=q.merge,C=q.pick;f=q.seriesType;var D=d.Series;f("column","line",{borderRadius:0,
groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1},select:{color:"#cccccc",borderColor:"#000000"}},dataLabels:{align:null,verticalAlign:null,y:null},softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"},{cropShoulder:0,directTouch:!0,trackerGroups:["group","dataLabelsGroup"],negStacks:!0,init:function(){D.prototype.init.apply(this,arguments);var d=this,f=d.chart;
f.hasRendered&&f.series.forEach(function(f){f.type===d.type&&(f.isDirty=!0)})},getColumnMetrics:function(){var d=this,f=d.options,t=d.xAxis,q=d.yAxis,m=t.options.reversedStacks;m=t.reversed&&!m||!t.reversed&&m;var b,g={},v=0;!1===f.grouping?v=1:d.chart.series.forEach(function(e){var f=e.yAxis,l=e.options;if(e.type===d.type&&(e.visible||!d.chart.options.chart.ignoreHiddenSeries)&&q.len===f.len&&q.pos===f.pos){if(l.stacking){b=e.stackKey;"undefined"===typeof g[b]&&(g[b]=v++);var h=g[b]}else!1!==l.grouping&&
(h=v++);e.columnIndex=h}});var h=Math.min(Math.abs(t.transA)*(t.ordinal&&t.ordinal.slope||f.pointRange||t.closestPointRange||t.tickInterval||1),t.len),e=h*f.groupPadding,p=(h-2*e)/(v||1);f=Math.min(f.maxPointWidth||t.len,C(f.pointWidth,p*(1-2*f.pointPadding)));d.columnMetrics={width:f,offset:(p-f)/2+(e+((d.columnIndex||0)+(m?1:0))*p-h/2)*(m?-1:1)};return d.columnMetrics},crispCol:function(d,f,t,q){var m=this.chart,b=this.borderWidth,g=-(b%2?.5:0);b=b%2?.5:1;m.inverted&&m.renderer.isVML&&(b+=1);this.options.crisp&&
(t=Math.round(d+t)+g,d=Math.round(d)+g,t-=d);q=Math.round(f+q)+b;g=.5>=Math.abs(f)&&.5<q;f=Math.round(f)+b;q-=f;g&&q&&(--f,q+=1);return{x:d,y:f,width:t,height:q}},translate:function(){var d=this,f=d.chart,t=d.options,q=d.dense=2>d.closestPointRange*d.xAxis.transA;q=d.borderWidth=C(t.borderWidth,q?0:1);var m=d.xAxis,b=d.yAxis,g=t.threshold,v=d.translatedThreshold=b.getThreshold(g),h=C(t.minPointLength,5),e=d.getColumnMetrics(),p=e.width,l=d.barW=Math.max(p,1+2*q),I=d.pointXOffset=e.offset,u=d.dataMin,
y=d.dataMax;f.inverted&&(v-=.5);t.pointPadding&&(l=Math.ceil(l));D.prototype.translate.apply(d);d.points.forEach(function(e){var n=C(e.yBottom,v),t=999+Math.abs(n),q=p,c=e.plotX;t=J(e.plotY,-t,b.len+t);var a=e.plotX+I,k=l,r=Math.min(t,n),w=Math.max(t,n)-r;if(h&&Math.abs(w)<h){w=h;var x=!b.reversed&&!e.negative||b.reversed&&e.negative;F(g)&&F(y)&&e.y===g&&y<=g&&(b.min||0)<g&&u!==y&&(x=!x);r=Math.abs(r-v)>h?n-h:v-(x?h:0)}L(e.options.pointWidth)&&(q=k=Math.ceil(e.options.pointWidth),a-=Math.round((q-
p)/2));e.barX=a;e.pointWidth=q;e.tooltipPos=f.inverted?[b.len+b.pos-f.plotLeft-t,m.len+m.pos-f.plotTop-(c||0)-I-k/2,w]:[a+k/2,t+b.pos-f.plotTop,w];e.shapeType=d.pointClass.prototype.shapeType||"rect";e.shapeArgs=d.crispCol.apply(d,e.isNull?[a,v,k,0]:[a,r,k,w])})},getSymbol:d.noop,drawLegendSymbol:A.drawRectangle,drawGraph:function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")},pointAttribs:function(d,f){var n=this.options,q=this.pointAttrToOptions||{};var m=q.stroke||
"borderColor";var b=q["stroke-width"]||"borderWidth",g=d&&d.color||this.color,v=d&&d[m]||n[m]||this.color||g,h=d&&d[b]||n[b]||this[b]||0;q=d&&d.options.dashStyle||n.dashStyle;var e=C(d&&d.opacity,n.opacity,1);if(d&&this.zones.length){var p=d.getZone();g=d.options.color||p&&(p.color||d.nonZonedColor)||this.color;p&&(v=p.borderColor||v,q=p.dashStyle||q,h=p.borderWidth||h)}f&&d&&(d=H(n.states[f],d.options.states&&d.options.states[f]||{}),f=d.brightness,g=d.color||"undefined"!==typeof f&&E(g).brighten(d.brightness).get()||
g,v=d[m]||v,h=d[b]||h,q=d.dashStyle||q,e=C(d.opacity,e));m={fill:g,stroke:v,"stroke-width":h,opacity:e};q&&(m.dashstyle=q);return m},drawPoints:function(){var d=this,f=this.chart,q=d.options,x=f.renderer,m=q.animationLimit||250,b;d.points.forEach(function(g){var n=g.graphic,h=!!n,e=n&&f.pointCount<m?"animate":"attr";if(F(g.plotY)&&null!==g.y){b=g.shapeArgs;n&&g.hasNewShapeType()&&(n=n.destroy());d.enabledDataSorting&&(g.startXPos=d.xAxis.reversed?-(b?b.width:0):d.xAxis.width);n||(g.graphic=n=x[g.shapeType](b).add(g.group||
d.group))&&d.enabledDataSorting&&f.hasRendered&&f.pointCount<m&&(n.attr({x:g.startXPos}),h=!0,e="animate");if(n&&h)n[e](H(b));if(q.borderRadius)n[e]({r:q.borderRadius});f.styledMode||n[e](d.pointAttribs(g,g.selected&&"select")).shadow(!1!==g.allowShadow&&q.shadow,null,q.stacking&&!q.borderRadius);n.addClass(g.getClassName(),!0)}else n&&(g.graphic=n.destroy())})},animate:function(d){var f=this,q=this.yAxis,w=f.options,m=this.chart.inverted,b={},g=m?"translateX":"translateY";if(d)b.scaleY=.001,d=J(q.toPixels(w.threshold),
q.pos,q.pos+q.len),m?b.translateX=d-q.len:b.translateY=d,f.clipBox&&f.setClip(),f.group.attr(b);else{var v=f.group.attr(g);f.group.animate({scaleY:1},x(K(f.options.animation),{step:function(d,e){f.group&&(b[g]=v+e.pos*(q.pos-v),f.group.attr(b))}}))}},remove:function(){var d=this,f=d.chart;f.hasRendered&&f.series.forEach(function(f){f.type===d.type&&(f.isDirty=!0)});D.prototype.remove.apply(d,arguments)}});""});Q(A,"parts/BarSeries.js",[A["parts/Utilities.js"]],function(d){d=d.seriesType;d("bar","column",
null,{inverted:!0});""});Q(A,"parts/ScatterSeries.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var A=f.addEvent;f=f.seriesType;var q=d.Series;f("scatter","line",{lineWidth:0,findNearestPointBy:"xy",jitter:{x:0,y:0},marker:{enabled:!0},tooltip:{headerFormat:'<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}},{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group",
"markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1,drawGraph:function(){this.options.lineWidth&&q.prototype.drawGraph.call(this)},applyJitter:function(){var d=this,f=this.options.jitter,q=this.points.length;f&&this.points.forEach(function(A,x){["x","y"].forEach(function(E,H){var C="plot"+E.toUpperCase();if(f[E]&&!A.isNull){var D=d[E+"Axis"];var w=f[E]*D.transA;if(D&&!D.isLog){var n=Math.max(0,A[C]-w);D=Math.min(D.len,A[C]+w);H=1E4*Math.sin(x+H*q);A[C]=n+(D-n)*(H-Math.floor(H));"x"===E&&(A.clientX=
A.plotX)}}})})}});A(q,"afterTranslate",function(){this.applyJitter&&this.applyJitter()});""});Q(A,"mixins/centered-series.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var A=f.isNumber,q=f.pick,M=f.relativeLength,K=d.deg2rad;d.CenteredSeriesMixin={getCenter:function(){var d=this.options,f=this.chart,x=2*(d.slicedOffset||0),A=f.plotWidth-2*x,E=f.plotHeight-2*x,C=d.center,D=Math.min(A,E),w=d.size,n=d.innerSize||0;"string"===typeof w&&(w=parseFloat(w));"string"===typeof n&&(n=parseFloat(n));
d=[q(C[0],"50%"),q(C[1],"50%"),q(w&&0>w?void 0:d.size,"100%"),q(n&&0>n?void 0:d.innerSize||0,"0%")];f.angular&&(d[3]=0);for(C=0;4>C;++C)w=d[C],f=2>C||2===C&&/%$/.test(w),d[C]=M(w,[A,E,D,d[2]][C])+(f?x:0);d[3]>d[2]&&(d[3]=d[2]);return d},getStartAndEndRadians:function(d,f){d=A(d)?d:0;f=A(f)&&f>d&&360>f-d?f:d+360;return{start:K*(d+-90),end:K*(f+-90)}}}});Q(A,"parts/PieSeries.js",[A["parts/Globals.js"],A["mixins/legend-symbol.js"],A["parts/Point.js"],A["parts/Utilities.js"]],function(d,f,A,q){var E=
q.addEvent,K=q.clamp,J=q.defined,L=q.fireEvent,x=q.isNumber,F=q.merge,H=q.pick,C=q.relativeLength,D=q.seriesType,w=q.setAnimation;q=d.CenteredSeriesMixin;var n=q.getStartAndEndRadians,t=d.noop,N=d.Series;D("pie","line",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{allowOverlap:!0,connectorPadding:5,connectorShape:"fixedOffset",crookDistance:"70%",distance:30,enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},softConnector:!0,x:0},fillColor:void 0,ignoreHiddenPoint:!0,
inactiveOtherPoints:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",borderWidth:1,lineWidth:void 0,states:{hover:{brightness:.1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],axisTypes:[],pointAttribs:d.seriesTypes.column.prototype.pointAttribs,animate:function(d){var b=this,f=b.points,m=b.startAngleRad;d||f.forEach(function(d){var e=d.graphic,
f=d.shapeArgs;e&&f&&(e.attr({r:H(d.startR,b.center&&b.center[3]/2),start:m,end:m}),e.animate({r:f.r,start:f.start,end:f.end},b.options.animation))})},hasData:function(){return!!this.processedXData.length},updateTotals:function(){var d,b=0,f=this.points,n=f.length,h=this.options.ignoreHiddenPoint;for(d=0;d<n;d++){var e=f[d];b+=h&&!e.visible?0:e.isNull?0:e.y}this.total=b;for(d=0;d<n;d++)e=f[d],e.percentage=0<b&&(e.visible||!h)?e.y/b*100:0,e.total=b},generatePoints:function(){N.prototype.generatePoints.call(this);
this.updateTotals()},getX:function(d,b,f){var g=this.center,h=this.radii?this.radii[f.index]:g[2]/2;d=Math.asin(K((d-g[1])/(h+f.labelDistance),-1,1));return g[0]+(b?-1:1)*Math.cos(d)*(h+f.labelDistance)+(0<f.labelDistance?(b?-1:1)*this.options.dataLabels.padding:0)},translate:function(d){this.generatePoints();var b=0,f=this.options,m=f.slicedOffset,h=m+(f.borderWidth||0),e=n(f.startAngle,f.endAngle),p=this.startAngleRad=e.start;e=(this.endAngleRad=e.end)-p;var l=this.points,q=f.dataLabels.distance;
f=f.ignoreHiddenPoint;var u,y=l.length;d||(this.center=d=this.getCenter());for(u=0;u<y;u++){var t=l[u];var w=p+b*e;if(!f||t.visible)b+=t.percentage/100;var x=p+b*e;t.shapeType="arc";t.shapeArgs={x:d[0],y:d[1],r:d[2]/2,innerR:d[3]/2,start:Math.round(1E3*w)/1E3,end:Math.round(1E3*x)/1E3};t.labelDistance=H(t.options.dataLabels&&t.options.dataLabels.distance,q);t.labelDistance=C(t.labelDistance,t.shapeArgs.r);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,t.labelDistance);x=(x+w)/2;x>1.5*Math.PI?
x-=2*Math.PI:x<-Math.PI/2&&(x+=2*Math.PI);t.slicedTranslation={translateX:Math.round(Math.cos(x)*m),translateY:Math.round(Math.sin(x)*m)};var B=Math.cos(x)*d[2]/2;var c=Math.sin(x)*d[2]/2;t.tooltipPos=[d[0]+.7*B,d[1]+.7*c];t.half=x<-Math.PI/2||x>Math.PI/2?1:0;t.angle=x;w=Math.min(h,t.labelDistance/5);t.labelPosition={natural:{x:d[0]+B+Math.cos(x)*t.labelDistance,y:d[1]+c+Math.sin(x)*t.labelDistance},"final":{},alignment:0>t.labelDistance?"center":t.half?"right":"left",connectorPosition:{breakAt:{x:d[0]+
B+Math.cos(x)*w,y:d[1]+c+Math.sin(x)*w},touchingSliceAt:{x:d[0]+B,y:d[1]+c}}}}L(this,"afterTranslate")},drawEmpty:function(){var d=this.options;if(0===this.total){var b=this.center[0];var f=this.center[1];this.graph||(this.graph=this.chart.renderer.circle(b,f,0).addClass("highcharts-graph").add(this.group));this.graph.animate({"stroke-width":d.borderWidth,cx:b,cy:f,r:this.center[2]/2,fill:d.fillColor||"none",stroke:d.color||"#cccccc"},this.options.animation)}else this.graph&&(this.graph=this.graph.destroy())},
redrawPoints:function(){var d=this,b=d.chart,f=b.renderer,n,h,e,p,l=d.options.shadow;this.drawEmpty();!l||d.shadowGroup||b.styledMode||(d.shadowGroup=f.g("shadow").attr({zIndex:-1}).add(d.group));d.points.forEach(function(g){var m={};h=g.graphic;if(!g.isNull&&h){p=g.shapeArgs;n=g.getTranslate();if(!b.styledMode){var v=g.shadowGroup;l&&!v&&(v=g.shadowGroup=f.g("shadow").add(d.shadowGroup));v&&v.attr(n);e=d.pointAttribs(g,g.selected&&"select")}g.delayedRendering?(h.setRadialReference(d.center).attr(p).attr(n),
b.styledMode||h.attr(e).attr({"stroke-linejoin":"round"}).shadow(l,v),g.delayedRendering=!1):(h.setRadialReference(d.center),b.styledMode||F(!0,m,e),F(!0,m,p,n),h.animate(m));h.attr({visibility:g.visible?"inherit":"hidden"});h.addClass(g.getClassName())}else h&&(g.graphic=h.destroy())})},drawPoints:function(){var d=this.chart.renderer;this.points.forEach(function(b){b.graphic&&b.hasNewShapeType()&&(b.graphic=b.graphic.destroy());b.graphic||(b.graphic=d[b.shapeType](b.shapeArgs).add(b.series.group),
b.delayedRendering=!0)})},searchPoint:t,sortByAngle:function(d,b){d.sort(function(d,f){return"undefined"!==typeof d.angle&&(f.angle-d.angle)*b})},drawLegendSymbol:f.drawRectangle,getCenter:q.getCenter,getSymbol:t,drawGraph:null},{init:function(){A.prototype.init.apply(this,arguments);var d=this;d.name=H(d.name,"Slice");var b=function(b){d.slice("select"===b.type)};E(d,"select",b);E(d,"unselect",b);return d},isValid:function(){return x(this.y)&&0<=this.y},setVisible:function(d,b){var f=this,m=f.series,
h=m.chart,e=m.options.ignoreHiddenPoint;b=H(b,e);d!==f.visible&&(f.visible=f.options.visible=d="undefined"===typeof d?!f.visible:d,m.options.data[m.data.indexOf(f)]=f.options,["graphic","dataLabel","connector","shadowGroup"].forEach(function(b){if(f[b])f[b][d?"show":"hide"](!0)}),f.legendItem&&h.legend.colorizeItem(f,d),d||"hover"!==f.state||f.setState(""),e&&(m.isDirty=!0),b&&h.redraw())},slice:function(d,b,f){var g=this.series;w(f,g.chart);H(b,!0);this.sliced=this.options.sliced=J(d)?d:!this.sliced;
g.options.data[g.data.indexOf(this)]=this.options;this.graphic&&this.graphic.animate(this.getTranslate());this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(d){var b=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(b.x,b.y,b.r+d,b.r+d,{innerR:b.r-1,start:b.start,end:b.end})},connectorShapes:{fixedOffset:function(d,b,f){var g=b.breakAt;
b=b.touchingSliceAt;return[["M",d.x,d.y],f.softConnector?["C",d.x+("left"===d.alignment?-5:5),d.y,2*g.x-b.x,2*g.y-b.y,g.x,g.y]:["L",g.x,g.y],["L",b.x,b.y]]},straight:function(d,b){b=b.touchingSliceAt;return[["M",d.x,d.y],["L",b.x,b.y]]},crookedLine:function(d,b,f){b=b.touchingSliceAt;var g=this.series,h=g.center[0],e=g.chart.plotWidth,m=g.chart.plotLeft;g=d.alignment;var l=this.shapeArgs.r;f=C(f.crookDistance,1);e="left"===g?h+l+(e+m-h-l)*(1-f):m+(h-l)*f;f=["L",e,d.y];h=!0;if("left"===g?e>d.x||e<
b.x:e<d.x||e>b.x)h=!1;d=[["M",d.x,d.y]];h&&d.push(f);d.push(["L",b.x,b.y]);return d}},getConnectorPath:function(){var d=this.labelPosition,b=this.series.options.dataLabels,f=b.connectorShape,n=this.connectorShapes;n[f]&&(f=n[f]);return f.call(this,{x:d.final.x,y:d.final.y,alignment:d.alignment},d.connectorPosition,b)}});""});Q(A,"parts/DataLabels.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var A=f.animObject,q=f.arrayMax,M=f.clamp,K=f.defined,J=f.extend,L=f.fireEvent,x=f.format,
F=f.isArray,H=f.merge,C=f.objectEach,D=f.pick,w=f.relativeLength,n=f.splat,t=f.stableSort;f=d.noop;var N=d.Series,m=d.seriesTypes;d.distribute=function(b,f,m){function g(b,e){return b.target-e.target}var e,n=!0,l=b,v=[];var u=0;var q=l.reducedLen||f;for(e=b.length;e--;)u+=b[e].size;if(u>q){t(b,function(b,e){return(e.rank||0)-(b.rank||0)});for(u=e=0;u<=q;)u+=b[e].size,e++;v=b.splice(e-1,b.length)}t(b,g);for(b=b.map(function(b){return{size:b.size,targets:[b.target],align:D(b.align,.5)}});n;){for(e=
b.length;e--;)n=b[e],u=(Math.min.apply(0,n.targets)+Math.max.apply(0,n.targets))/2,n.pos=M(u-n.size*n.align,0,f-n.size);e=b.length;for(n=!1;e--;)0<e&&b[e-1].pos+b[e-1].size>b[e].pos&&(b[e-1].size+=b[e].size,b[e-1].targets=b[e-1].targets.concat(b[e].targets),b[e-1].align=.5,b[e-1].pos+b[e-1].size>f&&(b[e-1].pos=f-b[e-1].size),b.splice(e,1),n=!0)}l.push.apply(l,v);e=0;b.some(function(b){var g=0;if(b.targets.some(function(){l[e].pos=b.pos+g;if("undefined"!==typeof m&&Math.abs(l[e].pos-l[e].target)>m)return l.slice(0,
e+1).forEach(function(b){delete b.pos}),l.reducedLen=(l.reducedLen||f)-.1*f,l.reducedLen>.1*f&&d.distribute(l,f,m),!0;g+=l[e].size;e++}))return!0});t(l,g)};N.prototype.drawDataLabels=function(){function b(c,a){var b=a.filter;return b?(a=b.operator,c=c[b.property],b=b.value,">"===a&&c>b||"<"===a&&c<b||">="===a&&c>=b||"<="===a&&c<=b||"=="===a&&c==b||"==="===a&&c===b?!0:!1):!0}function d(c,a){var b=[],e;if(F(c)&&!F(a))b=c.map(function(c){return H(c,a)});else if(F(a)&&!F(c))b=a.map(function(a){return H(c,
a)});else if(F(c)||F(a))for(e=Math.max(c.length,a.length);e--;)b[e]=H(c[e],a[e]);else b=H(c,a);return b}var f=this,h=f.chart,e=f.options,m=e.dataLabels,l=f.points,q,u=f.hasRendered||0,t=A(e.animation).duration,w=Math.min(t,200),E=!h.renderer.forExport&&D(m.defer,0<w),J=h.renderer;m=d(d(h.options.plotOptions&&h.options.plotOptions.series&&h.options.plotOptions.series.dataLabels,h.options.plotOptions&&h.options.plotOptions[f.type]&&h.options.plotOptions[f.type].dataLabels),m);L(this,"drawDataLabels");
if(F(m)||m.enabled||f._hasPointLabels){var B=f.plotGroup("dataLabelsGroup","data-labels",E&&!u?"hidden":"inherit",m.zIndex||6);E&&(B.attr({opacity:+u}),u||setTimeout(function(){var c=f.dataLabelsGroup;c&&(f.visible&&B.show(!0),c[e.animation?"animate":"attr"]({opacity:1},{duration:w}))},t-w));l.forEach(function(c){q=n(d(m,c.dlOptions||c.options&&c.options.dataLabels));q.forEach(function(a,d){var g=a.enabled&&(!c.isNull||c.dataLabelOnNull)&&b(c,a),l=c.dataLabels?c.dataLabels[d]:c.dataLabel,k=c.connectors?
c.connectors[d]:c.connector,m=D(a.distance,c.labelDistance),n=!l;if(g){var p=c.getLabelConfig();var u=D(a[c.formatPrefix+"Format"],a.format);p=K(u)?x(u,p,h):(a[c.formatPrefix+"Formatter"]||a.formatter).call(p,a);u=a.style;var v=a.rotation;h.styledMode||(u.color=D(a.color,u.color,f.color,"#000000"),"contrast"===u.color?(c.contrastColor=J.getContrast(c.color||f.color),u.color=!K(m)&&a.inside||0>m||e.stacking?c.contrastColor:"#000000"):delete c.contrastColor,e.cursor&&(u.cursor=e.cursor));var q={r:a.borderRadius||
0,rotation:v,padding:a.padding,zIndex:1};h.styledMode||(q.fill=a.backgroundColor,q.stroke=a.borderColor,q["stroke-width"]=a.borderWidth);C(q,function(a,c){"undefined"===typeof a&&delete q[c]})}!l||g&&K(p)?g&&K(p)&&(l?q.text=p:(c.dataLabels=c.dataLabels||[],l=c.dataLabels[d]=v?J.text(p,0,-9999,a.useHTML).addClass("highcharts-data-label"):J.label(p,0,-9999,a.shape,null,null,a.useHTML,null,"data-label"),d||(c.dataLabel=l),l.addClass(" highcharts-data-label-color-"+c.colorIndex+" "+(a.className||"")+
(a.useHTML?" highcharts-tracker":""))),l.options=a,l.attr(q),h.styledMode||l.css(u).shadow(a.shadow),l.added||l.add(B),a.textPath&&!a.useHTML&&(l.setTextPath(c.getDataLabelPath&&c.getDataLabelPath(l)||c.graphic,a.textPath),c.dataLabelPath&&!a.textPath.enabled&&(c.dataLabelPath=c.dataLabelPath.destroy())),f.alignDataLabel(c,l,a,null,n)):(c.dataLabel=c.dataLabel&&c.dataLabel.destroy(),c.dataLabels&&(1===c.dataLabels.length?delete c.dataLabels:delete c.dataLabels[d]),d||delete c.dataLabel,k&&(c.connector=
c.connector.destroy(),c.connectors&&(1===c.connectors.length?delete c.connectors:delete c.connectors[d])))})})}L(this,"afterDrawDataLabels")};N.prototype.alignDataLabel=function(b,d,f,h,e){var g=this,l=this.chart,m=this.isCartesian&&l.inverted,n=this.enabledDataSorting,q=D(b.dlBox&&b.dlBox.centerX,b.plotX,-9999),v=D(b.plotY,-9999),t=d.getBBox(),w=f.rotation,x=f.align,c=l.isInsidePlot(q,Math.round(v),m),a="justify"===D(f.overflow,n?"none":"justify"),k=this.visible&&!1!==b.visible&&(b.series.forceDL||
n&&!a||c||f.inside&&h&&l.isInsidePlot(q,m?h.x+1:h.y+h.height-1,m));var r=function(f){n&&g.xAxis&&!a&&g.setDataLabelStartPos(b,d,e,c,f)};if(k){var z=l.renderer.fontMetrics(l.styledMode?void 0:f.style.fontSize,d).b;h=J({x:m?this.yAxis.len-v:q,y:Math.round(m?this.xAxis.len-q:v),width:0,height:0},h);J(f,{width:t.width,height:t.height});w?(a=!1,q=l.renderer.rotCorr(z,w),q={x:h.x+f.x+h.width/2+q.x,y:h.y+f.y+{top:0,middle:.5,bottom:1}[f.verticalAlign]*h.height},r(q),d[e?"attr":"animate"](q).attr({align:x}),
r=(w+720)%360,r=180<r&&360>r,"left"===x?q.y-=r?t.height:0:"center"===x?(q.x-=t.width/2,q.y-=t.height/2):"right"===x&&(q.x-=t.width,q.y-=r?0:t.height),d.placed=!0,d.alignAttr=q):(r(h),d.align(f,null,h),q=d.alignAttr);a&&0<=h.height?this.justifyDataLabel(d,f,q,t,h,e):D(f.crop,!0)&&(k=l.isInsidePlot(q.x,q.y)&&l.isInsidePlot(q.x+t.width,q.y+t.height));if(f.shape&&!w)d[e?"attr":"animate"]({anchorX:m?l.plotWidth-b.plotY:b.plotX,anchorY:m?l.plotHeight-b.plotX:b.plotY})}e&&n&&(d.placed=!1);k||n&&!a||(d.hide(!0),
d.placed=!1)};N.prototype.setDataLabelStartPos=function(b,d,f,h,e){var g=this.chart,l=g.inverted,m=this.xAxis,n=m.reversed,q=l?d.height/2:d.width/2;b=(b=b.pointWidth)?b/2:0;m=l?e.x:n?-q-b:m.width-q+b;e=l?n?this.yAxis.height-q+b:-q-b:e.y;d.startXPos=m;d.startYPos=e;h?"hidden"===d.visibility&&(d.show(),d.attr({opacity:0}).animate({opacity:1})):d.attr({opacity:1}).animate({opacity:0},void 0,d.hide);g.hasRendered&&(f&&d.attr({x:d.startXPos,y:d.startYPos}),d.placed=!0)};N.prototype.justifyDataLabel=function(b,
d,f,h,e,m){var g=this.chart,n=d.align,p=d.verticalAlign,q=b.box?0:b.padding||0;var v=f.x+q;if(0>v){"right"===n?(d.align="left",d.inside=!0):d.x=-v;var t=!0}v=f.x+h.width-q;v>g.plotWidth&&("left"===n?(d.align="right",d.inside=!0):d.x=g.plotWidth-v,t=!0);v=f.y+q;0>v&&("bottom"===p?(d.verticalAlign="top",d.inside=!0):d.y=-v,t=!0);v=f.y+h.height-q;v>g.plotHeight&&("top"===p?(d.verticalAlign="bottom",d.inside=!0):d.y=g.plotHeight-v,t=!0);t&&(b.placed=!m,b.align(d,null,e));return t};m.pie&&(m.pie.prototype.dataLabelPositioners=
{radialDistributionY:function(b){return b.top+b.distributeBox.pos},radialDistributionX:function(b,d,f,h){return b.getX(f<d.top+2||f>d.bottom-2?h:f,d.half,d)},justify:function(b,d,f){return f[0]+(b.half?-1:1)*(d+b.labelDistance)},alignToPlotEdges:function(b,d,f,h){b=b.getBBox().width;return d?b+h:f-b-h},alignToConnectors:function(b,d,f,h){var e=0,g;b.forEach(function(b){g=b.dataLabel.getBBox().width;g>e&&(e=g)});return d?e+h:f-e-h}},m.pie.prototype.drawDataLabels=function(){var b=this,f=b.data,m,h=
b.chart,e=b.options.dataLabels||{},n=e.connectorPadding,l,t=h.plotWidth,u=h.plotHeight,y=h.plotLeft,w=Math.round(h.chartWidth/3),x,C=b.center,B=C[2]/2,c=C[1],a,k,r,z,A=[[],[]],E,F,L,J,M=[0,0,0,0],Q=b.dataLabelPositioners,O;b.visible&&(e.enabled||b._hasPointLabels)&&(f.forEach(function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),N.prototype.drawDataLabels.apply(b),f.forEach(function(a){a.dataLabel&&
(a.visible?(A[a.half].push(a),a.dataLabel._pos=null,!K(e.style.width)&&!K(a.options.dataLabels&&a.options.dataLabels.style&&a.options.dataLabels.style.width)&&a.dataLabel.getBBox().width>w&&(a.dataLabel.css({width:Math.round(.7*w)+"px"}),a.dataLabel.shortened=!0)):(a.dataLabel=a.dataLabel.destroy(),a.dataLabels&&1===a.dataLabels.length&&delete a.dataLabels))}),A.forEach(function(f,g){var l=f.length,p=[],q;if(l){b.sortByAngle(f,g-.5);if(0<b.maxLabelDistance){var v=Math.max(0,c-B-b.maxLabelDistance);
var w=Math.min(c+B+b.maxLabelDistance,h.plotHeight);f.forEach(function(a){0<a.labelDistance&&a.dataLabel&&(a.top=Math.max(0,c-B-a.labelDistance),a.bottom=Math.min(c+B+a.labelDistance,h.plotHeight),q=a.dataLabel.getBBox().height||21,a.distributeBox={target:a.labelPosition.natural.y-a.top+q/2,size:q,rank:a.y},p.push(a.distributeBox))});v=w+q-v;d.distribute(p,v,v/5)}for(J=0;J<l;J++){m=f[J];r=m.labelPosition;a=m.dataLabel;L=!1===m.visible?"hidden":"inherit";F=v=r.natural.y;p&&K(m.distributeBox)&&("undefined"===
typeof m.distributeBox.pos?L="hidden":(z=m.distributeBox.size,F=Q.radialDistributionY(m)));delete m.positionIndex;if(e.justify)E=Q.justify(m,B,C);else switch(e.alignTo){case "connectors":E=Q.alignToConnectors(f,g,t,y);break;case "plotEdges":E=Q.alignToPlotEdges(a,g,t,y);break;default:E=Q.radialDistributionX(b,m,F,v)}a._attr={visibility:L,align:r.alignment};O=m.options.dataLabels||{};a._pos={x:E+D(O.x,e.x)+({left:n,right:-n}[r.alignment]||0),y:F+D(O.y,e.y)-10};r.final.x=E;r.final.y=F;D(e.crop,!0)&&
(k=a.getBBox().width,v=null,E-k<n&&1===g?(v=Math.round(k-E+n),M[3]=Math.max(v,M[3])):E+k>t-n&&0===g&&(v=Math.round(E+k-t+n),M[1]=Math.max(v,M[1])),0>F-z/2?M[0]=Math.max(Math.round(-F+z/2),M[0]):F+z/2>u&&(M[2]=Math.max(Math.round(F+z/2-u),M[2])),a.sideOverflow=v)}}}),0===q(M)||this.verifyDataLabelOverflow(M))&&(this.placeDataLabels(),this.points.forEach(function(c){O=H(e,c.options.dataLabels);if(l=D(O.connectorWidth,1)){var d;x=c.connector;if((a=c.dataLabel)&&a._pos&&c.visible&&0<c.labelDistance){L=
a._attr.visibility;if(d=!x)c.connector=x=h.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-"+c.colorIndex+(c.className?" "+c.className:"")).add(b.dataLabelsGroup),h.styledMode||x.attr({"stroke-width":l,stroke:O.connectorColor||c.color||"#666666"});x[d?"attr":"animate"]({d:c.getConnectorPath()});x.attr("visibility",L)}else x&&(c.connector=x.destroy())}}))},m.pie.prototype.placeDataLabels=function(){this.points.forEach(function(b){var d=b.dataLabel,f;d&&b.visible&&((f=d._pos)?
(d.sideOverflow&&(d._attr.width=Math.max(d.getBBox().width-d.sideOverflow,0),d.css({width:d._attr.width+"px",textOverflow:(this.options.dataLabels.style||{}).textOverflow||"ellipsis"}),d.shortened=!0),d.attr(d._attr),d[d.moved?"animate":"attr"](f),d.moved=!0):d&&d.attr({y:-9999}));delete b.distributeBox},this)},m.pie.prototype.alignDataLabel=f,m.pie.prototype.verifyDataLabelOverflow=function(b){var d=this.center,f=this.options,h=f.center,e=f.minSize||80,m=null!==f.size;if(!m){if(null!==h[0])var l=
Math.max(d[2]-Math.max(b[1],b[3]),e);else l=Math.max(d[2]-b[1]-b[3],e),d[0]+=(b[3]-b[1])/2;null!==h[1]?l=M(l,e,d[2]-Math.max(b[0],b[2])):(l=M(l,e,d[2]-b[0]-b[2]),d[1]+=(b[0]-b[2])/2);l<d[2]?(d[2]=l,d[3]=Math.min(w(f.innerSize||0,l),l),this.translate(d),this.drawDataLabels&&this.drawDataLabels()):m=!0}return m});m.column&&(m.column.prototype.alignDataLabel=function(b,d,f,h,e){var g=this.chart.inverted,l=b.series,m=b.dlBox||b.shapeArgs,n=D(b.below,b.plotY>D(this.translatedThreshold,l.yAxis.len)),q=
D(f.inside,!!this.options.stacking);m&&(h=H(m),0>h.y&&(h.height+=h.y,h.y=0),m=h.y+h.height-l.yAxis.len,0<m&&m<h.height&&(h.height-=m),g&&(h={x:l.yAxis.len-h.y-h.height,y:l.xAxis.len-h.x-h.width,width:h.height,height:h.width}),q||(g?(h.x+=n?0:h.width,h.width=0):(h.y+=n?h.height:0,h.height=0)));f.align=D(f.align,!g||q?"center":n?"right":"left");f.verticalAlign=D(f.verticalAlign,g||q?"middle":n?"top":"bottom");N.prototype.alignDataLabel.call(this,b,d,f,h,e);f.inside&&b.contrastColor&&d.css({color:b.contrastColor})})});
Q(A,"modules/overlapping-datalabels.src.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var A=f.addEvent,q=f.fireEvent,M=f.isArray,K=f.objectEach,J=f.pick;d=d.Chart;A(d,"render",function(){var d=[];(this.labelCollectors||[]).forEach(function(f){d=d.concat(f())});(this.yAxis||[]).forEach(function(f){f.stacking&&f.options.stackLabels&&!f.options.stackLabels.allowOverlap&&K(f.stacking.stacks,function(f){K(f,function(f){d.push(f.label)})})});(this.series||[]).forEach(function(f){var q=
f.options.dataLabels;f.visible&&(!1!==q.enabled||f._hasPointLabels)&&(f.nodes||f.points).forEach(function(f){f.visible&&(M(f.dataLabels)?f.dataLabels:f.dataLabel?[f.dataLabel]:[]).forEach(function(q){var x=q.options;q.labelrank=J(x.labelrank,f.labelrank,f.shapeArgs&&f.shapeArgs.height);x.allowOverlap||d.push(q)})})});this.hideOverlappingLabels(d)});d.prototype.hideOverlappingLabels=function(d){var f=this,A=d.length,E=f.renderer,C,D,w,n=!1;var t=function(b){var d,f=b.box?0:b.padding||0,h=d=0,e;if(b&&
(!b.alignAttr||b.placed)){var m=b.alignAttr||{x:b.attr("x"),y:b.attr("y")};var l=b.parentGroup;b.width||(d=b.getBBox(),b.width=d.width,b.height=d.height,d=E.fontMetrics(null,b.element).h);var n=b.width-2*f;(e={left:"0",center:"0.5",right:"1"}[b.alignValue])?h=+e*n:Math.round(b.x)!==b.translateX&&(h=b.x-b.translateX);return{x:m.x+(l.translateX||0)+f-h,y:m.y+(l.translateY||0)+f-d,width:b.width-2*f,height:b.height-2*f}}};for(D=0;D<A;D++)if(C=d[D])C.oldOpacity=C.opacity,C.newOpacity=1,C.absoluteBox=t(C);
d.sort(function(b,d){return(d.labelrank||0)-(b.labelrank||0)});for(D=0;D<A;D++){var J=(t=d[D])&&t.absoluteBox;for(C=D+1;C<A;++C){var m=(w=d[C])&&w.absoluteBox;!J||!m||t===w||0===t.newOpacity||0===w.newOpacity||m.x>J.x+J.width||m.x+m.width<J.x||m.y>J.y+J.height||m.y+m.height<J.y||((t.labelrank<w.labelrank?t:w).newOpacity=0)}}d.forEach(function(b){if(b){var d=b.newOpacity;b.oldOpacity!==d&&(b.alignAttr&&b.placed?(b[d?"removeClass":"addClass"]("highcharts-data-label-hidden"),n=!0,b.alignAttr.opacity=
d,b[b.isOld?"animate":"attr"](b.alignAttr,null,function(){f.styledMode||b.css({pointerEvents:d?"auto":"none"});b.visibility=d?"inherit":"hidden";b.placed=!!d}),q(f,"afterHideOverlappingLabel")):b.attr({opacity:d}));b.isOld=!0}});n&&q(f,"afterHideAllOverlappingLabels")}});Q(A,"parts/Interaction.js",[A["parts/Globals.js"],A["parts/Legend.js"],A["parts/Point.js"],A["parts/Utilities.js"]],function(d,f,A,q){var E=q.addEvent,K=q.createElement,J=q.css,L=q.defined,x=q.extend,F=q.fireEvent,H=q.isArray,C=q.isFunction,
D=q.isNumber,w=q.isObject,n=q.merge,t=q.objectEach,N=q.pick;q=d.Chart;var m=d.defaultOptions,b=d.defaultPlotOptions,g=d.hasTouch,v=d.Series,h=d.seriesTypes,e=d.svg;var p=d.TrackerMixin={drawTrackerPoint:function(){var b=this,d=b.chart,e=d.pointer,f=function(b){var d=e.getPointFromEvent(b);"undefined"!==typeof d&&(e.isDirectTouch=!0,d.onMouseOver(b))},h;b.points.forEach(function(b){h=H(b.dataLabels)?b.dataLabels:b.dataLabel?[b.dataLabel]:[];b.graphic&&(b.graphic.element.point=b);h.forEach(function(d){d.div?
d.div.point=b:d.element.point=b})});b._hasTracking||(b.trackerGroups.forEach(function(l){if(b[l]){b[l].addClass("highcharts-tracker").on("mouseover",f).on("mouseout",function(b){e.onTrackerMouseOut(b)});if(g)b[l].on("touchstart",f);!d.styledMode&&b.options.cursor&&b[l].css(J).css({cursor:b.options.cursor})}}),b._hasTracking=!0);F(this,"afterDrawTracker")},drawTrackerGraph:function(){var b=this,d=b.options,f=d.trackByArea,h=[].concat(f?b.areaPath:b.graphPath),m=b.chart,n=m.pointer,p=m.renderer,q=m.options.tooltip.snap,
c=b.tracker,a=function(a){if(m.hoverSeries!==b)b.onMouseOver()},k="rgba(192,192,192,"+(e?.0001:.002)+")";c?c.attr({d:h}):b.graph&&(b.tracker=p.path(h).attr({visibility:b.visible?"visible":"hidden",zIndex:2}).addClass(f?"highcharts-tracker-area":"highcharts-tracker-line").add(b.group),m.styledMode||b.tracker.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:k,fill:f?k:"none","stroke-width":b.graph.strokeWidth()+(f?0:2*q)}),[b.tracker,b.markerGroup].forEach(function(c){c.addClass("highcharts-tracker").on("mouseover",
a).on("mouseout",function(a){n.onTrackerMouseOut(a)});d.cursor&&!m.styledMode&&c.css({cursor:d.cursor});if(g)c.on("touchstart",a)}));F(this,"afterDrawTracker")}};h.column&&(h.column.prototype.drawTracker=p.drawTrackerPoint);h.pie&&(h.pie.prototype.drawTracker=p.drawTrackerPoint);h.scatter&&(h.scatter.prototype.drawTracker=p.drawTrackerPoint);x(f.prototype,{setItemEvents:function(b,d,e){var f=this,g=f.chart.renderer.boxWrapper,l=b instanceof A,h="highcharts-legend-"+(l?"point":"series")+"-active",
m=f.chart.styledMode;(e?[d,b.legendSymbol]:[b.legendGroup]).forEach(function(c){if(c)c.on("mouseover",function(){b.visible&&f.allItems.forEach(function(a){b!==a&&a.setState("inactive",!l)});b.setState("hover");b.visible&&g.addClass(h);m||d.css(f.options.itemHoverStyle)}).on("mouseout",function(){f.chart.styledMode||d.css(n(b.visible?f.itemStyle:f.itemHiddenStyle));f.allItems.forEach(function(a){b!==a&&a.setState("",!l)});g.removeClass(h);b.setState()}).on("click",function(a){var c=function(){b.setVisible&&
b.setVisible();f.allItems.forEach(function(a){b!==a&&a.setState(b.visible?"inactive":"",!l)})};g.removeClass(h);a={browserEvent:a};b.firePointEvent?b.firePointEvent("legendItemClick",a,c):F(b,"legendItemClick",a,c)})})},createCheckboxForItem:function(b){b.checkbox=K("input",{type:"checkbox",className:"highcharts-legend-checkbox",checked:b.selected,defaultChecked:b.selected},this.options.itemCheckboxStyle,this.chart.container);E(b.checkbox,"click",function(d){F(b.series||b,"checkboxClick",{checked:d.target.checked,
item:b},function(){b.select()})})}});x(q.prototype,{showResetZoom:function(){function b(){d.zoomOut()}var d=this,e=m.lang,f=d.options.chart.resetZoomButton,g=f.theme,h=g.states,n="chart"===f.relativeTo||"spaceBox"===f.relativeTo?null:"plotBox";F(this,"beforeShowResetZoom",null,function(){d.resetZoomButton=d.renderer.button(e.resetZoom,null,null,b,g,h&&h.hover).attr({align:f.position.align,title:e.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(f.position,!1,n)});F(this,"afterShowResetZoom")},
zoomOut:function(){F(this,"selection",{resetSelection:!0},this.zoom)},zoom:function(b){var d=this,e,f=d.pointer,g=!1,l=d.inverted?f.mouseDownX:f.mouseDownY;!b||b.resetSelection?(d.axes.forEach(function(b){e=b.zoom()}),f.initiated=!1):b.xAxis.concat(b.yAxis).forEach(function(b){var c=b.axis,a=d.inverted?c.left:c.top,k=d.inverted?a+c.width:a+c.height,h=c.isXAxis,m=!1;if(!h&&l>=a&&l<=k||h||!L(l))m=!0;f[h?"zoomX":"zoomY"]&&m&&(e=c.zoom(b.min,b.max),c.displayBtn&&(g=!0))});var h=d.resetZoomButton;g&&!h?
d.showResetZoom():!g&&w(h)&&(d.resetZoomButton=h.destroy());e&&d.redraw(N(d.options.chart.animation,b&&b.animation,100>d.pointCount))},pan:function(b,e){var f=this,g=f.hoverPoints,l=f.options.chart,h=f.options.mapNavigation&&f.options.mapNavigation.enabled,m;e="object"===typeof e?e:{enabled:e,type:"x"};l&&l.panning&&(l.panning=e);var n=e.type;F(this,"pan",{originalEvent:b},function(){g&&g.forEach(function(a){a.setState()});var c=[1];"xy"===n?c=[1,0]:"y"===n&&(c=[0]);c.forEach(function(a){var c=f[a?
"xAxis":"yAxis"][0],e=c.options,g=c.horiz,l=b[g?"chartX":"chartY"];g=g?"mouseDownX":"mouseDownY";var p=f[g],q=(c.pointRange||0)/2,u=c.reversed&&!f.inverted||!c.reversed&&f.inverted?-1:1,t=c.getExtremes(),v=c.toValue(p-l,!0)+q*u;u=c.toValue(p+c.len-l,!0)-q*u;var w=u<v;p=w?u:v;v=w?v:u;var y=c.hasVerticalPanning(),x=c.panningState;c.series.forEach(function(b){if(y&&!a&&(!x||x.isDirty)){var c=b.getProcessedData(!0);b=b.getExtremes(c.yData,!0);x||(x={startMin:Number.MAX_VALUE,startMax:-Number.MAX_VALUE});
D(b.dataMin)&&D(b.dataMax)&&(x.startMin=Math.min(b.dataMin,x.startMin),x.startMax=Math.max(b.dataMax,x.startMax))}});u=Math.min(d.pick(null===x||void 0===x?void 0:x.startMin,t.dataMin),q?t.min:c.toValue(c.toPixels(t.min)-c.minPixelPadding));q=Math.max(d.pick(null===x||void 0===x?void 0:x.startMax,t.dataMax),q?t.max:c.toValue(c.toPixels(t.max)+c.minPixelPadding));c.panningState=x;if(!e.ordinal){e=u-p;0<e&&(v+=e,p=u);e=v-q;0<e&&(v=q,p-=e);if(c.series.length&&p!==t.min&&v!==t.max&&a||x&&p>=u&&v<=q)c.setExtremes(p,
v,!1,!1,{trigger:"pan"}),f.resetZoomButton||h||!n.match("y")||(f.showResetZoom(),c.displayBtn=!1),m=!0;f[g]=l}});m&&f.redraw(!1);J(f.container,{cursor:"move"})})}});x(A.prototype,{select:function(b,d){var e=this,f=e.series,g=f.chart;this.selectedStaging=b=N(b,!e.selected);e.firePointEvent(b?"select":"unselect",{accumulate:d},function(){e.selected=e.options.selected=b;f.options.data[f.data.indexOf(e)]=e.options;e.setState(b&&"select");d||g.getSelectedPoints().forEach(function(b){var d=b.series;b.selected&&
b!==e&&(b.selected=b.options.selected=!1,d.options.data[d.data.indexOf(b)]=b.options,b.setState(g.hoverPoints&&d.options.inactiveOtherPoints?"inactive":""),b.firePointEvent("unselect"))})});delete this.selectedStaging},onMouseOver:function(b){var d=this.series.chart,e=d.pointer;b=b?e.normalize(b):e.getChartCoordinatesFromPoint(this,d.inverted);e.runPointActions(b,this)},onMouseOut:function(){var b=this.series.chart;this.firePointEvent("mouseOut");this.series.options.inactiveOtherPoints||(b.hoverPoints||
[]).forEach(function(b){b.setState()});b.hoverPoints=b.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var b=this,d=n(b.series.options.point,b.options).events;b.events=d;t(d,function(d,e){C(d)&&E(b,e,d)});this.hasImportedEvents=!0}},setState:function(d,e){var f=this.series,g=this.state,l=f.options.states[d||"normal"]||{},h=b[f.type].marker&&f.options.marker,m=h&&!1===h.enabled,n=h&&h.states&&h.states[d||"normal"]||{},c=!1===n.enabled,a=f.stateMarkerGraphic,k=this.marker||{},p=
f.chart,q=f.halo,t,v=h&&f.markerAttribs;d=d||"";if(!(d===this.state&&!e||this.selected&&"select"!==d||!1===l.enabled||d&&(c||m&&!1===n.enabled)||d&&k.states&&k.states[d]&&!1===k.states[d].enabled)){this.state=d;v&&(t=f.markerAttribs(this,d));if(this.graphic){g&&this.graphic.removeClass("highcharts-point-"+g);d&&this.graphic.addClass("highcharts-point-"+d);if(!p.styledMode){var w=f.pointAttribs(this,d);var A=N(p.options.chart.animation,l.animation);f.options.inactiveOtherPoints&&w.opacity&&((this.dataLabels||
[]).forEach(function(a){a&&a.animate({opacity:w.opacity},A)}),this.connector&&this.connector.animate({opacity:w.opacity},A));this.graphic.animate(w,A)}t&&this.graphic.animate(t,N(p.options.chart.animation,n.animation,h.animation));a&&a.hide()}else{if(d&&n){g=k.symbol||f.symbol;a&&a.currentSymbol!==g&&(a=a.destroy());if(t)if(a)a[e?"animate":"attr"]({x:t.x,y:t.y});else g&&(f.stateMarkerGraphic=a=p.renderer.symbol(g,t.x,t.y,t.width,t.height).add(f.markerGroup),a.currentSymbol=g);!p.styledMode&&a&&a.attr(f.pointAttribs(this,
d))}a&&(a[d&&this.isInside?"show":"hide"](),a.element.point=this)}d=l.halo;l=(a=this.graphic||a)&&a.visibility||"inherit";d&&d.size&&a&&"hidden"!==l&&!this.isCluster?(q||(f.halo=q=p.renderer.path().add(a.parentGroup)),q.show()[e?"animate":"attr"]({d:this.haloPath(d.size)}),q.attr({"class":"highcharts-halo highcharts-color-"+N(this.colorIndex,f.colorIndex)+(this.className?" "+this.className:""),visibility:l,zIndex:-1}),q.point=this,p.styledMode||q.attr(x({fill:this.color||f.color,"fill-opacity":d.opacity},
d.attributes))):q&&q.point&&q.point.haloPath&&q.animate({d:q.point.haloPath(0)},null,q.hide);F(this,"afterSetState")}},haloPath:function(b){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-b,this.plotY-b,2*b,2*b)}});x(v.prototype,{onMouseOver:function(){var b=this.chart,d=b.hoverSeries;b.pointer.setHoverChartIndex();if(d&&d!==this)d.onMouseOut();this.options.events.mouseOver&&F(this,"mouseOver");this.setState("hover");b.hoverSeries=this},onMouseOut:function(){var b=this.options,
d=this.chart,e=d.tooltip,f=d.hoverPoint;d.hoverSeries=null;if(f)f.onMouseOut();this&&b.events.mouseOut&&F(this,"mouseOut");!e||this.stickyTracking||e.shared&&!this.noSharedTooltip||e.hide();d.series.forEach(function(b){b.setState("",!0)})},setState:function(b,d){var e=this,f=e.options,g=e.graph,l=f.inactiveOtherPoints,h=f.states,m=f.lineWidth,c=f.opacity,a=N(h[b||"normal"]&&h[b||"normal"].animation,e.chart.options.chart.animation);f=0;b=b||"";if(e.state!==b&&([e.group,e.markerGroup,e.dataLabelsGroup].forEach(function(a){a&&
(e.state&&a.removeClass("highcharts-series-"+e.state),b&&a.addClass("highcharts-series-"+b))}),e.state=b,!e.chart.styledMode)){if(h[b]&&!1===h[b].enabled)return;b&&(m=h[b].lineWidth||m+(h[b].lineWidthPlus||0),c=N(h[b].opacity,c));if(g&&!g.dashstyle)for(h={"stroke-width":m},g.animate(h,a);e["zone-graph-"+f];)e["zone-graph-"+f].attr(h),f+=1;l||[e.group,e.markerGroup,e.dataLabelsGroup,e.labelBySeries].forEach(function(b){b&&b.animate({opacity:c},a)})}d&&l&&e.points&&e.setAllPointsToState(b)},setAllPointsToState:function(b){this.points.forEach(function(d){d.setState&&
d.setState(b)})},setVisible:function(b,d){var e=this,f=e.chart,g=e.legendItem,h=f.options.chart.ignoreHiddenSeries,l=e.visible;var m=(e.visible=b=e.options.visible=e.userOptions.visible="undefined"===typeof b?!l:b)?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(function(b){if(e[b])e[b][m]()});if(f.hoverSeries===e||(f.hoverPoint&&f.hoverPoint.series)===e)e.onMouseOut();g&&f.legend.colorizeItem(e,b);e.isDirty=!0;e.options.stacking&&f.series.forEach(function(b){b.options.stacking&&
b.visible&&(b.isDirty=!0)});e.linkedSeries.forEach(function(c){c.setVisible(b,!1)});h&&(f.isDirtyBox=!0);F(e,m);!1!==d&&f.redraw()},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(b){this.selected=b=this.options.selected="undefined"===typeof b?!this.selected:b;this.checkbox&&(this.checkbox.checked=b);F(this,b?"select":"unselect")},drawTracker:p.drawTrackerGraph})});Q(A,"parts/Responsive.js",[A["parts/Globals.js"],A["parts/Utilities.js"]],function(d,f){var A=
f.find,q=f.isArray,M=f.isObject,K=f.merge,J=f.objectEach,L=f.pick,x=f.splat,F=f.uniqueKey;d=d.Chart;d.prototype.setResponsive=function(d,f){var q=this.options.responsive,w=[],n=this.currentResponsive;!f&&q&&q.rules&&q.rules.forEach(function(d){"undefined"===typeof d._id&&(d._id=F());this.matchResponsiveRule(d,w)},this);f=K.apply(0,w.map(function(d){return A(q.rules,function(f){return f._id===d}).chartOptions}));f.isResponsiveOptions=!0;w=w.toString()||void 0;w!==(n&&n.ruleIds)&&(n&&this.update(n.undoOptions,
d,!0),w?(n=this.currentOptions(f),n.isResponsiveOptions=!0,this.currentResponsive={ruleIds:w,mergedOptions:f,undoOptions:n},this.update(f,d,!0)):this.currentResponsive=void 0)};d.prototype.matchResponsiveRule=function(d,f){var q=d.condition;(q.callback||function(){return this.chartWidth<=L(q.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=L(q.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=L(q.minWidth,0)&&this.chartHeight>=L(q.minHeight,0)}).call(this)&&f.push(d._id)};d.prototype.currentOptions=function(d){function f(d,
t,w,m){var b;J(d,function(d,n){if(!m&&-1<A.collectionsWithUpdate.indexOf(n))for(d=x(d),w[n]=[],b=0;b<d.length;b++)t[n][b]&&(w[n][b]={},f(d[b],t[n][b],w[n][b],m+1));else M(d)?(w[n]=q(d)?[]:{},f(d,t[n]||{},w[n],m+1)):w[n]="undefined"===typeof t[n]?null:t[n]})}var A=this,w={};f(d,this.options,w,0);return w}});Q(A,"masters/highcharts.src.js",[A["parts/Globals.js"]],function(d){return d});A["masters/highcharts.src.js"]._modules=A;return A["masters/highcharts.src.js"]});
//# sourceMappingURL=highcharts.js.map
},{}],100:[function(require,module,exports){
'use strict';

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

},{}],101:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":102,"./lib/stringify":103}],102:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],103:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],104:[function(require,module,exports){
var Pointable = require('./pointable'),
  glMatrix = require("gl-matrix")
  , vec3 = glMatrix.vec3
  , mat3 = glMatrix.mat3
  , mat4 = glMatrix.mat4
  , _ = require('underscore');


var Bone = module.exports = function(finger, data) {
  this.finger = finger;

  this._center = null, this._matrix = null;

  /**
  * An integer code for the name of this bone.
  *
  * * 0 -- metacarpal
  * * 1 -- proximal
  * * 2 -- medial
  * * 3 -- distal
  * * 4 -- arm
  *
  * @member type
  * @type {number}
  * @memberof Leap.Bone.prototype
  */
  this.type = data.type;

  /**
   * The position of the previous, or base joint of the bone closer to the wrist.
   * @type {vector3}
   */
  this.prevJoint = data.prevJoint;

  /**
   * The position of the next joint, or the end of the bone closer to the finger tip.
   * @type {vector3}
   */
  this.nextJoint = data.nextJoint;

  /**
   * The estimated width of the tool in millimeters.
   *
   * The reported width is the average width of the visible portion of the
   * tool from the hand to the tip. If the width isn't known,
   * then a value of 0 is returned.
   *
   * Pointable objects representing fingers do not have a width property.
   *
   * @member width
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.width = data.width;

  var displacement = new Array(3);
  vec3.sub(displacement, data.nextJoint, data.prevJoint);

  this.length = vec3.length(displacement);


  /**
   *
   * These fully-specify the orientation of the bone.
   * See examples/threejs-bones.html for more info
   * Three vec3s:
   *  x (red): The rotation axis of the finger, pointing outwards.  (In general, away from the thumb )
   *  y (green): The "up" vector, orienting the top of the finger
   *  z (blue): The roll axis of the bone.
   *
   *  Most up vectors will be pointing the same direction, except for the thumb, which is more rightwards.
   *
   *  The thumb has one fewer bones than the fingers, but there are the same number of joints & joint-bases provided
   *  the first two appear in the same position, but only the second (proximal) rotates.
   *
   *  Normalized.
   */
  this.basis = data.basis;
};

Bone.prototype.left = function(){

  if (this._left) return this._left;

  this._left =  mat3.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])) < 0;

  return this._left;

};


/**
 * The Affine transformation matrix describing the orientation of the bone, in global Leap-space.
 * It contains a 3x3 rotation matrix (in the "top left"), and center coordinates in the fourth column.
 *
 * Unlike the basis, the right and left hands have the same coordinate system.
 *
 */
Bone.prototype.matrix = function(){

  if (this._matrix) return this._matrix;

  var b = this.basis,
      t = this._matrix = mat4.create();

  // open transform mat4 from rotation mat3
  t[0] = b[0][0], t[1] = b[0][1], t[2]  = b[0][2];
  t[4] = b[1][0], t[5] = b[1][1], t[6]  = b[1][2];
  t[8] = b[2][0], t[9] = b[2][1], t[10] = b[2][2];

  t[3] = this.center()[0];
  t[7] = this.center()[1];
  t[11] = this.center()[2];

  if ( this.left() ) {
    // flip the basis to be right-handed
    t[0] *= -1;
    t[1] *= -1;
    t[2] *= -1;
  }

  return this._matrix;
};

/**
 * Helper method to linearly interpolate between the two ends of the bone.
 *
 * when t = 0, the position of prevJoint will be returned
 * when t = 1, the position of nextJoint will be returned
 */
Bone.prototype.lerp = function(out, t){

  vec3.lerp(out, this.prevJoint, this.nextJoint, t);

};

/**
 *
 * The center position of the bone
 * Returns a vec3 array.
 *
 */
Bone.prototype.center = function(){

  if (this._center) return this._center;

  var center = vec3.create();
  this.lerp(center, 0.5);
  this._center = center;
  return center;

};

// The negative of the z-basis
Bone.prototype.direction = function(){

 return [
   this.basis[2][0] * -1,
   this.basis[2][1] * -1,
   this.basis[2][2] * -1
 ];

};

},{"./pointable":118,"gl-matrix":98,"underscore":145}],105:[function(require,module,exports){
var CircularBuffer = module.exports = function(size) {
  this.pos = 0;
  this._buf = [];
  this.size = size;
}

CircularBuffer.prototype.get = function(i) {
  if (i == undefined) i = 0;
  if (i >= this.size) return undefined;
  if (i >= this._buf.length) return undefined;
  return this._buf[(this.pos - i - 1) % this.size];
}

CircularBuffer.prototype.push = function(o) {
  this._buf[this.pos % this.size] = o;
  return this.pos++;
}

},{}],106:[function(require,module,exports){
var chooseProtocol = require('../protocol').chooseProtocol
  , EventEmitter = require('events').EventEmitter
  , _ = require('underscore');

var BaseConnection = module.exports = function(opts) {
  this.opts = _.defaults(opts || {}, {
    host : '127.0.0.1',
    enableGestures: false,
    scheme: this.getScheme(),
    port: this.getPort(),
    background: false,
    optimizeHMD: false,
    requestProtocolVersion: BaseConnection.defaultProtocolVersion
  });
  this.host = this.opts.host;
  this.port = this.opts.port;
  this.scheme = this.opts.scheme;
  this.protocolVersionVerified = false;
  this.background = null;
  this.optimizeHMD = null;
  this.on('ready', function() {
    this.enableGestures(this.opts.enableGestures);
    this.setBackground(this.opts.background);
    this.setOptimizeHMD(this.opts.optimizeHMD);

    if (this.opts.optimizeHMD){
      console.log("Optimized for head mounted display usage.");
    }else {
      console.log("Optimized for desktop usage.");
    }

  });
};

// The latest available:
BaseConnection.defaultProtocolVersion = 6;

BaseConnection.prototype.getUrl = function() {
  return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
}


BaseConnection.prototype.getScheme = function(){
  return 'ws:'
}

BaseConnection.prototype.getPort = function(){
  return 6437
}


BaseConnection.prototype.setBackground = function(state) {
  this.opts.background = state;
  if (this.protocol && this.protocol.sendBackground && this.background !== this.opts.background) {
    this.background = this.opts.background;
    this.protocol.sendBackground(this, this.opts.background);
  }
}

BaseConnection.prototype.setOptimizeHMD = function(state) {
  this.opts.optimizeHMD = state;
  if (this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD) {
    this.optimizeHMD = this.opts.optimizeHMD;
    this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD);
  }
}

BaseConnection.prototype.handleOpen = function() {
  if (!this.connected) {
    this.connected = true;
    this.emit('connect');
  }
}

BaseConnection.prototype.enableGestures = function(enabled) {
  this.gesturesEnabled = enabled ? true : false;
  this.send(this.protocol.encode({"enableGestures": this.gesturesEnabled}));
}

BaseConnection.prototype.handleClose = function(code, reason) {
  if (!this.connected) return;
  this.disconnect();

  // 1001 - an active connection is closed
  // 1006 - cannot connect
  if (code === 1001 && this.opts.requestProtocolVersion > 1) {
    if (this.protocolVersionVerified) {
      this.protocolVersionVerified = false;
    }else{
      this.opts.requestProtocolVersion--;
    }
  }
  this.startReconnection();
}

BaseConnection.prototype.startReconnection = function() {
  var connection = this;
  if(!this.reconnectionTimer){
    (this.reconnectionTimer = setInterval(function() { connection.reconnect() }, 500));
  }
}

BaseConnection.prototype.stopReconnection = function() {
  this.reconnectionTimer = clearInterval(this.reconnectionTimer);
}

// By default, disconnect will prevent auto-reconnection.
// Pass in true to allow the reconnection loop not be interrupted continue
BaseConnection.prototype.disconnect = function(allowReconnect) {
  if (!allowReconnect) this.stopReconnection();
  if (!this.socket) return;
  this.socket.close();
  delete this.socket;
  delete this.protocol;
  delete this.background; // This is not persisted when reconnecting to the web socket server
  delete this.optimizeHMD;
  delete this.focusedState;
  if (this.connected) {
    this.connected = false;
    this.emit('disconnect');
  }
  return true;
}

BaseConnection.prototype.reconnect = function() {
  if (this.connected) {
    this.stopReconnection();
  } else {
    this.disconnect(true);
    this.connect();
  }
}

BaseConnection.prototype.handleData = function(data) {
  var message = JSON.parse(data);

  var messageEvent;
  if (this.protocol === undefined) {
    messageEvent = this.protocol = chooseProtocol(message);
    this.protocolVersionVerified = true;
    this.emit('ready');
  } else {
    messageEvent = this.protocol(message);
  }
  this.emit(messageEvent.type, messageEvent);
}

BaseConnection.prototype.connect = function() {
  if (this.socket) return;
  this.socket = this.setupSocket();
  return true;
}

BaseConnection.prototype.send = function(data) {
  this.socket.send(data);
}

BaseConnection.prototype.reportFocus = function(state) {
  if (!this.connected || this.focusedState === state) return;
  this.focusedState = state;
  this.emit(this.focusedState ? 'focus' : 'blur');
  if (this.protocol && this.protocol.sendFocused) {
    this.protocol.sendFocused(this, this.focusedState);
  }
}

_.extend(BaseConnection.prototype, EventEmitter.prototype);
},{"../protocol":119,"events":155,"underscore":145}],107:[function(require,module,exports){
var BaseConnection = module.exports = require('./base')
  , _ = require('underscore');


var BrowserConnection = module.exports = function(opts) {
  BaseConnection.call(this, opts);
  var connection = this;
  this.on('ready', function() { connection.startFocusLoop(); })
  this.on('disconnect', function() { connection.stopFocusLoop(); })
}

_.extend(BrowserConnection.prototype, BaseConnection.prototype);

BrowserConnection.__proto__ = BaseConnection;

BrowserConnection.prototype.useSecure = function(){
  return location.protocol === 'https:'
}

BrowserConnection.prototype.getScheme = function(){
  return this.useSecure() ? 'wss:' : 'ws:'
}

BrowserConnection.prototype.getPort = function(){
  return this.useSecure() ? 6436 : 6437
}

BrowserConnection.prototype.setupSocket = function() {
  var connection = this;
  var socket = new WebSocket(this.getUrl());
  socket.onopen = function() { connection.handleOpen(); };
  socket.onclose = function(data) { connection.handleClose(data['code'], data['reason']); };
  socket.onmessage = function(message) { connection.handleData(message.data) };
  socket.onerror = function(error) {

    // attempt to degrade to ws: after one failed attempt for older Leap Service installations.
    if (connection.useSecure() && connection.scheme === 'wss:'){
      connection.scheme = 'ws:';
      connection.port = 6437;
      connection.disconnect();
      connection.connect();
    }

  };
  return socket;
}

BrowserConnection.prototype.startFocusLoop = function() {
  if (this.focusDetectorTimer) return;
  var connection = this;
  var propertyName = null;
  if (typeof document.hidden !== "undefined") {
    propertyName = "hidden";
  } else if (typeof document.mozHidden !== "undefined") {
    propertyName = "mozHidden";
  } else if (typeof document.msHidden !== "undefined") {
    propertyName = "msHidden";
  } else if (typeof document.webkitHidden !== "undefined") {
    propertyName = "webkitHidden";
  } else {
    propertyName = undefined;
  }

  if (connection.windowVisible === undefined) {
    connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false;
  }

  var focusListener = window.addEventListener('focus', function(e) {
    connection.windowVisible = true;
    updateFocusState();
  });

  var blurListener = window.addEventListener('blur', function(e) {
    connection.windowVisible = false;
    updateFocusState();
  });

  this.on('disconnect', function() {
    window.removeEventListener('focus', focusListener);
    window.removeEventListener('blur', blurListener);
  });

  var updateFocusState = function() {
    var isVisible = propertyName === undefined ? true : document[propertyName] === false;
    connection.reportFocus(isVisible && connection.windowVisible);
  }

  // save 100ms when resuming focus
  updateFocusState();

  this.focusDetectorTimer = setInterval(updateFocusState, 100);
}

BrowserConnection.prototype.stopFocusLoop = function() {
  if (!this.focusDetectorTimer) return;
  clearTimeout(this.focusDetectorTimer);
  delete this.focusDetectorTimer;
}

},{"./base":106,"underscore":145}],108:[function(require,module,exports){
var WebSocket = require('ws')
  , BaseConnection = require('./base')
  , _ = require('underscore');

var NodeConnection = module.exports = function(opts) {
  BaseConnection.call(this, opts);
  var connection = this;
  this.on('ready', function() { connection.reportFocus(true); });
}

_.extend(NodeConnection.prototype, BaseConnection.prototype);

NodeConnection.__proto__ = BaseConnection;

NodeConnection.prototype.setupSocket = function() {
  var connection = this;
  var socket = new WebSocket(this.getUrl());
  socket.on('open', function() { connection.handleOpen(); });
  socket.on('message', function(m) { connection.handleData(m); });
  socket.on('close', function(code, reason) { connection.handleClose(code, reason); });
  socket.on('error', function() { connection.startReconnection(); });
  return socket;
}

},{"./base":106,"underscore":145,"ws":124}],109:[function(require,module,exports){
(function (process){
var Frame = require('./frame')
  , Hand = require('./hand')
  , Pointable = require('./pointable')
  , Finger = require('./finger')
  , CircularBuffer = require("./circular_buffer")
  , Pipeline = require("./pipeline")
  , EventEmitter = require('events').EventEmitter
  , gestureListener = require('./gesture').gestureListener
  , Dialog = require('./dialog')
  , _ = require('underscore');

/**
 * Constructs a Controller object.
 *
 * When creating a Controller object, you may optionally pass in options
 * to set the host , set the port, enable gestures, or select the frame event type.
 *
 * ```javascript
 * var controller = new Leap.Controller({
 *   host: '127.0.0.1',
 *   port: 6437,
 *   enableGestures: true,
 *   frameEventName: 'animationFrame'
 * });
 * ```
 *
 * @class Controller
 * @memberof Leap
 * @classdesc
 * The Controller class is your main interface to the Leap Motion Controller.
 *
 * Create an instance of this Controller class to access frames of tracking data
 * and configuration information. Frame data can be polled at any time using the
 * [Controller.frame]{@link Leap.Controller#frame}() function. Call frame() or frame(0) to get the most recent
 * frame. Set the history parameter to a positive integer to access previous frames.
 * A controller stores up to 60 frames in its frame history.
 *
 * Polling is an appropriate strategy for applications which already have an
 * intrinsic update loop, such as a game.
 *
 * loopWhileDisconnected defaults to true, and maintains a 60FPS frame rate even when Leap Motion is not streaming
 * data at that rate (such as no hands in frame).  This is important for VR/WebGL apps which rely on rendering for
 * regular visual updates, including from other input devices.  Flipping this to false should be considered an
 * optimization for very specific use-cases.
 *
 *
 */


var Controller = module.exports = function(opts) {
  var inNode = (typeof(process) !== 'undefined' && process.versions && process.versions.node),
    controller = this;

  opts = _.defaults(opts || {}, {
    inNode: inNode
  });

  this.inNode = opts.inNode;

  opts = _.defaults(opts || {}, {
    frameEventName: this.useAnimationLoop() ? 'animationFrame' : 'deviceFrame',
    suppressAnimationLoop: !this.useAnimationLoop(),
    loopWhileDisconnected: true,
    useAllPlugins: false,
    checkVersion: true
  });

  this.animationFrameRequested = false;
  this.onAnimationFrame = function(timestamp) {
    if (controller.lastConnectionFrame.valid){
      controller.emit('animationFrame', controller.lastConnectionFrame);
    }
    controller.emit('frameEnd', timestamp);
    if (
      controller.loopWhileDisconnected &&
      ( ( controller.connection.focusedState !== false )  // loop while undefined, pre-ready.
        || controller.connection.opts.background) ){
      window.requestAnimationFrame(controller.onAnimationFrame);
    }else{
      controller.animationFrameRequested = false;
    }
  };
  this.suppressAnimationLoop = opts.suppressAnimationLoop;
  this.loopWhileDisconnected = opts.loopWhileDisconnected;
  this.frameEventName = opts.frameEventName;
  this.useAllPlugins = opts.useAllPlugins;
  this.history = new CircularBuffer(200);
  this.lastFrame = Frame.Invalid;
  this.lastValidFrame = Frame.Invalid;
  this.lastConnectionFrame = Frame.Invalid;
  this.accumulatedGestures = [];
  this.checkVersion = opts.checkVersion;
  if (opts.connectionType === undefined) {
    this.connectionType = (this.inBrowser() ? require('./connection/browser') : require('./connection/node'));
  } else {
    this.connectionType = opts.connectionType;
  }
  this.connection = new this.connectionType(opts);
  this.streamingCount = 0;
  this.devices = {};
  this.plugins = {};
  this._pluginPipelineSteps = {};
  this._pluginExtendedMethods = {};
  if (opts.useAllPlugins) this.useRegisteredPlugins();
  this.setupFrameEvents(opts);
  this.setupConnectionEvents();
  
  this.startAnimationLoop(); // immediately when started
}

Controller.prototype.gesture = function(type, cb) {
  var creator = gestureListener(this, type);
  if (cb !== undefined) {
    creator.stop(cb);
  }
  return creator;
}

/*
 * @returns the controller
 */
Controller.prototype.setBackground = function(state) {
  this.connection.setBackground(state);
  return this;
}

Controller.prototype.setOptimizeHMD = function(state) {
  this.connection.setOptimizeHMD(state);
  return this;
}

Controller.prototype.inBrowser = function() {
  return !this.inNode;
}

Controller.prototype.useAnimationLoop = function() {
  return this.inBrowser() && !this.inBackgroundPage();
}

Controller.prototype.inBackgroundPage = function(){
  // http://developer.chrome.com/extensions/extension#method-getBackgroundPage
  return (typeof(chrome) !== "undefined") &&
    chrome.extension &&
    chrome.extension.getBackgroundPage &&
    (chrome.extension.getBackgroundPage() === window)
}

/*
 * @returns the controller
 */
Controller.prototype.connect = function() {
  this.connection.connect();
  return this;
}

Controller.prototype.streaming = function() {
  return this.streamingCount > 0;
}

Controller.prototype.connected = function() {
  return !!this.connection.connected;
}

Controller.prototype.startAnimationLoop = function(){
  if (!this.suppressAnimationLoop && !this.animationFrameRequested) {
    this.animationFrameRequested = true;
    window.requestAnimationFrame(this.onAnimationFrame);
  }
}

/*
 * @returns the controller
 */
Controller.prototype.disconnect = function() {
  this.connection.disconnect();
  return this;
}

/**
 * Returns a frame of tracking data from the Leap.
 *
 * Use the optional history parameter to specify which frame to retrieve.
 * Call frame() or frame(0) to access the most recent frame; call frame(1) to
 * access the previous frame, and so on. If you use a history value greater
 * than the number of stored frames, then the controller returns an invalid frame.
 *
 * @method frame
 * @memberof Leap.Controller.prototype
 * @param {number} history The age of the frame to return, counting backwards from
 * the most recent frame (0) into the past and up to the maximum age (59).
 * @returns {Leap.Frame} The specified frame; or, if no history
 * parameter is specified, the newest frame. If a frame is not available at
 * the specified history position, an invalid Frame is returned.
 **/
Controller.prototype.frame = function(num) {
  return this.history.get(num) || Frame.Invalid;
}

Controller.prototype.loop = function(callback) {
  if (callback) {
    if (typeof callback === 'function'){
      this.on(this.frameEventName, callback);
    }else{
      // callback is actually of the form: {eventName: callback}
      this.setupFrameEvents(callback);
    }
  }

  return this.connect();
}

Controller.prototype.addStep = function(step) {
  if (!this.pipeline) this.pipeline = new Pipeline(this);
  this.pipeline.addStep(step);
}

// this is run on every deviceFrame
Controller.prototype.processFrame = function(frame) {
  if (frame.gestures) {
    this.accumulatedGestures = this.accumulatedGestures.concat(frame.gestures);
  }
  // lastConnectionFrame is used by the animation loop
  this.lastConnectionFrame = frame;
  this.startAnimationLoop(); // Only has effect if loopWhileDisconnected: false
  this.emit('deviceFrame', frame);
}

// on a this.deviceEventName (usually 'animationFrame' in browsers), this emits a 'frame'
Controller.prototype.processFinishedFrame = function(frame) {
  this.lastFrame = frame;
  if (frame.valid) {
    this.lastValidFrame = frame;
  }
  frame.controller = this;
  frame.historyIdx = this.history.push(frame);
  if (frame.gestures) {
    frame.gestures = this.accumulatedGestures;
    this.accumulatedGestures = [];
    for (var gestureIdx = 0; gestureIdx != frame.gestures.length; gestureIdx++) {
      this.emit("gesture", frame.gestures[gestureIdx], frame);
    }
  }
  if (this.pipeline) {
    frame = this.pipeline.run(frame);
    if (!frame) frame = Frame.Invalid;
  }
  this.emit('frame', frame);
  this.emitHandEvents(frame);
}

/**
 * The controller will emit 'hand' events for every hand on each frame.  The hand in question will be passed
 * to the event callback.
 *
 * @param frame
 */
Controller.prototype.emitHandEvents = function(frame){
  for (var i = 0; i < frame.hands.length; i++){
    this.emit('hand', frame.hands[i]);
  }
}

Controller.prototype.setupFrameEvents = function(opts){
  if (opts.frame){
    this.on('frame', opts.frame);
  }
  if (opts.hand){
    this.on('hand', opts.hand);
  }
}

/**
  Controller events.  The old 'deviceConnected' and 'deviceDisconnected' have been depricated -
  use 'deviceStreaming' and 'deviceStopped' instead, except in the case of an unexpected disconnect.

  There are 4 pairs of device events recently added/changed:
  -deviceAttached/deviceRemoved - called when a device's physical connection to the computer changes
  -deviceStreaming/deviceStopped - called when a device is paused or resumed.
  -streamingStarted/streamingStopped - called when there is/is no longer at least 1 streaming device.
									  Always comes after deviceStreaming.
  
  The first of all of the above event pairs is triggered as appropriate upon connection.  All of
  these events receives an argument with the most recent info about the device that triggered it.
  These events will always be fired in the order they are listed here, with reverse ordering for the
  matching shutdown call. (ie, deviceStreaming always comes after deviceAttached, and deviceStopped 
  will come before deviceRemoved).
  
  -deviceConnected/deviceDisconnected - These are considered deprecated and will be removed in
  the next revision.  In contrast to the other events and in keeping with it's original behavior,
  it will only be fired when a device begins streaming AFTER a connection has been established.
  It is not paired, and receives no device info.  Nearly identical functionality to
  streamingStarted/Stopped if you need to port.
*/
Controller.prototype.setupConnectionEvents = function() {
  var controller = this;
  this.connection.on('frame', function(frame) {
    controller.processFrame(frame);
  });
  // either deviceFrame or animationFrame:
  this.on(this.frameEventName, function(frame) {
    controller.processFinishedFrame(frame);
  });


  // here we backfill the 0.5.0 deviceEvents as best possible
  // backfill begin streaming events
  var backfillStreamingStartedEventsHandler = function(){
    if (controller.connection.opts.requestProtocolVersion < 5 && controller.streamingCount == 0){
      controller.streamingCount = 1;
      var info = {
        attached: true,
        streaming: true,
        type: 'unknown',
        id: "Lx00000000000"
      };
      controller.devices[info.id] = info;

      controller.emit('deviceAttached', info);
      controller.emit('deviceStreaming', info);
      controller.emit('streamingStarted', info);
      controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler)
    }
  }

  var backfillStreamingStoppedEvents = function(){
    if (controller.streamingCount > 0) {
      for (var deviceId in controller.devices){
        controller.emit('deviceStopped', controller.devices[deviceId]);
        controller.emit('deviceRemoved', controller.devices[deviceId]);
      }
      // only emit streamingStopped once, with the last device
      controller.emit('streamingStopped', controller.devices[deviceId]);

      controller.streamingCount = 0;

      for (var deviceId in controller.devices){
        delete controller.devices[deviceId];
      }
    }
  }
  // Delegate connection events
  this.connection.on('focus', function() {

    if ( controller.loopWhileDisconnected ){

      controller.startAnimationLoop();

    }

    controller.emit('focus');

  });
  this.connection.on('blur', function() { controller.emit('blur') });
  this.connection.on('protocol', function(protocol) {

    protocol.on('beforeFrameCreated', function(frameData){
      controller.emit('beforeFrameCreated', frameData)
    });

    protocol.on('afterFrameCreated', function(frame, frameData){
      controller.emit('afterFrameCreated', frame, frameData)
    });

    controller.emit('protocol', protocol); 
  });

  this.connection.on('ready', function() {

    if (controller.checkVersion && !controller.inNode){
      // show dialog only to web users
      controller.checkOutOfDate();
    }

    controller.emit('ready');
  });

  this.connection.on('connect', function() {
    controller.emit('connect');
    controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler)
    controller.connection.on('frame', backfillStreamingStartedEventsHandler);
  });

  this.connection.on('disconnect', function() {
    controller.emit('disconnect');
    backfillStreamingStoppedEvents();
  });

  // this does not fire when the controller is manually disconnected
  // or for Leap Service v1.2.0+
  this.connection.on('deviceConnect', function(evt) {
    if (evt.state){
      controller.emit('deviceConnected');
      controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler)
      controller.connection.on('frame', backfillStreamingStartedEventsHandler);
    }else{
      controller.emit('deviceDisconnected');
      backfillStreamingStoppedEvents();
    }
  });

  // Does not fire for Leap Service pre v1.2.0
  this.connection.on('deviceEvent', function(evt) {
    var info = evt.state,
        oldInfo = controller.devices[info.id];

    //Grab a list of changed properties in the device info
    var changed = {};
    for(var property in info) {
      //If a property i doesn't exist the cache, or has changed...
      if( !oldInfo || !oldInfo.hasOwnProperty(property) || oldInfo[property] != info[property] ) {
        changed[property] = true;
      }
    }

    //Update the device list
    controller.devices[info.id] = info;

    //Fire events based on change list
    if(changed.attached) {
      controller.emit(info.attached ? 'deviceAttached' : 'deviceRemoved', info);
    }

    if(!changed.streaming) return;

    if(info.streaming) {
      controller.streamingCount++;
      controller.emit('deviceStreaming', info);
      if( controller.streamingCount == 1 ) {
        controller.emit('streamingStarted', info);
      }
      //if attached & streaming both change to true at the same time, that device was streaming
      //already when we connected.
      if(!changed.attached) {
        controller.emit('deviceConnected');
      }
    }
    //Since when devices are attached all fields have changed, don't send events for streaming being false.
    else if(!(changed.attached && info.attached)) {
      controller.streamingCount--;
      controller.emit('deviceStopped', info);
      if(controller.streamingCount == 0){
        controller.emit('streamingStopped', info);
      }
      controller.emit('deviceDisconnected');
    }

  });


  this.on('newListener', function(event, listener) {
    if( event == 'deviceConnected' || event == 'deviceDisconnected' ) {
      console.warn(event + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
    }
  });

};




// Checks if the protocol version is the latest, if if not, shows the dialog.
Controller.prototype.checkOutOfDate = function(){
  console.assert(this.connection && this.connection.protocol);

  var serviceVersion = this.connection.protocol.serviceVersion;
  var protocolVersion = this.connection.protocol.version;
  var defaultProtocolVersion = this.connectionType.defaultProtocolVersion;

  if (defaultProtocolVersion > protocolVersion){

    console.warn("Your Protocol Version is v" + protocolVersion +
        ", this app was designed for v" + defaultProtocolVersion);

    Dialog.warnOutOfDate({
      sV: serviceVersion,
      pV: protocolVersion
    });
    return true
  }else{
    return false
  }

};



Controller._pluginFactories = {};

/*
 * Registers a plugin, making is accessible to controller.use later on.
 *
 * @member plugin
 * @memberof Leap.Controller.prototype
 * @param {String} name The name of the plugin (usually camelCase).
 * @param {function} factory A factory method which will return an instance of a plugin.
 * The factory receives an optional hash of options, passed in via controller.use.
 *
 * Valid keys for the object include frame, hand, finger, tool, and pointable.  The value
 * of each key can be either a function or an object.  If given a function, that function
 * will be called once for every instance of the object, with that instance injected as an
 * argument.  This allows decoration of objects with additional data:
 *
 * ```javascript
 * Leap.Controller.plugin('testPlugin', function(options){
 *   return {
 *     frame: function(frame){
 *       frame.foo = 'bar';
 *     }
 *   }
 * });
 * ```
 *
 * When hand is used, the callback is called for every hand in `frame.hands`.  Note that
 * hand objects are recreated with every new frame, so that data saved on the hand will not
 * persist.
 *
 * ```javascript
 * Leap.Controller.plugin('testPlugin', function(){
 *   return {
 *     hand: function(hand){
 *       console.log('testPlugin running on hand ' + hand.id);
 *     }
 *   }
 * });
 * ```
 *
 * A factory can return an object to add custom functionality to Frames, Hands, or Pointables.
 * The methods are added directly to the object's prototype.  Finger and Tool cannot be used here, Pointable
 * must be used instead.
 * This is encouraged for calculations which may not be necessary on every frame.
 * Memoization is also encouraged, for cases where the method may be called many times per frame by the application.
 *
 * ```javascript
 * // This plugin allows hand.usefulData() to be called later.
 * Leap.Controller.plugin('testPlugin', function(){
 *   return {
 *     hand: {
 *       usefulData: function(){
 *         console.log('usefulData on hand', this.id);
 *         // memoize the results on to the hand, preventing repeat work:
 *         this.x || this.x = someExpensiveCalculation();
 *         return this.x;
 *       }
 *     }
 *   }
 * });
 *
 * Note that the factory pattern allows encapsulation for every plugin instance.
 *
 * ```javascript
 * Leap.Controller.plugin('testPlugin', function(options){
 *   options || options = {}
 *   options.center || options.center = [0,0,0]
 *
 *   privatePrintingMethod = function(){
 *     console.log('privatePrintingMethod - options', options);
 *   }
 *
 *   return {
 *     pointable: {
 *       publicPrintingMethod: function(){
 *         privatePrintingMethod();
 *       }
 *     }
 *   }
 * });
 *
 */
Controller.plugin = function(pluginName, factory) {
  if (this._pluginFactories[pluginName]) {
    console.warn("Plugin \"" + pluginName + "\" already registered");
  }
  return this._pluginFactories[pluginName] = factory;
};

/*
 * Returns a list of registered plugins.
 * @returns {Array} Plugin Factories.
 */
Controller.plugins = function() {
  return _.keys(this._pluginFactories);
};



var setPluginCallbacks = function(pluginName, type, callback){
  
  if ( ['beforeFrameCreated', 'afterFrameCreated'].indexOf(type) != -1 ){
    
      // todo - not able to "unuse" a plugin currently
      this.on(type, callback);
      
    }else {
      
      if (!this.pipeline) this.pipeline = new Pipeline(this);
    
      if (!this._pluginPipelineSteps[pluginName]) this._pluginPipelineSteps[pluginName] = [];

      this._pluginPipelineSteps[pluginName].push(
        
        this.pipeline.addWrappedStep(type, callback)
        
      );
      
    }
  
};

var setPluginMethods = function(pluginName, type, hash){
  var klass;
  
  if (!this._pluginExtendedMethods[pluginName]) this._pluginExtendedMethods[pluginName] = [];

  switch (type) {
    case 'frame':
      klass = Frame;
      break;
    case 'hand':
      klass = Hand;
      break;
    case 'pointable':
      klass = Pointable;
      _.extend(Finger.prototype, hash);
      _.extend(Finger.Invalid,   hash);
      break;
    case 'finger':
      klass = Finger;
      break;
    default:
      throw pluginName + ' specifies invalid object type "' + type + '" for prototypical extension'
  }

  _.extend(klass.prototype, hash);
  _.extend(klass.Invalid, hash);
  this._pluginExtendedMethods[pluginName].push([klass, hash])
  
}



/*
 * Begin using a registered plugin.  The plugin's functionality will be added to all frames
 * returned by the controller (and/or added to the objects within the frame).
 *  - The order of plugin execution inside the loop will match the order in which use is called by the application.
 *  - The plugin be run for both deviceFrames and animationFrames.
 *
 *  If called a second time, the options will be merged with those of the already instantiated plugin.
 *
 * @method use
 * @memberOf Leap.Controller.prototype
 * @param pluginName
 * @param {Hash} Options to be passed to the plugin's factory.
 * @returns the controller
 */
Controller.prototype.use = function(pluginName, options) {
  var functionOrHash, pluginFactory, key, pluginInstance;

  pluginFactory = (typeof pluginName == 'function') ? pluginName : Controller._pluginFactories[pluginName];

  if (!pluginFactory) {
    throw 'Leap Plugin ' + pluginName + ' not found.';
  }

  options || (options = {});

  if (this.plugins[pluginName]){
    _.extend(this.plugins[pluginName], options);
    return this;
  }

  this.plugins[pluginName] = options;

  pluginInstance = pluginFactory.call(this, options);

  for (key in pluginInstance) {

    functionOrHash = pluginInstance[key];

    if (typeof functionOrHash === 'function') {
      
      setPluginCallbacks.call(this, pluginName, key, functionOrHash);
      
    } else {
      
      setPluginMethods.call(this, pluginName, key, functionOrHash);
      
    }

  }

  return this;
};




/*
 * Stop using a used plugin.  This will remove any of the plugin's pipeline methods (those called on every frame)
 * and remove any methods which extend frame-object prototypes.
 *
 * @method stopUsing
 * @memberOf Leap.Controller.prototype
 * @param pluginName
 * @returns the controller
 */
Controller.prototype.stopUsing = function (pluginName) {
  var steps = this._pluginPipelineSteps[pluginName],
      extMethodHashes = this._pluginExtendedMethods[pluginName],
      i = 0, klass, extMethodHash;

  if (!this.plugins[pluginName]) return;

  if (steps) {
    for (i = 0; i < steps.length; i++) {
      this.pipeline.removeStep(steps[i]);
    }
  }

  if (extMethodHashes){
    for (i = 0; i < extMethodHashes.length; i++){
      klass = extMethodHashes[i][0];
      extMethodHash = extMethodHashes[i][1];
      for (var methodName in extMethodHash) {
        delete klass.prototype[methodName];
        delete klass.Invalid[methodName];
      }
    }
  }

  delete this.plugins[pluginName];

  return this;
}

Controller.prototype.useRegisteredPlugins = function(){
  for (var plugin in Controller._pluginFactories){
    this.use(plugin);
  }
}


_.extend(Controller.prototype, EventEmitter.prototype);

}).call(this,require('_process'))
},{"./circular_buffer":105,"./connection/browser":107,"./connection/node":108,"./dialog":110,"./finger":111,"./frame":112,"./gesture":113,"./hand":114,"./pipeline":117,"./pointable":118,"_process":160,"events":155,"underscore":145}],110:[function(require,module,exports){
(function (process){
var Dialog = module.exports = function(message, options){
  this.options = (options || {});
  this.message = message;

  this.createElement();
};

Dialog.prototype.createElement = function(){
  this.element = document.createElement('div');
  this.element.className = "leapjs-dialog";
  this.element.style.position = "fixed";
  this.element.style.top = '8px';
  this.element.style.left = 0;
  this.element.style.right = 0;
  this.element.style.textAlign = 'center';
  this.element.style.zIndex = 1000;

  var dialog  = document.createElement('div');
  this.element.appendChild(dialog);
  dialog.style.className = "leapjs-dialog";
  dialog.style.display = "inline-block";
  dialog.style.margin = "auto";
  dialog.style.padding = "8px";
  dialog.style.color = "#222";
  dialog.style.background = "#eee";
  dialog.style.borderRadius = "4px";
  dialog.style.border = "1px solid #999";
  dialog.style.textAlign = "left";
  dialog.style.cursor = "pointer";
  dialog.style.whiteSpace = "nowrap";
  dialog.style.transition = "box-shadow 1s linear";
  dialog.innerHTML = this.message;


  if (this.options.onclick){
    dialog.addEventListener('click', this.options.onclick);
  }

  if (this.options.onmouseover){
    dialog.addEventListener('mouseover', this.options.onmouseover);
  }

  if (this.options.onmouseout){
    dialog.addEventListener('mouseout', this.options.onmouseout);
  }

  if (this.options.onmousemove){
    dialog.addEventListener('mousemove', this.options.onmousemove);
  }
};

Dialog.prototype.show = function(){
  document.body.appendChild(this.element);
  return this;
};

Dialog.prototype.hide = function(){
  document.body.removeChild(this.element);
  return this;
};




// Shows a DOM dialog box with links to developer.leapmotion.com to upgrade
// This will work whether or not the Leap is plugged in,
// As long as it is called after a call to .connect() and the 'ready' event has fired.
Dialog.warnOutOfDate = function(params){
  params || (params = {});

  var url = "http://developer.leapmotion.com?";

  params.returnTo = window.location.href;

  for (var key in params){
    url += key + '=' + encodeURIComponent(params[key]) + '&';
  }

  var dialog,
    onclick = function(event){

       if (event.target.id != 'leapjs-decline-upgrade'){

         var popup = window.open(url,
           '_blank',
           'height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1'
         );

         if (window.focus) {popup.focus()}

       }

       dialog.hide();

       return true;
    },


    message = "This site requires Leap Motion Tracking V2." +
      "<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button>" +
      "<button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>";

  dialog = new Dialog(message, {
      onclick: onclick,
      onmousemove: function(e){
        if (e.target == document.getElementById('leapjs-decline-upgrade')){
          document.getElementById('leapjs-decline-upgrade').style.color = '#000';
          document.getElementById('leapjs-decline-upgrade').style.boxShadow = '0px 0px 2px #5daa00';

          document.getElementById('leapjs-accept-upgrade').style.color = '#444';
          document.getElementById('leapjs-accept-upgrade').style.boxShadow = 'none';
        }else{
          document.getElementById('leapjs-accept-upgrade').style.color = '#000';
          document.getElementById('leapjs-accept-upgrade').style.boxShadow = '0px 0px 2px #5daa00';

          document.getElementById('leapjs-decline-upgrade').style.color = '#444';
          document.getElementById('leapjs-decline-upgrade').style.boxShadow = 'none';
        }
      },
      onmouseout: function(){
        document.getElementById('leapjs-decline-upgrade').style.color = '#444';
        document.getElementById('leapjs-decline-upgrade').style.boxShadow = 'none';
        document.getElementById('leapjs-accept-upgrade').style.color = '#444';
        document.getElementById('leapjs-accept-upgrade').style.boxShadow = 'none';
      }
    }
  );

  return dialog.show();
};


// Tracks whether we've warned for lack of bones API.  This will be shown only for early private-beta members.
Dialog.hasWarnedBones = false;

Dialog.warnBones = function(){
  if (this.hasWarnedBones) return;
  this.hasWarnedBones = true;

  console.warn("Your Leap Service is out of date");

  if ( !(typeof(process) !== 'undefined' && process.versions && process.versions.node) ){
    this.warnOutOfDate({reason: 'bones'});
  }

}
}).call(this,require('_process'))
},{"_process":160}],111:[function(require,module,exports){
var Pointable = require('./pointable'),
  Bone = require('./bone')
  , Dialog = require('./dialog')
  , _ = require('underscore');

/**
* Constructs a Finger object.
*
* An uninitialized finger is considered invalid.
* Get valid Finger objects from a Frame or a Hand object.
*
* @class Finger
* @memberof Leap
* @classdesc
* The Finger class reports the physical characteristics of a finger.
*
* Both fingers and tools are classified as Pointable objects. Use the
* Pointable.tool property to determine whether a Pointable object represents a
* tool or finger. The Leap classifies a detected entity as a tool when it is
* thinner, straighter, and longer than a typical finger.
*
* Note that Finger objects can be invalid, which means that they do not
* contain valid tracking data and do not correspond to a physical entity.
* Invalid Finger objects can be the result of asking for a Finger object
* using an ID from an earlier frame when no Finger objects with that ID
* exist in the current frame. A Finger object created from the Finger
* constructor is also invalid. Test for validity with the Pointable.valid
* property.
*/
var Finger = module.exports = function(data) {
  Pointable.call(this, data); // use pointable as super-constructor
  
  /**
  * The position of the distal interphalangeal joint of the finger.
  * This joint is closest to the tip.
  * 
  * The distal interphalangeal joint is located between the most extreme segment
  * of the finger (the distal phalanx) and the middle segment (the medial
  * phalanx).
  *
  * @member dipPosition
  * @type {number[]}
  * @memberof Leap.Finger.prototype
  */  
  this.dipPosition = data.dipPosition;

  /**
  * The position of the proximal interphalangeal joint of the finger. This joint is the middle
  * joint of a finger.
  *
  * The proximal interphalangeal joint is located between the two finger segments
  * closest to the hand (the proximal and the medial phalanges). On a thumb,
  * which lacks an medial phalanx, this joint index identifies the knuckle joint
  * between the proximal phalanx and the metacarpal bone.
  *
  * @member pipPosition
  * @type {number[]}
  * @memberof Leap.Finger.prototype
  */  
  this.pipPosition = data.pipPosition;

  /**
  * The position of the metacarpopophalangeal joint, or knuckle, of the finger.
  *
  * The metacarpopophalangeal joint is located at the base of a finger between
  * the metacarpal bone and the first phalanx. The common name for this joint is
  * the knuckle.
  *
  * On a thumb, which has one less phalanx than a finger, this joint index
  * identifies the thumb joint near the base of the hand, between the carpal
  * and metacarpal bones.
  *
  * @member mcpPosition
  * @type {number[]}
  * @memberof Leap.Finger.prototype
  */  
  this.mcpPosition = data.mcpPosition;

  /**
   * The position of the Carpometacarpal joint
   *
   * This is at the distal end of the wrist, and has no common name.
   *
   */
  this.carpPosition = data.carpPosition;

  /**
  * Whether or not this finger is in an extended posture.
  *
  * A finger is considered extended if it is extended straight from the hand as if
  * pointing. A finger is not extended when it is bent down and curled towards the 
  * palm.
  * @member extended
  * @type {Boolean}
  * @memberof Leap.Finger.prototype
  */
  this.extended = data.extended;

  /**
  * An integer code for the name of this finger.
  * 
  * * 0 -- thumb
  * * 1 -- index finger
  * * 2 -- middle finger
  * * 3 -- ring finger
  * * 4 -- pinky
  *
  * @member type
  * @type {number}
  * @memberof Leap.Finger.prototype
  */
  this.type = data.type;

  this.finger = true;
  
  /**
  * The joint positions of this finger as an array in the order base to tip.
  *
  * @member positions
  * @type {array[]}
  * @memberof Leap.Finger.prototype
  */
  this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];

  if (data.bases){
    this.addBones(data);
  } else {
    Dialog.warnBones();
  }

};

_.extend(Finger.prototype, Pointable.prototype);


Finger.prototype.addBones = function(data){
  /**
  * Four bones per finger, from wrist outwards:
  * metacarpal, proximal, medial, and distal.
  *
  * See http://en.wikipedia.org/wiki/Interphalangeal_articulations_of_hand
  */
  this.metacarpal   = new Bone(this, {
    type: 0,
    width: this.width,
    prevJoint: this.carpPosition,
    nextJoint: this.mcpPosition,
    basis: data.bases[0]
  });

  this.proximal     = new Bone(this, {
    type: 1,
    width: this.width,
    prevJoint: this.mcpPosition,
    nextJoint: this.pipPosition,
    basis: data.bases[1]
  });

  this.medial = new Bone(this, {
    type: 2,
    width: this.width,
    prevJoint: this.pipPosition,
    nextJoint: this.dipPosition,
    basis: data.bases[2]
  });

  /**
   * Note that the `distal.nextJoint` position is slightly different from the `finger.tipPosition`.
   * The former is at the very end of the bone, where the latter is the center of a sphere positioned at
   * the tip of the finger.  The btipPosition "bone tip position" is a few mm closer to the wrist than
   * the tipPosition.
   * @type {Bone}
   */
  this.distal       = new Bone(this, {
    type: 3,
    width: this.width,
    prevJoint: this.dipPosition,
    nextJoint: data.btipPosition,
    basis: data.bases[3]
  });

  this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
};

Finger.prototype.toString = function() {
    return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + ' ]';
};

Finger.Invalid = { valid: false };

},{"./bone":104,"./dialog":110,"./pointable":118,"underscore":145}],112:[function(require,module,exports){
var Hand = require("./hand")
  , Pointable = require("./pointable")
  , createGesture = require("./gesture").createGesture
  , glMatrix = require("gl-matrix")
  , mat3 = glMatrix.mat3
  , vec3 = glMatrix.vec3
  , InteractionBox = require("./interaction_box")
  , Finger = require('./finger')
  , _ = require("underscore");

/**
 * Constructs a Frame object.
 *
 * Frame instances created with this constructor are invalid.
 * Get valid Frame objects by calling the
 * [Controller.frame]{@link Leap.Controller#frame}() function.
 *<C-D-Space>
 * @class Frame
 * @memberof Leap
 * @classdesc
 * The Frame class represents a set of hand and finger tracking data detected
 * in a single frame.
 *
 * The Leap detects hands, fingers and tools within the tracking area, reporting
 * their positions, orientations and motions in frames at the Leap frame rate.
 *
 * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.
 */
var Frame = module.exports = function(data) {
  /**
   * Reports whether this Frame instance is valid.
   *
   * A valid Frame is one generated by the Controller object that contains
   * tracking data for all detected entities. An invalid Frame contains no
   * actual tracking data, but you can call its functions without risk of a
   * undefined object exception. The invalid Frame mechanism makes it more
   * convenient to track individual data across the frame history. For example,
   * you can invoke:
   *
   * ```javascript
   * var finger = controller.frame(n).finger(fingerID);
   * ```
   *
   * for an arbitrary Frame history value, "n", without first checking whether
   * frame(n) returned a null object. (You should still check that the
   * returned Finger instance is valid.)
   *
   * @member valid
   * @memberof Leap.Frame.prototype
   * @type {Boolean}
   */
  this.valid = true;
  /**
   * A unique ID for this Frame. Consecutive frames processed by the Leap
   * have consecutive increasing values.
   * @member id
   * @memberof Leap.Frame.prototype
   * @type {String}
   */
  this.id = data.id;
  /**
   * The frame capture time in microseconds elapsed since the Leap started.
   * @member timestamp
   * @memberof Leap.Frame.prototype
   * @type {number}
   */
  this.timestamp = data.timestamp;
  /**
   * The list of Hand objects detected in this frame, given in arbitrary order.
   * The list can be empty if no hands are detected.
   *
   * @member hands[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Hand}
   */
  this.hands = [];
  this.handsMap = {};
  /**
   * The list of Pointable objects (fingers and tools) detected in this frame,
   * given in arbitrary order. The list can be empty if no fingers or tools are
   * detected.
   *
   * @member pointables[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Pointable}
   */
  this.pointables = [];
  /**
   * The list of Tool objects detected in this frame, given in arbitrary order.
   * The list can be empty if no tools are detected.
   *
   * @member tools[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Pointable}
   */
  this.tools = [];
  /**
   * The list of Finger objects detected in this frame, given in arbitrary order.
   * The list can be empty if no fingers are detected.
   * @member fingers[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Pointable}
   */
  this.fingers = [];

  /**
   * The InteractionBox associated with the current frame.
   *
   * @member interactionBox
   * @memberof Leap.Frame.prototype
   * @type {Leap.InteractionBox}
   */
  if (data.interactionBox) {
    this.interactionBox = new InteractionBox(data.interactionBox);
  }
  this.gestures = [];
  this.pointablesMap = {};
  this._translation = data.t;
  this._rotation = _.flatten(data.r);
  this._scaleFactor = data.s;
  this.data = data;
  this.type = 'frame'; // used by event emitting
  this.currentFrameRate = data.currentFrameRate;

  if (data.gestures) {
   /**
    * The list of Gesture objects detected in this frame, given in arbitrary order.
    * The list can be empty if no gestures are detected.
    *
    * Circle and swipe gestures are updated every frame. Tap gestures
    * only appear in the list for a single frame.
    * @member gestures[]
    * @memberof Leap.Frame.prototype
    * @type {Leap.Gesture}
    */
    for (var gestureIdx = 0, gestureCount = data.gestures.length; gestureIdx != gestureCount; gestureIdx++) {
      this.gestures.push(createGesture(data.gestures[gestureIdx]));
    }
  }
  this.postprocessData(data);
};

Frame.prototype.postprocessData = function(data){
  if (!data) {
    data = this.data;
  }

  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {
    var hand = new Hand(data.hands[handIdx]);
    hand.frame = this;
    this.hands.push(hand);
    this.handsMap[hand.id] = hand;
  }

  data.pointables = _.sortBy(data.pointables, function(pointable) { return pointable.id });

  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
    var pointableData = data.pointables[pointableIdx];
    var pointable = pointableData.dipPosition ? new Finger(pointableData) : new Pointable(pointableData);
    pointable.frame = this;
    this.addPointable(pointable);
  }
};

/**
 * Adds data from a pointable element into the pointablesMap; 
 * also adds the pointable to the frame.handsMap hand to which it belongs,
 * and to the hand's tools or hand's fingers map.
 * 
 * @param pointable {Object} a Pointable
 */
Frame.prototype.addPointable = function (pointable) {
  this.pointables.push(pointable);
  this.pointablesMap[pointable.id] = pointable;
  (pointable.tool ? this.tools : this.fingers).push(pointable);
  if (pointable.handId !== undefined && this.handsMap.hasOwnProperty(pointable.handId)) {
    var hand = this.handsMap[pointable.handId];
    hand.pointables.push(pointable);
    (pointable.tool ? hand.tools : hand.fingers).push(pointable);
    switch (pointable.type){
      case 0:
        hand.thumb = pointable;
        break;
      case 1:
        hand.indexFinger = pointable;
        break;
      case 2:
        hand.middleFinger = pointable;
        break;
      case 3:
        hand.ringFinger = pointable;
        break;
      case 4:
        hand.pinky = pointable;
        break;
    }
  }
};

/**
 * The tool with the specified ID in this frame.
 *
 * Use the Frame tool() function to retrieve a tool from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no tool
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a tool is lost and subsequently
 * regained, the new Pointable object representing that tool may have a
 * different ID than that representing the tool in an earlier frame.
 *
 * @method tool
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a Tool object from a previous frame.
 * @returns {Leap.Pointable} The tool with the
 * matching ID if one exists in this frame; otherwise, an invalid Pointable object
 * is returned.
 */
Frame.prototype.tool = function(id) {
  var pointable = this.pointable(id);
  return pointable.tool ? pointable : Pointable.Invalid;
};

/**
 * The Pointable object with the specified ID in this frame.
 *
 * Use the Frame pointable() function to retrieve the Pointable object from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no finger or tool
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a finger or tool is lost and subsequently
 * regained, the new Pointable object representing that finger or tool may have
 * a different ID than that representing the finger or tool in an earlier frame.
 *
 * @method pointable
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a Pointable object from a previous frame.
 * @returns {Leap.Pointable} The Pointable object with
 * the matching ID if one exists in this frame;
 * otherwise, an invalid Pointable object is returned.
 */
Frame.prototype.pointable = function(id) {
  return this.pointablesMap[id] || Pointable.Invalid;
};

/**
 * The finger with the specified ID in this frame.
 *
 * Use the Frame finger() function to retrieve the finger from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Finger object, but if no finger
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a finger is lost and subsequently
 * regained, the new Pointable object representing that physical finger may have
 * a different ID than that representing the finger in an earlier frame.
 *
 * @method finger
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a finger from a previous frame.
 * @returns {Leap.Pointable} The finger with the
 * matching ID if one exists in this frame; otherwise, an invalid Pointable
 * object is returned.
 */
Frame.prototype.finger = function(id) {
  var pointable = this.pointable(id);
  return !pointable.tool ? pointable : Pointable.Invalid;
};

/**
 * The Hand object with the specified ID in this frame.
 *
 * Use the Frame hand() function to retrieve the Hand object from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Hand object, but if no hand
 * with the specified ID is present, an invalid Hand object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a hand is lost and subsequently
 * regained, the new Hand object representing that physical hand may have
 * a different ID than that representing the physical hand in an earlier frame.
 *
 * @method hand
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a Hand object from a previous frame.
 * @returns {Leap.Hand} The Hand object with the matching
 * ID if one exists in this frame; otherwise, an invalid Hand object is returned.
 */
Frame.prototype.hand = function(id) {
  return this.handsMap[id] || Hand.Invalid;
};

/**
 * The angle of rotation around the rotation axis derived from the overall
 * rotational motion between the current frame and the specified frame.
 *
 * The returned angle is expressed in radians measured clockwise around
 * the rotation axis (using the right-hand rule) between the start and end frames.
 * The value is always between 0 and pi radians (0 and 180 degrees).
 *
 * The Leap derives frame rotation from the relative change in position and
 * orientation of all objects detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, then the
 * angle of rotation is zero.
 *
 * @method rotationAngle
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @param {number[]} [axis] The axis to measure rotation around.
 * @returns {number} A positive value containing the heuristically determined
 * rotational change between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.rotationAngle = function(sinceFrame, axis) {
  if (!this.valid || !sinceFrame.valid) return 0.0;

  var rot = this.rotationMatrix(sinceFrame);
  var cs = (rot[0] + rot[4] + rot[8] - 1.0)*0.5;
  var angle = Math.acos(cs);
  angle = isNaN(angle) ? 0.0 : angle;

  if (axis !== undefined) {
    var rotAxis = this.rotationAxis(sinceFrame);
    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));
  }

  return angle;
};

/**
 * The axis of rotation derived from the overall rotational motion between
 * the current frame and the specified frame.
 *
 * The returned direction vector is normalized.
 *
 * The Leap derives frame rotation from the relative change in position and
 * orientation of all objects detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, or if no
 * rotation is detected between the two frames, a zero vector is returned.
 *
 * @method rotationAxis
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A normalized direction vector representing the axis of the heuristically determined
 * rotational change between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.rotationAxis = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  return vec3.normalize(vec3.create(), [
    this._rotation[7] - sinceFrame._rotation[5],
    this._rotation[2] - sinceFrame._rotation[6],
    this._rotation[3] - sinceFrame._rotation[1]
  ]);
}

/**
 * The transform matrix expressing the rotation derived from the overall
 * rotational motion between the current frame and the specified frame.
 *
 * The Leap derives frame rotation from the relative change in position and
 * orientation of all objects detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, then
 * this method returns an identity matrix.
 *
 * @method rotationMatrix
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A transformation matrix containing the heuristically determined
 * rotational change between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.rotationMatrix = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return mat3.create();
  var transpose = mat3.transpose(mat3.create(), this._rotation)
  return mat3.multiply(mat3.create(), sinceFrame._rotation, transpose);
}

/**
 * The scale factor derived from the overall motion between the current frame and the specified frame.
 *
 * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
 * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
 *
 * The Leap derives scaling from the relative inward or outward motion of all
 * objects detected in the field of view (independent of translation and rotation).
 *
 * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.
 *
 * @method scaleFactor
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
 * @returns {number} A positive value representing the heuristically determined
 * scaling change ratio between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.scaleFactor = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return 1.0;
  return Math.exp(this._scaleFactor - sinceFrame._scaleFactor);
}

/**
 * The change of position derived from the overall linear motion between the
 * current frame and the specified frame.
 *
 * The returned translation vector provides the magnitude and direction of the
 * movement in millimeters.
 *
 * The Leap derives frame translation from the linear motion of all objects
 * detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, then this
 * method returns a zero vector.
 *
 * @method translation
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
 * @returns {number[]} A vector representing the heuristically determined change in
 * position of all objects between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.translation = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  return vec3.subtract(vec3.create(), this._translation, sinceFrame._translation);
}

/**
 * A string containing a brief, human readable description of the Frame object.
 *
 * @method toString
 * @memberof Leap.Frame.prototype
 * @returns {String} A brief description of this frame.
 */
Frame.prototype.toString = function() {
  var str = "Frame [ id:"+this.id+" | timestamp:"+this.timestamp+" | Hand count:("+this.hands.length+") | Pointable count:("+this.pointables.length+")";
  if (this.gestures) str += " | Gesture count:("+this.gestures.length+")";
  str += " ]";
  return str;
}

/**
 * Returns a JSON-formatted string containing the hands, pointables and gestures
 * in this frame.
 *
 * @method dump
 * @memberof Leap.Frame.prototype
 * @returns {String} A JSON-formatted string.
 */
Frame.prototype.dump = function() {
  var out = '';
  out += "Frame Info:<br/>";
  out += this.toString();
  out += "<br/><br/>Hands:<br/>"
  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {
    out += "  "+ this.hands[handIdx].toString() + "<br/>";
  }
  out += "<br/><br/>Pointables:<br/>";
  for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
      out += "  "+ this.pointables[pointableIdx].toString() + "<br/>";
  }
  if (this.gestures) {
    out += "<br/><br/>Gestures:<br/>";
    for (var gestureIdx = 0, gestureCount = this.gestures.length; gestureIdx != gestureCount; gestureIdx++) {
        out += "  "+ this.gestures[gestureIdx].toString() + "<br/>";
    }
  }
  out += "<br/><br/>Raw JSON:<br/>";
  out += JSON.stringify(this.data);
  return out;
}

/**
 * An invalid Frame object.
 *
 * You can use this invalid Frame in comparisons testing
 * whether a given Frame instance is valid or invalid. (You can also check the
 * [Frame.valid]{@link Leap.Frame#valid} property.)
 *
 * @static
 * @type {Leap.Frame}
 * @name Invalid
 * @memberof Leap.Frame
 */
Frame.Invalid = {
  valid: false,
  hands: [],
  fingers: [],
  tools: [],
  gestures: [],
  pointables: [],
  pointable: function() { return Pointable.Invalid },
  finger: function() { return Pointable.Invalid },
  hand: function() { return Hand.Invalid },
  toString: function() { return "invalid frame" },
  dump: function() { return this.toString() },
  rotationAngle: function() { return 0.0; },
  rotationMatrix: function() { return mat3.create(); },
  rotationAxis: function() { return vec3.create(); },
  scaleFactor: function() { return 1.0; },
  translation: function() { return vec3.create(); }
};

},{"./finger":111,"./gesture":113,"./hand":114,"./interaction_box":116,"./pointable":118,"gl-matrix":98,"underscore":145}],113:[function(require,module,exports){
var glMatrix = require("gl-matrix")
  , vec3 = glMatrix.vec3
  , EventEmitter = require('events').EventEmitter
  , _ = require('underscore');

/**
 * Constructs a new Gesture object.
 *
 * An uninitialized Gesture object is considered invalid. Get valid instances
 * of the Gesture class, which will be one of the Gesture subclasses, from a
 * Frame object.
 *
 * @class Gesture
 * @abstract
 * @memberof Leap
 * @classdesc
 * The Gesture class represents a recognized movement by the user.
 *
 * The Leap watches the activity within its field of view for certain movement
 * patterns typical of a user gesture or command. For example, a movement from side to
 * side with the hand can indicate a swipe gesture, while a finger poking forward
 * can indicate a screen tap gesture.
 *
 * When the Leap recognizes a gesture, it assigns an ID and adds a
 * Gesture object to the frame gesture list. For continuous gestures, which
 * occur over many frames, the Leap updates the gesture by adding
 * a Gesture object having the same ID and updated properties in each
 * subsequent frame.
 *
 * **Important:** Recognition for each type of gesture must be enabled;
 * otherwise **no gestures are recognized or reported**.
 *
 * Subclasses of Gesture define the properties for the specific movement patterns
 * recognized by the Leap.
 *
 * The Gesture subclasses for include:
 *
 * * CircleGesture -- A circular movement by a finger.
 * * SwipeGesture -- A straight line movement by the hand with fingers extended.
 * * ScreenTapGesture -- A forward tapping movement by a finger.
 * * KeyTapGesture -- A downward tapping movement by a finger.
 *
 * Circle and swipe gestures are continuous and these objects can have a
 * state of start, update, and stop.
 *
 * The screen tap gesture is a discrete gesture. The Leap only creates a single
 * ScreenTapGesture object appears for each tap and it always has a stop state.
 *
 * Get valid Gesture instances from a Frame object. You can get a list of gestures
 * from the Frame gestures array. You can also use the Frame gesture() method
 * to find a gesture in the current frame using an ID value obtained in a
 * previous frame.
 *
 * Gesture objects can be invalid. For example, when you get a gesture by ID
 * using Frame.gesture(), and there is no gesture with that ID in the current
 * frame, then gesture() returns an Invalid Gesture object (rather than a null
 * value). Always check object validity in situations where a gesture might be
 * invalid.
 */
var createGesture = exports.createGesture = function(data) {
  var gesture;
  switch (data.type) {
    case 'circle':
      gesture = new CircleGesture(data);
      break;
    case 'swipe':
      gesture = new SwipeGesture(data);
      break;
    case 'screenTap':
      gesture = new ScreenTapGesture(data);
      break;
    case 'keyTap':
      gesture = new KeyTapGesture(data);
      break;
    default:
      throw "unknown gesture type";
  }

 /**
  * The gesture ID.
  *
  * All Gesture objects belonging to the same recognized movement share the
  * same ID value. Use the ID value with the Frame::gesture() method to
  * find updates related to this Gesture object in subsequent frames.
  *
  * @member id
  * @memberof Leap.Gesture.prototype
  * @type {number}
  */
  gesture.id = data.id;
 /**
  * The list of hands associated with this Gesture, if any.
  *
  * If no hands are related to this gesture, the list is empty.
  *
  * @member handIds
  * @memberof Leap.Gesture.prototype
  * @type {Array}
  */
  gesture.handIds = data.handIds.slice();
 /**
  * The list of fingers and tools associated with this Gesture, if any.
  *
  * If no Pointable objects are related to this gesture, the list is empty.
  *
  * @member pointableIds
  * @memberof Leap.Gesture.prototype
  * @type {Array}
  */
  gesture.pointableIds = data.pointableIds.slice();
 /**
  * The elapsed duration of the recognized movement up to the
  * frame containing this Gesture object, in microseconds.
  *
  * The duration reported for the first Gesture in the sequence (with the
  * start state) will typically be a small positive number since
  * the movement must progress far enough for the Leap to recognize it as
  * an intentional gesture.
  *
  * @member duration
  * @memberof Leap.Gesture.prototype
  * @type {number}
  */
  gesture.duration = data.duration;
 /**
  * The gesture ID.
  *
  * Recognized movements occur over time and have a beginning, a middle,
  * and an end. The 'state()' attribute reports where in that sequence this
  * Gesture object falls.
  *
  * Possible values for the state field are:
  *
  * * start
  * * update
  * * stop
  *
  * @member state
  * @memberof Leap.Gesture.prototype
  * @type {String}
  */
  gesture.state = data.state;
 /**
  * The gesture type.
  *
  * Possible values for the type field are:
  *
  * * circle
  * * swipe
  * * screenTap
  * * keyTap
  *
  * @member type
  * @memberof Leap.Gesture.prototype
  * @type {String}
  */
  gesture.type = data.type;
  return gesture;
}

/*
 * Returns a builder object, which uses method chaining for gesture callback binding.
 */
var gestureListener = exports.gestureListener = function(controller, type) {
  var handlers = {};
  var gestureMap = {};

  controller.on('gesture', function(gesture, frame) {
    if (gesture.type == type) {
      if (gesture.state == "start" || gesture.state == "stop") {
        if (gestureMap[gesture.id] === undefined) {
          var gestureTracker = new Gesture(gesture, frame);
          gestureMap[gesture.id] = gestureTracker;
          _.each(handlers, function(cb, name) {
            gestureTracker.on(name, cb);
          });
        }
      }
      gestureMap[gesture.id].update(gesture, frame);
      if (gesture.state == "stop") {
        delete gestureMap[gesture.id];
      }
    }
  });
  var builder = {
    start: function(cb) {
      handlers['start'] = cb;
      return builder;
    },
    stop: function(cb) {
      handlers['stop'] = cb;
      return builder;
    },
    complete: function(cb) {
      handlers['stop'] = cb;
      return builder;
    },
    update: function(cb) {
      handlers['update'] = cb;
      return builder;
    }
  }
  return builder;
}

var Gesture = exports.Gesture = function(gesture, frame) {
  this.gestures = [gesture];
  this.frames = [frame];
}

Gesture.prototype.update = function(gesture, frame) {
  this.lastGesture = gesture;
  this.lastFrame = frame;
  this.gestures.push(gesture);
  this.frames.push(frame);
  this.emit(gesture.state, this);
}

Gesture.prototype.translation = function() {
  return vec3.subtract(vec3.create(), this.lastGesture.startPosition, this.lastGesture.position);
}

_.extend(Gesture.prototype, EventEmitter.prototype);

/**
 * Constructs a new CircleGesture object.
 *
 * An uninitialized CircleGesture object is considered invalid. Get valid instances
 * of the CircleGesture class from a Frame object.
 *
 * @class CircleGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The CircleGesture classes represents a circular finger movement.
 *
 * A circle movement is recognized when the tip of a finger draws a circle
 * within the Leap field of view.
 *
 * ![CircleGesture](images/Leap_Gesture_Circle.png)
 *
 * Circle gestures are continuous. The CircleGesture objects for the gesture have
 * three possible states:
 *
 * * start -- The circle gesture has just started. The movement has
 *  progressed far enough for the recognizer to classify it as a circle.
 * * update -- The circle gesture is continuing.
 * * stop -- The circle gesture is finished.
 */
var CircleGesture = function(data) {
 /**
  * The center point of the circle within the Leap frame of reference.
  *
  * @member center
  * @memberof Leap.CircleGesture.prototype
  * @type {number[]}
  */
  this.center = data.center;
 /**
  * The normal vector for the circle being traced.
  *
  * If you draw the circle clockwise, the normal vector points in the same
  * general direction as the pointable object drawing the circle. If you draw
  * the circle counterclockwise, the normal points back toward the
  * pointable. If the angle between the normal and the pointable object
  * drawing the circle is less than 90 degrees, then the circle is clockwise.
  *
  * ```javascript
  *    var clockwiseness;
  *    if (circle.pointable.direction.angleTo(circle.normal) <= PI/4) {
  *        clockwiseness = "clockwise";
  *    }
  *    else
  *    {
  *        clockwiseness = "counterclockwise";
  *    }
  * ```
  *
  * @member normal
  * @memberof Leap.CircleGesture.prototype
  * @type {number[]}
  */
  this.normal = data.normal;
 /**
  * The number of times the finger tip has traversed the circle.
  *
  * Progress is reported as a positive number of the number. For example,
  * a progress value of .5 indicates that the finger has gone halfway
  * around, while a value of 3 indicates that the finger has gone around
  * the the circle three times.
  *
  * Progress starts where the circle gesture began. Since the circle
  * must be partially formed before the Leap can recognize it, progress
  * will be greater than zero when a circle gesture first appears in the
  * frame.
  *
  * @member progress
  * @memberof Leap.CircleGesture.prototype
  * @type {number}
  */
  this.progress = data.progress;
 /**
  * The radius of the circle in mm.
  *
  * @member radius
  * @memberof Leap.CircleGesture.prototype
  * @type {number}
  */
  this.radius = data.radius;
}

CircleGesture.prototype.toString = function() {
  return "CircleGesture ["+JSON.stringify(this)+"]";
}

/**
 * Constructs a new SwipeGesture object.
 *
 * An uninitialized SwipeGesture object is considered invalid. Get valid instances
 * of the SwipeGesture class from a Frame object.
 *
 * @class SwipeGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The SwipeGesture class represents a swiping motion of a finger or tool.
 *
 * ![SwipeGesture](images/Leap_Gesture_Swipe.png)
 *
 * Swipe gestures are continuous.
 */
var SwipeGesture = function(data) {
 /**
  * The starting position within the Leap frame of
  * reference, in mm.
  *
  * @member startPosition
  * @memberof Leap.SwipeGesture.prototype
  * @type {number[]}
  */
  this.startPosition = data.startPosition;
 /**
  * The current swipe position within the Leap frame of
  * reference, in mm.
  *
  * @member position
  * @memberof Leap.SwipeGesture.prototype
  * @type {number[]}
  */
  this.position = data.position;
 /**
  * The unit direction vector parallel to the swipe motion.
  *
  * You can compare the components of the vector to classify the swipe as
  * appropriate for your application. For example, if you are using swipes
  * for two dimensional scrolling, you can compare the x and y values to
  * determine if the swipe is primarily horizontal or vertical.
  *
  * @member direction
  * @memberof Leap.SwipeGesture.prototype
  * @type {number[]}
  */
  this.direction = data.direction;
 /**
  * The speed of the finger performing the swipe gesture in
  * millimeters per second.
  *
  * @member speed
  * @memberof Leap.SwipeGesture.prototype
  * @type {number}
  */
  this.speed = data.speed;
}

SwipeGesture.prototype.toString = function() {
  return "SwipeGesture ["+JSON.stringify(this)+"]";
}

/**
 * Constructs a new ScreenTapGesture object.
 *
 * An uninitialized ScreenTapGesture object is considered invalid. Get valid instances
 * of the ScreenTapGesture class from a Frame object.
 *
 * @class ScreenTapGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The ScreenTapGesture class represents a tapping gesture by a finger or tool.
 *
 * A screen tap gesture is recognized when the tip of a finger pokes forward
 * and then springs back to approximately the original postion, as if
 * tapping a vertical screen. The tapping finger must pause briefly before beginning the tap.
 *
 * ![ScreenTap](images/Leap_Gesture_Tap2.png)
 *
 * ScreenTap gestures are discrete. The ScreenTapGesture object representing a tap always
 * has the state, STATE_STOP. Only one ScreenTapGesture object is created for each
 * screen tap gesture recognized.
 */
var ScreenTapGesture = function(data) {
 /**
  * The position where the screen tap is registered.
  *
  * @member position
  * @memberof Leap.ScreenTapGesture.prototype
  * @type {number[]}
  */
  this.position = data.position;
 /**
  * The direction of finger tip motion.
  *
  * @member direction
  * @memberof Leap.ScreenTapGesture.prototype
  * @type {number[]}
  */
  this.direction = data.direction;
 /**
  * The progess value is always 1.0 for a screen tap gesture.
  *
  * @member progress
  * @memberof Leap.ScreenTapGesture.prototype
  * @type {number}
  */
  this.progress = data.progress;
}

ScreenTapGesture.prototype.toString = function() {
  return "ScreenTapGesture ["+JSON.stringify(this)+"]";
}

/**
 * Constructs a new KeyTapGesture object.
 *
 * An uninitialized KeyTapGesture object is considered invalid. Get valid instances
 * of the KeyTapGesture class from a Frame object.
 *
 * @class KeyTapGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The KeyTapGesture class represents a tapping gesture by a finger or tool.
 *
 * A key tap gesture is recognized when the tip of a finger rotates down toward the
 * palm and then springs back to approximately the original postion, as if
 * tapping. The tapping finger must pause briefly before beginning the tap.
 *
 * ![KeyTap](images/Leap_Gesture_Tap.png)
 *
 * Key tap gestures are discrete. The KeyTapGesture object representing a tap always
 * has the state, STATE_STOP. Only one KeyTapGesture object is created for each
 * key tap gesture recognized.
 */
var KeyTapGesture = function(data) {
    /**
     * The position where the key tap is registered.
     *
     * @member position
     * @memberof Leap.KeyTapGesture.prototype
     * @type {number[]}
     */
    this.position = data.position;
    /**
     * The direction of finger tip motion.
     *
     * @member direction
     * @memberof Leap.KeyTapGesture.prototype
     * @type {number[]}
     */
    this.direction = data.direction;
    /**
     * The progess value is always 1.0 for a key tap gesture.
     *
     * @member progress
     * @memberof Leap.KeyTapGesture.prototype
     * @type {number}
     */
    this.progress = data.progress;
}

KeyTapGesture.prototype.toString = function() {
  return "KeyTapGesture ["+JSON.stringify(this)+"]";
}

},{"events":155,"gl-matrix":98,"underscore":145}],114:[function(require,module,exports){
var Pointable = require("./pointable")
  , Bone = require('./bone')
  , glMatrix = require("gl-matrix")
  , mat3 = glMatrix.mat3
  , vec3 = glMatrix.vec3
  , _ = require("underscore");

/**
 * Constructs a Hand object.
 *
 * An uninitialized hand is considered invalid.
 * Get valid Hand objects from a Frame object.
 * @class Hand
 * @memberof Leap
 * @classdesc
 * The Hand class reports the physical characteristics of a detected hand.
 *
 * Hand tracking data includes a palm position and velocity; vectors for
 * the palm normal and direction to the fingers; properties of a sphere fit
 * to the hand; and lists of the attached fingers and tools.
 *
 * Note that Hand objects can be invalid, which means that they do not contain
 * valid tracking data and do not correspond to a physical entity. Invalid Hand
 * objects can be the result of asking for a Hand object using an ID from an
 * earlier frame when no Hand objects with that ID exist in the current frame.
 * A Hand object created from the Hand constructor is also invalid.
 * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.
 */
var Hand = module.exports = function(data) {
  /**
   * A unique ID assigned to this Hand object, whose value remains the same
   * across consecutive frames while the tracked hand remains visible. If
   * tracking is lost (for example, when a hand is occluded by another hand
   * or when it is withdrawn from or reaches the edge of the Leap field of view),
   * the Leap may assign a new ID when it detects the hand in a future frame.
   *
   * Use the ID value with the {@link Frame.hand}() function to find this
   * Hand object in future frames.
   *
   * @member id
   * @memberof Leap.Hand.prototype
   * @type {String}
   */
  this.id = data.id;
  /**
   * The center position of the palm in millimeters from the Leap origin.
   * @member palmPosition
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.palmPosition = data.palmPosition;
  /**
   * The direction from the palm position toward the fingers.
   *
   * The direction is expressed as a unit vector pointing in the same
   * direction as the directed line from the palm position to the fingers.
   *
   * @member direction
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.direction = data.direction;
  /**
   * The rate of change of the palm position in millimeters/second.
   *
   * @member palmVeclocity
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.palmVelocity = data.palmVelocity;
  /**
   * The normal vector to the palm. If your hand is flat, this vector will
   * point downward, or "out" of the front surface of your palm.
   *
   * ![Palm Vectors](images/Leap_Palm_Vectors.png)
   *
   * The direction is expressed as a unit vector pointing in the same
   * direction as the palm normal (that is, a vector orthogonal to the palm).
   * @member palmNormal
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.palmNormal = data.palmNormal;
  /**
   * The center of a sphere fit to the curvature of this hand.
   *
   * This sphere is placed roughly as if the hand were holding a ball.
   *
   * ![Hand Ball](images/Leap_Hand_Ball.png)
   * @member sphereCenter
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.sphereCenter = data.sphereCenter;
  /**
   * The radius of a sphere fit to the curvature of this hand, in millimeters.
   *
   * This sphere is placed roughly as if the hand were holding a ball. Thus the
   * size of the sphere decreases as the fingers are curled into a fist.
   *
   * @member sphereRadius
   * @memberof Leap.Hand.prototype
   * @type {number}
   */
  this.sphereRadius = data.sphereRadius;
  /**
   * Reports whether this is a valid Hand object.
   *
   * @member valid
   * @memberof Leap.Hand.prototype
   * @type {boolean}
   */
  this.valid = true;
  /**
   * The list of Pointable objects (fingers and tools) detected in this frame
   * that are associated with this hand, given in arbitrary order. The list
   * can be empty if no fingers or tools associated with this hand are detected.
   *
   * Use the {@link Pointable} tool property to determine
   * whether or not an item in the list represents a tool or finger.
   * You can also get only the tools using the Hand.tools[] list or
   * only the fingers using the Hand.fingers[] list.
   *
   * @member pointables[]
   * @memberof Leap.Hand.prototype
   * @type {Leap.Pointable[]}
   */
  this.pointables = [];
  /**
   * The list of fingers detected in this frame that are attached to
   * this hand, given in arbitrary order.
   *
   * The list can be empty if no fingers attached to this hand are detected.
   *
   * @member fingers[]
   * @memberof Leap.Hand.prototype
   * @type {Leap.Pointable[]}
   */
  this.fingers = [];
  
  if (data.armBasis){
    this.arm = new Bone(this, {
      type: 4,
      width: data.armWidth,
      prevJoint: data.elbow,
      nextJoint: data.wrist,
      basis: data.armBasis
    });
  }else{
    this.arm = null;
  }
  
  /**
   * The list of tools detected in this frame that are held by this
   * hand, given in arbitrary order.
   *
   * The list can be empty if no tools held by this hand are detected.
   *
   * @member tools[]
   * @memberof Leap.Hand.prototype
   * @type {Leap.Pointable[]}
   */
  this.tools = [];
  this._translation = data.t;
  this._rotation = _.flatten(data.r);
  this._scaleFactor = data.s;

  /**
   * Time the hand has been visible in seconds.
   *
   * @member timeVisible
   * @memberof Leap.Hand.prototype
   * @type {number}
   */
   this.timeVisible = data.timeVisible;

  /**
   * The palm position with stabalization
   * @member stabilizedPalmPosition
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
   this.stabilizedPalmPosition = data.stabilizedPalmPosition;

   /**
   * Reports whether this is a left or a right hand.
   *
   * @member type
   * @type {String}
   * @memberof Leap.Hand.prototype
   */
   this.type = data.type;
   this.grabStrength = data.grabStrength;
   this.pinchStrength = data.pinchStrength;
   this.confidence = data.confidence;
}

/**
 * The finger with the specified ID attached to this hand.
 *
 * Use this function to retrieve a Pointable object representing a finger
 * attached to this hand using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no finger
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that the ID values assigned to fingers persist across frames, but only
 * until tracking of a particular finger is lost. If tracking of a finger is
 * lost and subsequently regained, the new Finger object representing that
 * finger may have a different ID than that representing the finger in an
 * earlier frame.
 *
 * @method finger
 * @memberof Leap.Hand.prototype
 * @param {String} id The ID value of a finger from a previous frame.
 * @returns {Leap.Pointable} The Finger object with
 * the matching ID if one exists for this hand in this frame; otherwise, an
 * invalid Finger object is returned.
 */
Hand.prototype.finger = function(id) {
  var finger = this.frame.finger(id);
  return (finger && (finger.handId == this.id)) ? finger : Pointable.Invalid;
}

/**
 * The angle of rotation around the rotation axis derived from the change in
 * orientation of this hand, and any associated fingers and tools, between the
 * current frame and the specified frame.
 *
 * The returned angle is expressed in radians measured clockwise around the
 * rotation axis (using the right-hand rule) between the start and end frames.
 * The value is always between 0 and pi radians (0 and 180 degrees).
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either
 * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.
 *
 * @method rotationAngle
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @param {numnber[]} [axis] The axis to measure rotation around.
 * @returns {number} A positive value representing the heuristically determined
 * rotational change of the hand between the current frame and that specified in
 * the sinceFrame parameter.
 */
Hand.prototype.rotationAngle = function(sinceFrame, axis) {
  if (!this.valid || !sinceFrame.valid) return 0.0;
  var sinceHand = sinceFrame.hand(this.id);
  if(!sinceHand.valid) return 0.0;
  var rot = this.rotationMatrix(sinceFrame);
  var cs = (rot[0] + rot[4] + rot[8] - 1.0)*0.5
  var angle = Math.acos(cs);
  angle = isNaN(angle) ? 0.0 : angle;
  if (axis !== undefined) {
    var rotAxis = this.rotationAxis(sinceFrame);
    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));
  }
  return angle;
}

/**
 * The axis of rotation derived from the change in orientation of this hand, and
 * any associated fingers and tools, between the current frame and the specified frame.
 *
 * The returned direction vector is normalized.
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either
 * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.
 *
 * @method rotationAxis
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A normalized direction Vector representing the axis of the heuristically determined
 * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.rotationAxis = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  var sinceHand = sinceFrame.hand(this.id);
  if (!sinceHand.valid) return vec3.create();
  return vec3.normalize(vec3.create(), [
    this._rotation[7] - sinceHand._rotation[5],
    this._rotation[2] - sinceHand._rotation[6],
    this._rotation[3] - sinceHand._rotation[1]
  ]);
}

/**
 * The transform matrix expressing the rotation derived from the change in
 * orientation of this hand, and any associated fingers and tools, between
 * the current frame and the specified frame.
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either
 * this frame or sinceFrame are invalid Frame objects, then this method returns
 * an identity matrix.
 *
 * @method rotationMatrix
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A transformation Matrix containing the heuristically determined
 * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.rotationMatrix = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return mat3.create();
  var sinceHand = sinceFrame.hand(this.id);
  if(!sinceHand.valid) return mat3.create();
  var transpose = mat3.transpose(mat3.create(), this._rotation);
  var m = mat3.multiply(mat3.create(), sinceHand._rotation, transpose);
  return m;
}

/**
 * The scale factor derived from the hand's motion between the current frame and the specified frame.
 *
 * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
 * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
 *
 * The Leap derives scaling from the relative inward or outward motion of a hand
 * and its associated fingers and tools (independent of translation and rotation).
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame
 * are invalid Frame objects, then this method returns 1.0.
 *
 * @method scaleFactor
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
 * @returns {number} A positive value representing the heuristically determined
 * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.scaleFactor = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return 1.0;
  var sinceHand = sinceFrame.hand(this.id);
  if(!sinceHand.valid) return 1.0;

  return Math.exp(this._scaleFactor - sinceHand._scaleFactor);
}

/**
 * The change of position of this hand between the current frame and the specified frame
 *
 * The returned translation vector provides the magnitude and direction of the
 * movement in millimeters.
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either this frame or
 * sinceFrame are invalid Frame objects, then this method returns a zero vector.
 *
 * @method translation
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
 * @returns {number[]} A Vector representing the heuristically determined change in hand
 * position between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.translation = function(sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  var sinceHand = sinceFrame.hand(this.id);
  if(!sinceHand.valid) return vec3.create();
  return [
    this._translation[0] - sinceHand._translation[0],
    this._translation[1] - sinceHand._translation[1],
    this._translation[2] - sinceHand._translation[2]
  ];
}

/**
 * A string containing a brief, human readable description of the Hand object.
 * @method toString
 * @memberof Leap.Hand.prototype
 * @returns {String} A description of the Hand as a string.
 */
Hand.prototype.toString = function() {
  return "Hand (" + this.type + ") [ id: "+ this.id + " | palm velocity:"+this.palmVelocity+" | sphere center:"+this.sphereCenter+" ] ";
}

/**
 * The pitch angle in radians.
 *
 * Pitch is the angle between the negative z-axis and the projection of
 * the vector onto the y-z plane. In other words, pitch represents rotation
 * around the x-axis.
 * If the vector points upward, the returned angle is between 0 and pi radians
 * (180 degrees); if it points downward, the angle is between 0 and -pi radians.
 *
 * @method pitch
 * @memberof Leap.Hand.prototype
 * @returns {number} The angle of this vector above or below the horizon (x-z plane).
 *
 */
Hand.prototype.pitch = function() {
  return Math.atan2(this.direction[1], -this.direction[2]);
}

/**
 *  The yaw angle in radians.
 *
 * Yaw is the angle between the negative z-axis and the projection of
 * the vector onto the x-z plane. In other words, yaw represents rotation
 * around the y-axis. If the vector points to the right of the negative z-axis,
 * then the returned angle is between 0 and pi radians (180 degrees);
 * if it points to the left, the angle is between 0 and -pi radians.
 *
 * @method yaw
 * @memberof Leap.Hand.prototype
 * @returns {number} The angle of this vector to the right or left of the y-axis.
 *
 */
Hand.prototype.yaw = function() {
  return Math.atan2(this.direction[0], -this.direction[2]);
}

/**
 *  The roll angle in radians.
 *
 * Roll is the angle between the y-axis and the projection of
 * the vector onto the x-y plane. In other words, roll represents rotation
 * around the z-axis. If the vector points to the left of the y-axis,
 * then the returned angle is between 0 and pi radians (180 degrees);
 * if it points to the right, the angle is between 0 and -pi radians.
 *
 * @method roll
 * @memberof Leap.Hand.prototype
 * @returns {number} The angle of this vector to the right or left of the y-axis.
 *
 */
Hand.prototype.roll = function() {
  return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
}

/**
 * An invalid Hand object.
 *
 * You can use an invalid Hand object in comparisons testing
 * whether a given Hand instance is valid or invalid. (You can also use the
 * Hand valid property.)
 *
 * @static
 * @type {Leap.Hand}
 * @name Invalid
 * @memberof Leap.Hand
 */
Hand.Invalid = {
  valid: false,
  fingers: [],
  tools: [],
  pointables: [],
  left: false,
  pointable: function() { return Pointable.Invalid },
  finger: function() { return Pointable.Invalid },
  toString: function() { return "invalid frame" },
  dump: function() { return this.toString(); },
  rotationAngle: function() { return 0.0; },
  rotationMatrix: function() { return mat3.create(); },
  rotationAxis: function() { return vec3.create(); },
  scaleFactor: function() { return 1.0; },
  translation: function() { return vec3.create(); }
};

},{"./bone":104,"./pointable":118,"gl-matrix":98,"underscore":145}],115:[function(require,module,exports){
/**
 * Leap is the global namespace of the Leap API.
 * @namespace Leap
 */
module.exports = {
  Controller: require("./controller"),
  Frame: require("./frame"),
  Gesture: require("./gesture"),
  Hand: require("./hand"),
  Pointable: require("./pointable"),
  Finger: require("./finger"),
  InteractionBox: require("./interaction_box"),
  CircularBuffer: require("./circular_buffer"),
  UI: require("./ui"),
  JSONProtocol: require("./protocol").JSONProtocol,
  glMatrix: require("gl-matrix"),
  mat3: require("gl-matrix").mat3,
  vec3: require("gl-matrix").vec3,
  loopController: undefined,
  version: require('./version.js'),

  /**
   * Expose utility libraries for convenience
   * Use carefully - they may be subject to upgrade or removal in different versions of LeapJS.
   *
   */
  _: require('underscore'),
  EventEmitter: require('events').EventEmitter,

  /**
   * The Leap.loop() function passes a frame of Leap data to your
   * callback function and then calls window.requestAnimationFrame() after
   * executing your callback function.
   *
   * Leap.loop() sets up the Leap controller and WebSocket connection for you.
   * You do not need to create your own controller when using this method.
   *
   * Your callback function is called on an interval determined by the client
   * browser. Typically, this is on an interval of 60 frames/second. The most
   * recent frame of Leap data is passed to your callback function. If the Leap
   * is producing frames at a slower rate than the browser frame rate, the same
   * frame of Leap data can be passed to your function in successive animation
   * updates.
   *
   * As an alternative, you can create your own Controller object and use a
   * {@link Controller#onFrame onFrame} callback to process the data at
   * the frame rate of the Leap device. See {@link Controller} for an
   * example.
   *
   * @method Leap.loop
   * @param {function} callback A function called when the browser is ready to
   * draw to the screen. The most recent {@link Frame} object is passed to
   * your callback function.
   *
   * ```javascript
   *    Leap.loop( function( frame ) {
   *        // ... your code here
   *    })
   * ```
   */
  loop: function(opts, callback) {
    if (opts && callback === undefined &&  ( ({}).toString.call(opts) === '[object Function]' ) ) {
      callback = opts;
      opts = {};
    }

    if (this.loopController) {
      if (opts){
        this.loopController.setupFrameEvents(opts);
      }
    }else{
      this.loopController = new this.Controller(opts);
    }

    this.loopController.loop(callback);
    return this.loopController;
  },

  /*
   * Convenience method for Leap.Controller.plugin
   */
  plugin: function(name, options){
    this.Controller.plugin(name, options)
  }
}

},{"./circular_buffer":105,"./controller":109,"./finger":111,"./frame":112,"./gesture":113,"./hand":114,"./interaction_box":116,"./pointable":118,"./protocol":119,"./ui":120,"./version.js":123,"events":155,"gl-matrix":98,"underscore":145}],116:[function(require,module,exports){
var glMatrix = require("gl-matrix")
  , vec3 = glMatrix.vec3;

/**
 * Constructs a InteractionBox object.
 *
 * @class InteractionBox
 * @memberof Leap
 * @classdesc
 * The InteractionBox class represents a box-shaped region completely within
 * the field of view of the Leap Motion controller.
 *
 * The interaction box is an axis-aligned rectangular prism and provides
 * normalized coordinates for hands, fingers, and tools within this box.
 * The InteractionBox class can make it easier to map positions in the
 * Leap Motion coordinate system to 2D or 3D coordinate systems used
 * for application drawing.
 *
 * ![Interaction Box](images/Leap_InteractionBox.png)
 *
 * The InteractionBox region is defined by a center and dimensions along the x, y, and z axes.
 */
var InteractionBox = module.exports = function(data) {
  /**
   * Indicates whether this is a valid InteractionBox object.
   *
   * @member valid
   * @type {Boolean}
   * @memberof Leap.InteractionBox.prototype
   */
  this.valid = true;
  /**
   * The center of the InteractionBox in device coordinates (millimeters).
   * This point is equidistant from all sides of the box.
   *
   * @member center
   * @type {number[]}
   * @memberof Leap.InteractionBox.prototype
   */
  this.center = data.center;

  this.size = data.size;
  /**
   * The width of the InteractionBox in millimeters, measured along the x-axis.
   *
   * @member width
   * @type {number}
   * @memberof Leap.InteractionBox.prototype
   */
  this.width = data.size[0];
  /**
   * The height of the InteractionBox in millimeters, measured along the y-axis.
   *
   * @member height
   * @type {number}
   * @memberof Leap.InteractionBox.prototype
   */
  this.height = data.size[1];
  /**
   * The depth of the InteractionBox in millimeters, measured along the z-axis.
   *
   * @member depth
   * @type {number}
   * @memberof Leap.InteractionBox.prototype
   */
  this.depth = data.size[2];
}

/**
 * Converts a position defined by normalized InteractionBox coordinates
 * into device coordinates in millimeters.
 *
 * This function performs the inverse of normalizePoint().
 *
 * @method denormalizePoint
 * @memberof Leap.InteractionBox.prototype
 * @param {number[]} normalizedPosition The input position in InteractionBox coordinates.
 * @returns {number[]} The corresponding denormalized position in device coordinates.
 */
InteractionBox.prototype.denormalizePoint = function(normalizedPosition) {
  return vec3.fromValues(
    (normalizedPosition[0] - 0.5) * this.size[0] + this.center[0],
    (normalizedPosition[1] - 0.5) * this.size[1] + this.center[1],
    (normalizedPosition[2] - 0.5) * this.size[2] + this.center[2]
  );
}

/**
 * Normalizes the coordinates of a point using the interaction box.
 *
 * Coordinates from the Leap Motion frame of reference (millimeters) are
 * converted to a range of [0..1] such that the minimum value of the
 * InteractionBox maps to 0 and the maximum value of the InteractionBox maps to 1.
 *
 * @method normalizePoint
 * @memberof Leap.InteractionBox.prototype
 * @param {number[]} position The input position in device coordinates.
 * @param {Boolean} clamp Whether or not to limit the output value to the range [0,1]
 * when the input position is outside the InteractionBox. Defaults to true.
 * @returns {number[]} The normalized position.
 */
InteractionBox.prototype.normalizePoint = function(position, clamp) {
  var vec = vec3.fromValues(
    ((position[0] - this.center[0]) / this.size[0]) + 0.5,
    ((position[1] - this.center[1]) / this.size[1]) + 0.5,
    ((position[2] - this.center[2]) / this.size[2]) + 0.5
  );

  if (clamp) {
    vec[0] = Math.min(Math.max(vec[0], 0), 1);
    vec[1] = Math.min(Math.max(vec[1], 0), 1);
    vec[2] = Math.min(Math.max(vec[2], 0), 1);
  }
  return vec;
}

/**
 * Writes a brief, human readable description of the InteractionBox object.
 *
 * @method toString
 * @memberof Leap.InteractionBox.prototype
 * @returns {String} A description of the InteractionBox object as a string.
 */
InteractionBox.prototype.toString = function() {
  return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
}

/**
 * An invalid InteractionBox object.
 *
 * You can use this InteractionBox instance in comparisons testing
 * whether a given InteractionBox instance is valid or invalid. (You can also use the
 * InteractionBox.valid property.)
 *
 * @static
 * @type {Leap.InteractionBox}
 * @name Invalid
 * @memberof Leap.InteractionBox
 */
InteractionBox.Invalid = { valid: false };

},{"gl-matrix":98}],117:[function(require,module,exports){
var Pipeline = module.exports = function (controller) {
  this.steps = [];
  this.controller = controller;
}

Pipeline.prototype.addStep = function (step) {
  this.steps.push(step);
}

Pipeline.prototype.run = function (frame) {
  var stepsLength = this.steps.length;
  for (var i = 0; i != stepsLength; i++) {
    if (!frame) break;
    frame = this.steps[i](frame);
  }
  return frame;
}

Pipeline.prototype.removeStep = function(step){
  var index = this.steps.indexOf(step);
  if (index === -1) throw "Step not found in pipeline";
  this.steps.splice(index, 1);
}

/*
 * Wraps a plugin callback method in method which can be run inside the pipeline.
 * This wrapper method loops the callback over objects within the frame as is appropriate,
 * calling the callback for each in turn.
 *
 * @method createStepFunction
 * @memberOf Leap.Controller.prototype
 * @param {Controller} The controller on which the callback is called.
 * @param {String} type What frame object the callback is run for and receives.
 *       Can be one of 'frame', 'finger', 'hand', 'pointable', 'tool'
 * @param {function} callback The method which will be run inside the pipeline loop.  Receives one argument, such as a hand.
 * @private
 */
Pipeline.prototype.addWrappedStep = function (type, callback) {
  var controller = this.controller,
    step = function (frame) {
      var dependencies, i, len;
      dependencies = (type == 'frame') ? [frame] : (frame[type + 's'] || []);

      for (i = 0, len = dependencies.length; i < len; i++) {
        callback.call(controller, dependencies[i]);
      }

      return frame;
    };

  this.addStep(step);
  return step;
};
},{}],118:[function(require,module,exports){
var glMatrix = require("gl-matrix")
  , vec3 = glMatrix.vec3;

/**
 * Constructs a Pointable object.
 *
 * An uninitialized pointable is considered invalid.
 * Get valid Pointable objects from a Frame or a Hand object.
 *
 * @class Pointable
 * @memberof Leap
 * @classdesc
 * The Pointable class reports the physical characteristics of a detected
 * finger or tool.
 *
 * Both fingers and tools are classified as Pointable objects. Use the
 * Pointable.tool property to determine whether a Pointable object represents a
 * tool or finger. The Leap classifies a detected entity as a tool when it is
 * thinner, straighter, and longer than a typical finger.
 *
 * Note that Pointable objects can be invalid, which means that they do not
 * contain valid tracking data and do not correspond to a physical entity.
 * Invalid Pointable objects can be the result of asking for a Pointable object
 * using an ID from an earlier frame when no Pointable objects with that ID
 * exist in the current frame. A Pointable object created from the Pointable
 * constructor is also invalid. Test for validity with the Pointable.valid
 * property.
 */
var Pointable = module.exports = function(data) {
  /**
   * Indicates whether this is a valid Pointable object.
   *
   * @member valid
   * @type {Boolean}
   * @memberof Leap.Pointable.prototype
   */
  this.valid = true;
  /**
   * A unique ID assigned to this Pointable object, whose value remains the
   * same across consecutive frames while the tracked finger or tool remains
   * visible. If tracking is lost (for example, when a finger is occluded by
   * another finger or when it is withdrawn from the Leap field of view), the
   * Leap may assign a new ID when it detects the entity in a future frame.
   *
   * Use the ID value with the pointable() functions defined for the
   * {@link Frame} and {@link Frame.Hand} classes to find this
   * Pointable object in future frames.
   *
   * @member id
   * @type {String}
   * @memberof Leap.Pointable.prototype
   */
  this.id = data.id;
  this.handId = data.handId;
  /**
   * The estimated length of the finger or tool in millimeters.
   *
   * The reported length is the visible length of the finger or tool from the
   * hand to tip. If the length isn't known, then a value of 0 is returned.
   *
   * @member length
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.length = data.length;
  /**
   * Whether or not the Pointable is believed to be a tool.
   * Tools are generally longer, thinner, and straighter than fingers.
   *
   * If tool is false, then this Pointable must be a finger.
   *
   * @member tool
   * @type {Boolean}
   * @memberof Leap.Pointable.prototype
   */
  this.tool = data.tool;
  /**
   * The estimated width of the tool in millimeters.
   *
   * The reported width is the average width of the visible portion of the
   * tool from the hand to the tip. If the width isn't known,
   * then a value of 0 is returned.
   *
   * Pointable objects representing fingers do not have a width property.
   *
   * @member width
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.width = data.width;
  /**
   * The direction in which this finger or tool is pointing.
   *
   * The direction is expressed as a unit vector pointing in the same
   * direction as the tip.
   *
   * ![Finger](images/Leap_Finger_Model.png)
   * @member direction
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.direction = data.direction;
  /**
   * The tip position in millimeters from the Leap origin.
   * Stabilized
   *
   * @member stabilizedTipPosition
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.stabilizedTipPosition = data.stabilizedTipPosition;
  /**
   * The tip position in millimeters from the Leap origin.
   *
   * @member tipPosition
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.tipPosition = data.tipPosition;
  /**
   * The rate of change of the tip position in millimeters/second.
   *
   * @member tipVelocity
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.tipVelocity = data.tipVelocity;
  /**
   * The current touch zone of this Pointable object.
   *
   * The Leap Motion software computes the touch zone based on a floating touch
   * plane that adapts to the user's finger movement and hand posture. The Leap
   * Motion software interprets purposeful movements toward this plane as potential touch
   * points. When a Pointable moves close to the adaptive touch plane, it enters the
   * "hovering" zone. When a Pointable reaches or passes through the plane, it enters
   * the "touching" zone.
   *
   * The possible states include:
   *
   * * "none" -- The Pointable is outside the hovering zone.
   * * "hovering" -- The Pointable is close to, but not touching the touch plane.
   * * "touching" -- The Pointable has penetrated the touch plane.
   *
   * The touchDistance value provides a normalized indication of the distance to
   * the touch plane when the Pointable is in the hovering or touching zones.
   *
   * @member touchZone
   * @type {String}
   * @memberof Leap.Pointable.prototype
   */
  this.touchZone = data.touchZone;
  /**
   * A value proportional to the distance between this Pointable object and the
   * adaptive touch plane.
   *
   * ![Touch Distance](images/Leap_Touch_Plane.png)
   *
   * The touch distance is a value in the range [-1, 1]. The value 1.0 indicates the
   * Pointable is at the far edge of the hovering zone. The value 0 indicates the
   * Pointable is just entering the touching zone. A value of -1.0 indicates the
   * Pointable is firmly within the touching zone. Values in between are
   * proportional to the distance from the plane. Thus, the touchDistance of 0.5
   * indicates that the Pointable is halfway into the hovering zone.
   *
   * You can use the touchDistance value to modulate visual feedback given to the
   * user as their fingers close in on a touch target, such as a button.
   *
   * @member touchDistance
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.touchDistance = data.touchDistance;

  /**
   * How long the pointable has been visible in seconds.
   *
   * @member timeVisible
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.timeVisible = data.timeVisible;
}

/**
 * A string containing a brief, human readable description of the Pointable
 * object.
 *
 * @method toString
 * @memberof Leap.Pointable.prototype
 * @returns {String} A description of the Pointable object as a string.
 */
Pointable.prototype.toString = function() {
  return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + ' ]';
}

/**
 * Returns the hand which the pointable is attached to.
 */
Pointable.prototype.hand = function(){
  return this.frame.hand(this.handId);
}

/**
 * An invalid Pointable object.
 *
 * You can use this Pointable instance in comparisons testing
 * whether a given Pointable instance is valid or invalid. (You can also use the
 * Pointable.valid property.)

 * @static
 * @type {Leap.Pointable}
 * @name Invalid
 * @memberof Leap.Pointable
 */
Pointable.Invalid = { valid: false };

},{"gl-matrix":98}],119:[function(require,module,exports){
var Frame = require('./frame')
  , Hand = require('./hand')
  , Pointable = require('./pointable')
  , Finger = require('./finger')
  , _ = require('underscore')
  , EventEmitter = require('events').EventEmitter;

var Event = function(data) {
  this.type = data.type;
  this.state = data.state;
};

exports.chooseProtocol = function(header) {
  var protocol;
  switch(header.version) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      protocol = JSONProtocol(header);
      protocol.sendBackground = function(connection, state) {
        connection.send(protocol.encode({background: state}));
      }
      protocol.sendFocused = function(connection, state) {
        connection.send(protocol.encode({focused: state}));
      }
      protocol.sendOptimizeHMD = function(connection, state) {
        connection.send(protocol.encode({optimizeHMD: state}));
      }
      break;
    default:
      throw "unrecognized version";
  }
  return protocol;
}

var JSONProtocol = exports.JSONProtocol = function(header) {

  var protocol = function(frameData) {

    if (frameData.event) {

      return new Event(frameData.event);

    } else {

      protocol.emit('beforeFrameCreated', frameData);

      var frame = new Frame(frameData);

      protocol.emit('afterFrameCreated', frame, frameData);

      return frame;

    }

  };

  protocol.encode = function(message) {
    return JSON.stringify(message);
  };
  protocol.version = header.version;
  protocol.serviceVersion = header.serviceVersion;
  protocol.versionLong = 'Version ' + header.version;
  protocol.type = 'protocol';

  _.extend(protocol, EventEmitter.prototype);

  return protocol;
};



},{"./finger":111,"./frame":112,"./hand":114,"./pointable":118,"events":155,"underscore":145}],120:[function(require,module,exports){
exports.UI = {
  Region: require("./ui/region"),
  Cursor: require("./ui/cursor")
};
},{"./ui/cursor":121,"./ui/region":122}],121:[function(require,module,exports){
var Cursor = module.exports = function() {
  return function(frame) {
    var pointable = frame.pointables.sort(function(a, b) { return a.z - b.z })[0]
    if (pointable && pointable.valid) {
      frame.cursorPosition = pointable.tipPosition
    }
    return frame
  }
}

},{}],122:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
  , _ = require('underscore')

var Region = module.exports = function(start, end) {
  this.start = new Vector(start)
  this.end = new Vector(end)
  this.enteredFrame = null
}

Region.prototype.hasPointables = function(frame) {
  for (var i = 0; i != frame.pointables.length; i++) {
    var position = frame.pointables[i].tipPosition
    if (position.x >= this.start.x && position.x <= this.end.x && position.y >= this.start.y && position.y <= this.end.y && position.z >= this.start.z && position.z <= this.end.z) {
      return true
    }
  }
  return false
}

Region.prototype.listener = function(opts) {
  var region = this
  if (opts && opts.nearThreshold) this.setupNearRegion(opts.nearThreshold)
  return function(frame) {
    return region.updatePosition(frame)
  }
}

Region.prototype.clipper = function() {
  var region = this
  return function(frame) {
    region.updatePosition(frame)
    return region.enteredFrame ? frame : null
  }
}

Region.prototype.setupNearRegion = function(distance) {
  var nearRegion = this.nearRegion = new Region(
    [this.start.x - distance, this.start.y - distance, this.start.z - distance],
    [this.end.x + distance, this.end.y + distance, this.end.z + distance]
  )
  var region = this
  nearRegion.on("enter", function(frame) {
    region.emit("near", frame)
  })
  nearRegion.on("exit", function(frame) {
    region.emit("far", frame)
  })
  region.on('exit', function(frame) {
    region.emit("near", frame)
  })
}

Region.prototype.updatePosition = function(frame) {
  if (this.nearRegion) this.nearRegion.updatePosition(frame)
  if (this.hasPointables(frame) && this.enteredFrame == null) {
    this.enteredFrame = frame
    this.emit("enter", this.enteredFrame)
  } else if (!this.hasPointables(frame) && this.enteredFrame != null) {
    this.enteredFrame = null
    this.emit("exit", this.enteredFrame)
  }
  return frame
}

Region.prototype.normalize = function(position) {
  return new Vector([
    (position.x - this.start.x) / (this.end.x - this.start.x),
    (position.y - this.start.y) / (this.end.y - this.start.y),
    (position.z - this.start.z) / (this.end.z - this.start.z)
  ])
}

Region.prototype.mapToXY = function(position, width, height) {
  var normalized = this.normalize(position)
  var x = normalized.x, y = normalized.y
  if (x > 1) x = 1
  else if (x < -1) x = -1
  if (y > 1) y = 1
  else if (y < -1) y = -1
  return [
    (x + 1) / 2 * width,
    (1 - y) / 2 * height,
    normalized.z
  ]
}

_.extend(Region.prototype, EventEmitter.prototype)
},{"events":155,"underscore":145}],123:[function(require,module,exports){
// This file is automatically updated from package.json by grunt.
module.exports = {
  full: '0.6.4',
  major: 0,
  minor: 6,
  dot: 4
}
},{}],124:[function(require,module,exports){
(function (global){
/// shim for browser packaging

module.exports = function() {
  return global.WebSocket || global.MozWebSocket;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],125:[function(require,module,exports){
'use strict'

// A linked list to keep track of recently-used-ness
const Yallist = require('yallist')

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache

},{"yallist":148}],126:[function(require,module,exports){
var leapConnector = require('./src/leapConnector');


module.exports.leap = leapConnector;
},{"./src/leapConnector":127}],127:[function(require,module,exports){
var Leap = require('leapjs');
var Pointer = require('./pointer')

/** constant for scaling pointing in the x axis */
var X_SCALE = 150;

/** constant for scaling pointing in the y axis */
var Y_SCALE = -400;

/** constant for offsetting pointing in the y axis */
var Y_OFFSET = 400;

var ROTATION_SCALE = 100;

var MAX_ROTATION = 30;

var MIN_ROTATION = 0.00001;

var LeapConnector = function(gestureDispatcher) {
  this.gestureDispatcher = gestureDispatcher;


  /** Store the lastX for custom pointing algorithm */
  this.lastX = -1;

  /** Store the lastY for custom pointing algorithm */
  this.lastY = -1;

};

LeapConnector.prototype.start = function() {
  var that = this;
  this.controller = Leap.loop({
//    frameEventName: 'deviceFrame',
    enableGestures : false
  }, function(frame) {
    return that.onFrame(frame);
  });
  return that;
}

LeapConnector.prototype.limitRotation = function(r) {
  r *= ROTATION_SCALE;
  r = Math.max(-MAX_ROTATION, r);
  r = Math.min(MAX_ROTATION, r);
  if (Math.abs(r) < MIN_ROTATION) {
    r = 0;
  }
  return r;
}

// workaround for LeapJS bug
// see http://jsfiddle.net/kLs8ymye/2/
// https://github.com/leapmotion/leapjs/issues/188
LeapConnector.prototype.axisAngle = function(rotation) {
    //NOTE: Index = 3*row + col when basis vector 
  var axis = [
    rotation[5] - rotation[7],
    rotation[6] - rotation[2],
    rotation[1] - rotation[3]
  ];
  var sin = Leap.vec3.len(axis);
  var cos = ((rotation[0] + rotation[4] + rotation[8]) - 1.0)*0.5;
  var angle = Math.atan2(sin,cos);

    if (-1e-6 < sin && sin < 1e-6) {
        axis = [0, 0, 0];
        angle = 0;
        return [axis, angle];
    }
    
    Leap.vec3.scale(axis, axis, 1 / sin);
  return [axis,angle];
}

LeapConnector.prototype.getBasis = function (frame) {

  var handLast = frame.hands[0];
  var dir = handLast.direction;
  var nor = handLast.palmNormal;
  var dxn = Leap.vec3.create();
  Leap.vec3.cross(dxn, dir, nor);
  var basisLast = [].concat(dir).concat(nor);
  basisLast[6] = dxn[0];
  basisLast[7] = dxn[1];
  basisLast[8] = dxn[2];
  
  return basisLast;
}

LeapConnector.prototype.onFrame = function(frame) {
  var that = this;
  if (frame.hands.length == 1) {
    if (frame.fingers.length > 3) {
      var lastFrame = this.controller.frame(1);
      if (lastFrame && lastFrame.hands.length > 0) {
        
        // rotate
        that.lastY = -1;
        that.lastX = -1;
  
        var hand = frame.hands[0];
        var translation = hand.translation(lastFrame);
        // comment out for the moment until JS Leap Motion rotation bugs are fixed.
        that.gestureDispatcher.triggerPan(translation[0], -translation[1]);
        that.gestureDispatcher.triggerZoom(-translation[2]);
        
        var basis = that.getBasis(frame); 
        var basisLast = that.getBasis(lastFrame); 
        
        Leap.mat3.transpose(basisLast, basisLast);
        var rotation = Leap.mat3.create();
        Leap.mat3.multiply(rotation, basis, basisLast) 

        //Get axis-angle representation
        var axisAngle = that.axisAngle(rotation);
                      
        Leap.vec3.scale(axisAngle[0], axisAngle[0], axisAngle[1]);
        
        
        
        // yaw pitch roll are slightly better, but there still seems to be an issue.
//        var xRotation = this.limitRotation(hand.pitch() - lastFrame.hands[0].pitch());
//        var yRotation = this.limitRotation(hand.yaw() - lastFrame.hands[0].yaw());
//        var zRotation = this.limitRotation(hand.roll() - lastFrame.hands[0].roll());
        
        // these rotations have an issue where changes aren't updated properly.
        // see https://github.com/leapmotion/leapjs/issues/188
//        var xRotation = this.limitRotation(hand.rotationAngle(lastFrame, [ 1, 0, 0 ]));
//        var yRotation = this.limitRotation(hand.rotationAngle(lastFrame, [ 0, 1, 0 ]));
//        var zRotation = this.limitRotation(hand.rotationAngle(lastFrame, [ 0, 0, 1 ]));
        // console.log('lastframe1: ' + that.lastFrame);
        if (Math.abs(axisAngle[0][0]) > MIN_ROTATION || 
            Math.abs(axisAngle[0][1]) > MIN_ROTATION || 
            Math.abs(axisAngle[0][2]) > MIN_ROTATION) {
          that.gestureDispatcher.triggerRotate(this.limitRotation(axisAngle[0][0]),
              this.limitRotation(axisAngle[0][1]), this.limitRotation(axisAngle[0][2]));
        }
      }
    } else if (frame.fingers.length > 0) {

      try {
        var finger = frame.fingers[0];
        var hit = Pointer(finger);
        // Vector hit =
        // controller.locatedScreens().closestScreenHit(finger).intersect(finger,true);
        var zVel = finger.tipVelocity.getZ[2];
        var absZVel = Math.abs(zVel);
        var y = hit.getY();
        var x = hit.getX();

        if (absZVel > 50 && that.lastY != -1) {
          var scale = 2500 / (absZVel * absZVel);
          x = (hit.x - that.lastX) * scale + that.lastX;
          y = (hit.y - that.lastY) * scale + that.lastY;
        }
        that.lastY = y;
        that.lastX = x;
        if (!isNaN(x) && !isNaN(y)) {
          // that.gestureDispatcher.point(x, y);
        }
      } catch (e) {
        console.log('error occurred when pointing: ' + e);
      }
    } else {
      that.lastY = -1;
      that.lastX = -1;

    }
    var i;
    if (frame.gestures) {

      frame.gestures.forEach(function(gesture) {
        switch (gesture.type) {
        case 'swipe':
          that.gestureDispatcher.reset();
          break;
        case 'screenTap':

          that.gestureDispatcher.selectMouseCursor();
          // add a delay so the app can process the mouse clicks.
          setTimeout(that.gestureDispatcher.zoomToSelection, 100);
          break;
        case 'keyTap':
          that.gestureDispatcher.zoomToSelection();
          break;
        default:
          console.log("Unknown gesture type: " + gesture.type);
          break;
        }
      });
    }
  }
  // console.log('lastframe2: ' + that.lastFrame);
}

module.exports = LeapConnector;

},{"./pointer":128,"leapjs":115}],128:[function(require,module,exports){
// adapted from a forum post by cabbibo:
// https://github.com/leapmotion/leapjs/issues/31
// http://cabbibo.com/leap/lmlab/mouse/test.html

/*

Below are all of the starting parameters for the different
Pointer Acceleration Functions. 

Additionally the look and feel of the graph is created here.

*/
var PARAMS = function(){
  
  
  //Function Type that we are starting with 
  this.functionType = 'atan'
  
  
  //power function
  this.power = {
    division:300,
    divisionRange:[1,10000],
    power:1,
    powerRange:[0,3]
    
  }
  
  
  this.atan = {
    division1:660,
    division1Range:[0,10000],
    division2:0.5,
    division2Range:[0,1]
  }
  
  this.asymp1 = {
    max:0.5,
    maxRange:[0,1],
    min:0.001,
    minRange:[0,.1],
    Vo:200,
    VoRange:[1,10000]
  }
  
  this.asymp2 = {
    max:0.001,
    maxRange:[0,.01],
    min:0.001,
    minRange:[0,.01],
    Vo:1500,
    VoRange:[0,3000],
  }
  
  
  
  //Look and Feel Section
  this.mouseSize = 10
  this.frameOpacity = 800
  
  this.gainGraphFrames = 200
  
  
  
  

  //Moves Cursor to the center of the screen
  this.resetPosition = function(){
    curPos.x = window.innerWidth/2
    curPos.y = window.innerHeight/2
  }
}

//Initialize params
var params = new PARAMS();


//setting up the current position to be in the very center of the screen
var curPos = {
  x:window.innerWidth/2,
  y:window.innerHeight/2
}


var point = function (pointer) {
  
  //get the amount to be added by calling the 'convert' function.
  //The convert function will basically use whatever equation that we have selected
  //In order to create Pointer Acceleration
  var addAmount = convert(pointer.tipVelocity[0],pointer.tipVelocity[1], params.functionType)
  
  
  //Add the altered velocity to the current Position
  var newPos = {
    x:(curPos.x + addAmount.x),
    y:(curPos.y + addAmount.y)
  }
  
  
  /*
    Setting up the bounding box
  */
  if(newPos.x >= window.innerWidth){
    newPos.x = window.innerWidth
  }
  
  if(newPos.x <= 0 ){
    newPos.x =  0
  }
    
  if(newPos.y >= window.innerHeight){
    newPos.y = window.innerHeight
  }
  
  if(newPos.y <= 0 ){
    newPos.y =  0
  }
    
  //Assign the current position to the be the new position for use in the next frame
  curPos = newPos;
  return newPos;
} 


//Function to convert the velocity to something useful
function convert(velocityX, velocityY, type){

  //Gets the magnitude outside the individual functions
  //Becasue it will be the same for every function type
  var magnitude = Math.sqrt((velocityX*velocityX)+(velocityY*velocityY))

  //CD or Control Display Gain, is the amount that 
  var cdGain = 1
  
  
  
  
  
  if(type == 'power'){
    
    cdGain = Math.pow(magnitude,params.power.power) / Math.pow(params.power.division,params.power.power) 
    
  }else if (type == 'atan'){
    
    cdGain = Math.atan(magnitude/params.atan.division1) / params.atan.division2
    
  }else if(type == 'asymp1'){
    
    cdGain = ((params.asymp1.max) *(1- Math.exp(-magnitude/params.asymp1.Vo))+params.asymp1.min)
  
  }else if(type == 'asymp2'){
    
    cdGain = (((params.asymp2.max) * magnitude * Math.exp(-magnitude/params.asymp2.Vo))+params.asymp2.min)
    
  }

  //The amount that we are going to be adding to the current position
  //is simply the Control Display Gain Multiplied by the Velocity
  //the velocityY is negated becasue of the change of Axis direction in browser
  toReturn = {
    x:cdGain*velocityX,
    y:-cdGain*velocityY
  }
  
  //console.log(toReturn.x)
  return toReturn 
  
}


module.exports = point;
module.exports.reset = params.resetPosition;
},{}],129:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sbastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],130:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":131,"./lib/tychei":132,"./lib/xor128":133,"./lib/xor4096":134,"./lib/xorshift7":135,"./lib/xorwow":136,"./seedrandom":137}],131:[function(require,module,exports){
// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],132:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],133:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],134:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],135:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],136:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],137:[function(require,module,exports){
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":151}],138:[function(require,module,exports){
(function (process,global){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":160}],139:[function(require,module,exports){
var Stream = require('stream');
var sockjs = require('sockjs-client');
var resolve = require('url').resolve;
var parse = require('url').parse;

module.exports = function (u, cb) {
    var uri = parse(u).protocol ? u : resolve(window.location.href, u);
    
    var stream = new Stream;
    stream.readable = true;
    stream.writable = true;
    
    var ready = false;
    var buffer = [];
    
    var sock = sockjs(uri);
    stream.sock = sock;
    
    stream.write = function (msg) {
        if (!ready || buffer.length) buffer.push(msg)
        else sock.send(msg)
    };
    
    stream.end = function (msg) {
        if (msg !== undefined) stream.write(msg);
        if (!ready) {
            stream._ended = true;
            return;
        }
        stream.writable = false;
        sock.close();
    };
    
    stream.destroy = function () {
        stream._ended = true;
        stream.writable = stream.readable = false;
        buffer.length = 0
        sock.close();
    };
    
    sock.onopen = function () {
        if (typeof cb === 'function') cb();
        ready = true;
        for (var i = 0; i < buffer.length; i++) {
            sock.send(buffer[i]);
        }
        buffer = [];
        stream.emit('connect');
        if (stream._ended) stream.end();
    };
    
    sock.onmessage = function (e) {
        stream.emit('data', e.data);
    };
    
    sock.onclose = function () {
        stream.emit('end');
        stream.writable = false;
        stream.readable = false;
    };
    
    return stream;
};

},{"sockjs-client":140,"stream":175,"url":177}],140:[function(require,module,exports){
/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// JSON2 by Douglas Crockford (minified).
var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()


//     [*] Including lib/index.js
// Public object
var SockJS = (function(){
              var _document = document;
              var _window = window;
              var utils = {};


//         [*] Including lib/reventtarget.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */
var REventTarget = function() {};
REventTarget.prototype.addEventListener = function (eventType, listener) {
    if(!this._listeners) {
         this._listeners = {};
    }
    if(!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
    }
    var arr = this._listeners[eventType];
    if(utils.arrIndexOf(arr, listener) === -1) {
        arr.push(listener);
    }
    return;
};

REventTarget.prototype.removeEventListener = function (eventType, listener) {
    if(!(this._listeners && (eventType in this._listeners))) {
        return;
    }
    var arr = this._listeners[eventType];
    var idx = utils.arrIndexOf(arr, listener);
    if (idx !== -1) {
        if(arr.length > 1) {
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );
        } else {
            delete this._listeners[eventType];
        }
        return;
    }
    return;
};

REventTarget.prototype.dispatchEvent = function (event) {
    var t = event.type;
    var args = Array.prototype.slice.call(arguments, 0);
    if (this['on'+t]) {
        this['on'+t].apply(this, args);
    }
    if (this._listeners && t in this._listeners) {
        for(var i=0; i < this._listeners[t].length; i++) {
            this._listeners[t][i].apply(this, args);
        }
    }
};
//         [*] End of lib/reventtarget.js


//         [*] Including lib/simpleevent.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SimpleEvent = function(type, obj) {
    this.type = type;
    if (typeof obj !== 'undefined') {
        for(var k in obj) {
            if (!obj.hasOwnProperty(k)) continue;
            this[k] = obj[k];
        }
    }
};

SimpleEvent.prototype.toString = function() {
    var r = [];
    for(var k in this) {
        if (!this.hasOwnProperty(k)) continue;
        var v = this[k];
        if (typeof v === 'function') v = '[function]';
        r.push(k + '=' + v);
    }
    return 'SimpleEvent(' + r.join(', ') + ')';
};
//         [*] End of lib/simpleevent.js


//         [*] Including lib/eventemitter.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventEmitter = function(events) {
    this.events = events || [];
};
EventEmitter.prototype.emit = function(type) {
    var that = this;
    var args = Array.prototype.slice.call(arguments, 1);
    if (!that.nuked && that['on'+type]) {
        that['on'+type].apply(that, args);
    }
    if (utils.arrIndexOf(that.events, type) === -1) {
        utils.log('Event ' + JSON.stringify(type) +
                  ' not listed ' + JSON.stringify(that.events) +
                  ' in ' + that);
    }
};

EventEmitter.prototype.nuke = function(type) {
    var that = this;
    that.nuked = true;
    for(var i=0; i<that.events.length; i++) {
        delete that[that.events[i]];
    }
};
//         [*] End of lib/eventemitter.js


//         [*] Including lib/utils.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';
utils.random_string = function(length, max) {
    max = max || random_string_chars.length;
    var i, ret = [];
    for(i=0; i < length; i++) {
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );
    }
    return ret.join('');
};
utils.random_number = function(max) {
    return Math.floor(Math.random() * max);
};
utils.random_number_string = function(max) {
    var t = (''+(max - 1)).length;
    var p = Array(t+1).join('0');
    return (p + utils.random_number(max)).slice(-t);
};

// Assuming that url looks like: http://asdasd:111/asd
utils.getOrigin = function(url) {
    url += '/';
    var parts = url.split('/').slice(0, 3);
    return parts.join('/');
};

utils.isSameOriginUrl = function(url_a, url_b) {
    // location.origin would do, but it's not always available.
    if (!url_b) url_b = _window.location.href;

    return (url_a.split('/').slice(0,3).join('/')
                ===
            url_b.split('/').slice(0,3).join('/'));
};

utils.getParentDomain = function(url) {
    // ipv4 ip address
    if (/^[0-9.]*$/.test(url)) return url;
    // ipv6 ip address
    if (/^\[/.test(url)) return url;
    // no dots
    if (!(/[.]/.test(url))) return url;

    var parts = url.split('.').slice(1);
    return parts.join('.');
};

utils.objectExtend = function(dst, src) {
    for(var k in src) {
        if (src.hasOwnProperty(k)) {
            dst[k] = src[k];
        }
    }
    return dst;
};

var WPrefix = '_jp';

utils.polluteGlobalNamespace = function() {
    if (!(WPrefix in _window)) {
        _window[WPrefix] = {};
    }
};

utils.closeFrame = function (code, reason) {
    return 'c'+JSON.stringify([code, reason]);
};

utils.userSetCode = function (code) {
    return code === 1000 || (code >= 3000 && code <= 4999);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
utils.countRTO = function (rtt) {
    var rto;
    if (rtt > 100) {
        rto = 3 * rtt; // rto > 300msec
    } else {
        rto = rtt + 200; // 200msec < rto <= 300msec
    }
    return rto;
}

utils.log = function() {
    if (_window.console && console.log && console.log.apply) {
        console.log.apply(console, arguments);
    }
};

utils.bind = function(fun, that) {
    if (fun.bind) {
        return fun.bind(that);
    } else {
        return function() {
            return fun.apply(that, arguments);
        };
    }
};

utils.flatUrl = function(url) {
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;
};

utils.amendUrl = function(url) {
    var dl = _document.location;
    if (!url) {
        throw new Error('Wrong url for SockJS');
    }
    if (!utils.flatUrl(url)) {
        throw new Error('Only basic urls are supported in SockJS');
    }

    //  '//abc' --> 'http://abc'
    if (url.indexOf('//') === 0) {
        url = dl.protocol + url;
    }
    // '/abc' --> 'http://localhost:80/abc'
    if (url.indexOf('/') === 0) {
        url = dl.protocol + '//' + dl.host + url;
    }
    // strip trailing slashes
    url = url.replace(/[/]+$/,'');
    return url;
};

// IE doesn't support [].indexOf.
utils.arrIndexOf = function(arr, obj){
    for(var i=0; i < arr.length; i++){
        if(arr[i] === obj){
            return i;
        }
    }
    return -1;
};

utils.arrSkip = function(arr, obj) {
    var idx = utils.arrIndexOf(arr, obj);
    if (idx === -1) {
        return arr.slice();
    } else {
        var dst = arr.slice(0, idx);
        return dst.concat(arr.slice(idx+1));
    }
};

// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df
utils.isArray = Array.isArray || function(value) {
    return {}.toString.call(value).indexOf('Array') >= 0
};

utils.delay = function(t, fun) {
    if(typeof t === 'function') {
        fun = t;
        t = 0;
    }
    return setTimeout(fun, t);
};


// Chars worth escaping, as defined by Douglas Crockford:
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;

// JSON Quote string. Use native implementation when possible.
var JSONQuote = (JSON && JSON.stringify) || function(string) {
    json_escapable.lastIndex = 0;
    if (json_escapable.test(string)) {
        string = string.replace(json_escapable, function(a) {
            return json_lookup[a];
        });
    }
    return '"' + string + '"';
};

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unroll_lookup = function(escapable) {
    var i;
    var unrolled = {}
    var c = []
    for(i=0; i<65536; i++) {
        c.push( String.fromCharCode(i) );
    }
    escapable.lastIndex = 0;
    c.join('').replace(escapable, function (a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
    });
    escapable.lastIndex = 0;
    return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
utils.quote = function(string) {
    var quoted = JSONQuote(string);

    // In most cases this should be very fast and good enough.
    extra_escapable.lastIndex = 0;
    if(!extra_escapable.test(quoted)) {
        return quoted;
    }

    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);

    return quoted.replace(extra_escapable, function(a) {
        return extra_lookup[a];
    });
}

var _all_protocols = ['websocket',
                      'xdr-streaming',
                      'xhr-streaming',
                      'iframe-eventsource',
                      'iframe-htmlfile',
                      'xdr-polling',
                      'xhr-polling',
                      'iframe-xhr-polling',
                      'jsonp-polling'];

utils.probeProtocols = function() {
    var probed = {};
    for(var i=0; i<_all_protocols.length; i++) {
        var protocol = _all_protocols[i];
        // User can have a typo in protocol name.
        probed[protocol] = SockJS[protocol] &&
                           SockJS[protocol].enabled();
    }
    return probed;
};

utils.detectProtocols = function(probed, protocols_whitelist, info) {
    var pe = {},
        protocols = [];
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;
    for(var i=0; i<protocols_whitelist.length; i++) {
        var protocol = protocols_whitelist[i];
        pe[protocol] = probed[protocol];
    }
    var maybe_push = function(protos) {
        var proto = protos.shift();
        if (pe[proto]) {
            protocols.push(proto);
        } else {
            if (protos.length > 0) {
                maybe_push(protos);
            }
        }
    }

    // 1. Websocket
    if (info.websocket !== false) {
        maybe_push(['websocket']);
    }

    // 2. Streaming
    if (pe['xhr-streaming'] && !info.null_origin) {
        protocols.push('xhr-streaming');
    } else {
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-streaming');
        } else {
            maybe_push(['iframe-eventsource',
                        'iframe-htmlfile']);
        }
    }

    // 3. Polling
    if (pe['xhr-polling'] && !info.null_origin) {
        protocols.push('xhr-polling');
    } else {
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-polling');
        } else {
            maybe_push(['iframe-xhr-polling',
                        'jsonp-polling']);
        }
    }
    return protocols;
}
//         [*] End of lib/utils.js


//         [*] Including lib/dom.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// May be used by htmlfile jsonp and transports.
var MPrefix = '_sockjs_global';
utils.createHook = function() {
    var window_id = 'a' + utils.random_string(8);
    if (!(MPrefix in _window)) {
        var map = {};
        _window[MPrefix] = function(window_id) {
            if (!(window_id in map)) {
                map[window_id] = {
                    id: window_id,
                    del: function() {delete map[window_id];}
                };
            }
            return map[window_id];
        }
    }
    return _window[MPrefix](window_id);
};



utils.attachMessage = function(listener) {
    utils.attachEvent('message', listener);
};
utils.attachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.addEventListener(event, listener, false);
    } else {
        // IE quirks.
        // According to: http://stevesouders.com/misc/test-postmessage.php
        // the message gets delivered only to 'document', not 'window'.
        _document.attachEvent("on" + event, listener);
        // I get 'window' for ie8.
        _window.attachEvent("on" + event, listener);
    }
};

utils.detachMessage = function(listener) {
    utils.detachEvent('message', listener);
};
utils.detachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.removeEventListener(event, listener, false);
    } else {
        _document.detachEvent("on" + event, listener);
        _window.detachEvent("on" + event, listener);
    }
};


var on_unload = {};
// Things registered after beforeunload are to be called immediately.
var after_unload = false;

var trigger_unload_callbacks = function() {
    for(var ref in on_unload) {
        on_unload[ref]();
        delete on_unload[ref];
    };
};

var unload_triggered = function() {
    if(after_unload) return;
    after_unload = true;
    trigger_unload_callbacks();
};

// Onbeforeunload alone is not reliable. We could use only 'unload'
// but it's not working in opera within an iframe. Let's use both.
utils.attachEvent('beforeunload', unload_triggered);
utils.attachEvent('unload', unload_triggered);

utils.unload_add = function(listener) {
    var ref = utils.random_string(8);
    on_unload[ref] = listener;
    if (after_unload) {
        utils.delay(trigger_unload_callbacks);
    }
    return ref;
};
utils.unload_del = function(ref) {
    if (ref in on_unload)
        delete on_unload[ref];
};


utils.createIframe = function (iframe_url, error_callback) {
    var iframe = _document.createElement('iframe');
    var tref, unload_ref;
    var unattach = function() {
        clearTimeout(tref);
        // Explorer had problems with that.
        try {iframe.onload = null;} catch (x) {}
        iframe.onerror = null;
    };
    var cleanup = function() {
        if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
                if(iframe) {
                    iframe.parentNode.removeChild(iframe);
                }
                iframe = null;
            }, 0);
            utils.unload_del(unload_ref);
        }
    };
    var onerror = function(r) {
        if (iframe) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    iframe.src = iframe_url;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function(){onerror('onerror');};
    iframe.onload = function() {
        // `onload` is triggered before scripts on the iframe are
        // executed. Give it few seconds to actually load stuff.
        clearTimeout(tref);
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);
    };
    _document.body.appendChild(iframe);
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};

utils.createHtmlfile = function (iframe_url, error_callback) {
    var doc = new ActiveXObject('htmlfile');
    var tref, unload_ref;
    var iframe;
    var unattach = function() {
        clearTimeout(tref);
    };
    var cleanup = function() {
        if (doc) {
            unattach();
            utils.unload_del(unload_ref);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
        }
    };
    var onerror = function(r)  {
        if (doc) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[WPrefix] = _window[WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframe_url;
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};
//         [*] End of lib/dom.js


//         [*] Including lib/dom2.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AbstractXHRObject = function(){};
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
    var that = this;

    try {
        that.xhr = new XMLHttpRequest();
    } catch(x) {};

    if (!that.xhr) {
        try {
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');
        } catch(x) {};
    }
    if (_window.ActiveXObject || _window.XDomainRequest) {
        // IE8 caches even POSTs
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);
    }

    // Explorer tends to keep connection open, even after the
    // tab gets closed: http://bugs.jquery.com/ticket/5280
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        that.xhr.open(method, url, true);
    } catch(e) {
        // IE raises an exception on wrong port.
        that.emit('finish', 0, '');
        that._cleanup();
        return;
    };

    if (!opts || !opts.no_credentials) {
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."
        that.xhr.withCredentials = 'true';
    }
    if (opts && opts.headers) {
        for(var key in opts.headers) {
            that.xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    that.xhr.onreadystatechange = function() {
        if (that.xhr) {
            var x = that.xhr;
            switch (x.readyState) {
            case 3:
                // IE doesn't like peeking into responseText or status
                // on Microsoft.XMLHTTP and readystate=3
                try {
                    var status = x.status;
                    var text = x.responseText;
                } catch (x) {};
                // IE does return readystate == 3 for 404 answers.
                if (text && text.length > 0) {
                    that.emit('chunk', status, text);
                }
                break;
            case 4:
                that.emit('finish', x.status, x.responseText);
                that._cleanup(false);
                break;
            }
        }
    };
    that.xhr.send(payload);
};

AbstractXHRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xhr) return;
    utils.unload_del(that.unload_ref);

    // IE needs this field to be a function
    that.xhr.onreadystatechange = function(){};

    if (abort) {
        try {
            that.xhr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

var XHRCorsObject = utils.XHRCorsObject = function() {
    var that = this, args = arguments;
    utils.delay(function(){that._start.apply(that, args);});
};
XHRCorsObject.prototype = new AbstractXHRObject();

var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){
        that._start(method, url, payload, {
            no_credentials: true
        });
    });
};
XHRLocalObject.prototype = new AbstractXHRObject();



// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
var XDRObject = utils.XDRObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){that._start(method, url, payload);});
};
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);
XDRObject.prototype._start = function(method, url, payload) {
    var that = this;
    var xdr = new XDomainRequest();
    // IE caches even POSTs
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);

    var onerror = xdr.ontimeout = xdr.onerror = function() {
        that.emit('finish', 0, '');
        that._cleanup(false);
    };
    xdr.onprogress = function() {
        that.emit('chunk', 200, xdr.responseText);
    };
    xdr.onload = function() {
        that.emit('finish', 200, xdr.responseText);
        that._cleanup(false);
    };
    that.xdr = xdr;
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        // Fails with AccessDenied if port number is bogus
        that.xdr.open(method, url);
        that.xdr.send(payload);
    } catch(x) {
        onerror();
    }
};

XDRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xdr) return;
    utils.unload_del(that.unload_ref);

    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =
        that.xdr.onload = null;
    if (abort) {
        try {
            that.xdr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xdr = null;
};

XDRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

// 1. Is natively via XHR
// 2. Is natively via XDR
// 3. Nope, but postMessage is there so it should work via the Iframe.
// 4. Nope, sorry.
utils.isXHRCorsCapable = function() {
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
        return 1;
    }
    // XDomainRequest doesn't work if page is served from file://
    if (_window.XDomainRequest && _document.domain) {
        return 2;
    }
    if (IframeTransport.enabled()) {
        return 3;
    }
    return 4;
};
//         [*] End of lib/dom2.js


//         [*] Including lib/sockjs.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SockJS = function(url, dep_protocols_whitelist, options) {
    if (this === window) {
        // makes `new` optional
        return new SockJS(url, dep_protocols_whitelist, options);
    }
    
    var that = this, protocols_whitelist;
    that._options = {devel: false, debug: false, protocols_whitelist: [],
                     info: undefined, rtt: undefined};
    if (options) {
        utils.objectExtend(that._options, options);
    }
    that._base_url = utils.amendUrl(url);
    that._server = that._options.server || utils.random_number_string(1000);
    if (that._options.protocols_whitelist &&
        that._options.protocols_whitelist.length) {
        protocols_whitelist = that._options.protocols_whitelist;
    } else {
        // Deprecated API
        if (typeof dep_protocols_whitelist === 'string' &&
            dep_protocols_whitelist.length > 0) {
            protocols_whitelist = [dep_protocols_whitelist];
        } else if (utils.isArray(dep_protocols_whitelist)) {
            protocols_whitelist = dep_protocols_whitelist
        } else {
            protocols_whitelist = null;
        }
        if (protocols_whitelist) {
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +
                        'instead of supplying protocol list as a second ' +
                        'parameter to SockJS constructor.');
        }
    }
    that._protocols = [];
    that.protocol = null;
    that.readyState = SockJS.CONNECTING;
    that._ir = createInfoReceiver(that._base_url);
    that._ir.onfinish = function(info, rtt) {
        that._ir = null;
        if (info) {
            if (that._options.info) {
                // Override if user supplies the option
                info = utils.objectExtend(info, that._options.info);
            }
            if (that._options.rtt) {
                rtt = that._options.rtt;
            }
            that._applyInfo(info, rtt, protocols_whitelist);
            that._didClose();
        } else {
            that._didClose(1002, 'Can\'t connect to server', true);
        }
    };
};
// Inheritance
SockJS.prototype = new REventTarget();

SockJS.version = "0.3.1.7.ga67f.dirty";

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._debug = function() {
    if (this._options.debug)
        utils.log.apply(utils, arguments);
};

SockJS.prototype._dispatchOpen = function() {
    var that = this;
    if (that.readyState === SockJS.CONNECTING) {
        if (that._transport_tref) {
            clearTimeout(that._transport_tref);
            that._transport_tref = null;
        }
        that.readyState = SockJS.OPEN;
        that.dispatchEvent(new SimpleEvent("open"));
    } else {
        // The server might have been restarted, and lost track of our
        // connection.
        that._didClose(1006, "Server lost session");
    }
};

SockJS.prototype._dispatchMessage = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
            return;
    that.dispatchEvent(new SimpleEvent("message", {data: data}));
};

SockJS.prototype._dispatchHeartbeat = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
        return;
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));
};

SockJS.prototype._didClose = function(code, reason, force) {
    var that = this;
    if (that.readyState !== SockJS.CONNECTING &&
        that.readyState !== SockJS.OPEN &&
        that.readyState !== SockJS.CLOSING)
            throw new Error('INVALID_STATE_ERR');
    if (that._ir) {
        that._ir.nuke();
        that._ir = null;
    }

    if (that._transport) {
        that._transport.doCleanup();
        that._transport = null;
    }

    var close_event = new SimpleEvent("close", {
        code: code,
        reason: reason,
        wasClean: utils.userSetCode(code)});

    if (!utils.userSetCode(code) &&
        that.readyState === SockJS.CONNECTING && !force) {
        if (that._try_next_protocol(close_event)) {
            return;
        }
        close_event = new SimpleEvent("close", {code: 2000,
                                                reason: "All transports failed",
                                                wasClean: false,
                                                last_event: close_event});
    }
    that.readyState = SockJS.CLOSED;

    utils.delay(function() {
                   that.dispatchEvent(close_event);
                });
};

SockJS.prototype._didMessage = function(data) {
    var that = this;
    var type = data.slice(0, 1);
    switch(type) {
    case 'o':
        that._dispatchOpen();
        break;
    case 'a':
        var payload = JSON.parse(data.slice(1) || '[]');
        for(var i=0; i < payload.length; i++){
            that._dispatchMessage(payload[i]);
        }
        break;
    case 'm':
        var payload = JSON.parse(data.slice(1) || 'null');
        that._dispatchMessage(payload);
        break;
    case 'c':
        var payload = JSON.parse(data.slice(1) || '[]');
        that._didClose(payload[0], payload[1]);
        break;
    case 'h':
        that._dispatchHeartbeat();
        break;
    }
};

SockJS.prototype._try_next_protocol = function(close_event) {
    var that = this;
    if (that.protocol) {
        that._debug('Closed transport:', that.protocol, ''+close_event);
        that.protocol = null;
    }
    if (that._transport_tref) {
        clearTimeout(that._transport_tref);
        that._transport_tref = null;
    }

    while(1) {
        var protocol = that.protocol = that._protocols.shift();
        if (!protocol) {
            return false;
        }
        // Some protocols require access to `body`, what if were in
        // the `head`?
        if (SockJS[protocol] &&
            SockJS[protocol].need_body === true &&
            (!_document.body ||
             (typeof _document.readyState !== 'undefined'
              && _document.readyState !== 'complete'))) {
            that._protocols.unshift(protocol);
            that.protocol = 'waiting-for-load';
            utils.attachEvent('load', function(){
                that._try_next_protocol();
            });
            return true;
        }

        if (!SockJS[protocol] ||
              !SockJS[protocol].enabled(that._options)) {
            that._debug('Skipping transport:', protocol);
        } else {
            var roundTrips = SockJS[protocol].roundTrips || 1;
            var to = ((that._options.rto || 0) * roundTrips) || 5000;
            that._transport_tref = utils.delay(to, function() {
                if (that.readyState === SockJS.CONNECTING) {
                    // I can't understand how it is possible to run
                    // this timer, when the state is CLOSED, but
                    // apparently in IE everythin is possible.
                    that._didClose(2007, "Transport timeouted");
                }
            });

            var connid = utils.random_string(8);
            var trans_url = that._base_url + '/' + that._server + '/' + connid;
            that._debug('Opening transport:', protocol, ' url:'+trans_url,
                        ' RTO:'+that._options.rto);
            that._transport = new SockJS[protocol](that, trans_url,
                                                   that._base_url);
            return true;
        }
    }
};

SockJS.prototype.close = function(code, reason) {
    var that = this;
    if (code && !utils.userSetCode(code))
        throw new Error("INVALID_ACCESS_ERR");
    if(that.readyState !== SockJS.CONNECTING &&
       that.readyState !== SockJS.OPEN) {
        return false;
    }
    that.readyState = SockJS.CLOSING;
    that._didClose(code || 1000, reason || "Normal closure");
    return true;
};

SockJS.prototype.send = function(data) {
    var that = this;
    if (that.readyState === SockJS.CONNECTING)
        throw new Error('INVALID_STATE_ERR');
    if (that.readyState === SockJS.OPEN) {
        that._transport.doSend(utils.quote('' + data));
    }
    return true;
};

SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {
    var that = this;
    that._options.info = info;
    that._options.rtt = rtt;
    that._options.rto = utils.countRTO(rtt);
    that._options.info.null_origin = !_document.domain;
    var probed = utils.probeProtocols();
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);
};
//         [*] End of lib/sockjs.js


//         [*] Including lib/trans-websocket.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {
    var that = this;
    var url = trans_url + '/websocket';
    if (url.slice(0, 5) === 'https') {
        url = 'wss' + url.slice(5);
    } else {
        url = 'ws' + url.slice(4);
    }
    that.ri = ri;
    that.url = url;
    var Constructor = _window.WebSocket || _window.MozWebSocket;

    that.ws = new Constructor(that.url);
    that.ws.onmessage = function(e) {
        that.ri._didMessage(e.data);
    };
    // Firefox has an interesting bug. If a websocket connection is
    // created after onbeforeunload, it stays alive even when user
    // navigates away from the page. In such situation let's lie -
    // let's not open the ws connection at all. See:
    // https://github.com/sockjs/sockjs-client/issues/28
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
    that.unload_ref = utils.unload_add(function(){that.ws.close()});
    that.ws.onclose = function() {
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));
    };
};

WebSocketTransport.prototype.doSend = function(data) {
    this.ws.send('[' + data + ']');
};

WebSocketTransport.prototype.doCleanup = function() {
    var that = this;
    var ws = that.ws;
    if (ws) {
        ws.onmessage = ws.onclose = null;
        ws.close();
        utils.unload_del(that.unload_ref);
        that.unload_ref = that.ri = that.ws = null;
    }
};

WebSocketTransport.enabled = function() {
    return !!(_window.WebSocket || _window.MozWebSocket);
};

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;
//         [*] End of lib/trans-websocket.js


//         [*] Including lib/trans-sender.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var BufferedSender = function() {};
BufferedSender.prototype.send_constructor = function(sender) {
    var that = this;
    that.send_buffer = [];
    that.sender = sender;
};
BufferedSender.prototype.doSend = function(message) {
    var that = this;
    that.send_buffer.push(message);
    if (!that.send_stop) {
        that.send_schedule();
    }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.send_schedule_wait = function() {
    var that = this;
    var tref;
    that.send_stop = function() {
        that.send_stop = null;
        clearTimeout(tref);
    };
    tref = utils.delay(25, function() {
        that.send_stop = null;
        that.send_schedule();
    });
};

BufferedSender.prototype.send_schedule = function() {
    var that = this;
    if (that.send_buffer.length > 0) {
        var payload = '[' + that.send_buffer.join(',') + ']';
        that.send_stop = that.sender(that.trans_url,
                                     payload,
                                     function() {
                                         that.send_stop = null;
                                         that.send_schedule_wait();
                                     });
        that.send_buffer = [];
    }
};

BufferedSender.prototype.send_destructor = function() {
    var that = this;
    if (that._send_stop) {
        that._send_stop();
    }
    that._send_stop = null;
};

var jsonPGenericSender = function(url, payload, callback) {
    var that = this;

    if (!('_send_form' in that)) {
        var form = that._send_form = _document.createElement('form');
        var area = that._send_area = _document.createElement('textarea');
        area.name = 'd';
        form.style.display = 'none';
        form.style.position = 'absolute';
        form.method = 'POST';
        form.enctype = 'application/x-www-form-urlencoded';
        form.acceptCharset = "UTF-8";
        form.appendChild(area);
        _document.body.appendChild(form);
    }
    var form = that._send_form;
    var area = that._send_area;
    var id = 'a' + utils.random_string(8);
    form.target = id;
    form.action = url + '/jsonp_send?i=' + id;

    var iframe;
    try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = _document.createElement('<iframe name="'+ id +'">');
    } catch(x) {
        iframe = _document.createElement('iframe');
        iframe.name = id;
    }
    iframe.id = id;
    form.appendChild(iframe);
    iframe.style.display = 'none';

    try {
        area.value = payload;
    } catch(e) {
        utils.log('Your browser is seriously broken. Go home! ' + e.message);
    }
    form.submit();

    var completed = function(e) {
        if (!iframe.onerror) return;
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        utils.delay(500, function() {
                       iframe.parentNode.removeChild(iframe);
                       iframe = null;
                   });
        area.value = '';
        callback();
    };
    iframe.onerror = iframe.onload = completed;
    iframe.onreadystatechange = function(e) {
        if (iframe.readyState == 'complete') completed();
    };
    return completed;
};

var createAjaxSender = function(AjaxObject) {
    return function(url, payload, callback) {
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);
        xo.onfinish = function(status, text) {
            callback(status);
        };
        return function(abort_reason) {
            callback(0, abort_reason);
        };
    };
};
//         [*] End of lib/trans-sender.js


//         [*] Including lib/trans-jsonp-receiver.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Parts derived from Socket.io:
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js
// and jQuery-JSONP:
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js
var jsonPGenericReceiver = function(url, callback) {
    var tref;
    var script = _document.createElement('script');
    var script2;  // Opera synchronous load trick.
    var close_script = function(frame) {
        if (script2) {
            script2.parentNode.removeChild(script2);
            script2 = null;
        }
        if (script) {
            clearTimeout(tref);
            script.parentNode.removeChild(script);
            script.onreadystatechange = script.onerror =
                script.onload = script.onclick = null;
            script = null;
            callback(frame);
            callback = null;
        }
    };

    // IE9 fires 'error' event after orsc or before, in random order.
    var loaded_okay = false;
    var error_timer = null;

    script.id = 'a' + utils.random_string(8);
    script.src = url;
    script.type = 'text/javascript';
    script.charset = 'UTF-8';
    script.onerror = function(e) {
        if (!error_timer) {
            // Delay firing close_script.
            error_timer = setTimeout(function() {
                if (!loaded_okay) {
                    close_script(utils.closeFrame(
                        1006,
                        "JSONP script loaded abnormally (onerror)"));
                }
            }, 1000);
        }
    };
    script.onload = function(e) {
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));
    };

    script.onreadystatechange = function(e) {
        if (/loaded|closed/.test(script.readyState)) {
            if (script && script.htmlFor && script.onclick) {
                loaded_okay = true;
                try {
                    // In IE, actually execute the script.
                    script.onclick();
                } catch (x) {}
            }
            if (script) {
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));
            }
        }
    };
    // IE: event/htmlFor/onclick trick.
    // One can't rely on proper order for onreadystatechange. In order to
    // make sure, set a 'htmlFor' and 'event' properties, so that
    // script code will be installed as 'onclick' handler for the
    // script object. Later, onreadystatechange, manually execute this
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
    // set. For reference see:
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    // Also, read on that about script ordering:
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
    if (typeof script.async === 'undefined' && _document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!/opera/i.test(navigator.userAgent)) {
            // Naively assume we're in IE
            try {
                script.htmlFor = script.id;
                script.event = "onclick";
            } catch (x) {}
            script.async = true;
        } else {
            // Opera, second sync script hack
            script2 = _document.createElement('script');
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};";
            script.async = script2.async = false;
        }
    }
    if (typeof script.async !== 'undefined') {
        script.async = true;
    }

    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
    tref = setTimeout(function() {
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));
                      }, 35000);

    var head = _document.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    if (script2) {
        head.insertBefore(script2, head.firstChild);
    }
    return close_script;
};
//         [*] End of lib/trans-jsonp-receiver.js


//         [*] Including lib/trans-jsonp-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// mssage could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors


var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {
    utils.polluteGlobalNamespace();
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(jsonPGenericSender);
    that._schedule_recv();
};

// Inheritnace
JsonPTransport.prototype = new BufferedSender();

JsonPTransport.prototype._schedule_recv = function() {
    var that = this;
    var callback = function(data) {
        that._recv_stop = null;
        if (data) {
            // no data - heartbeat;
            if (!that._is_closing) {
                that.ri._didMessage(data);
            }
        }
        // The message can be a close message, and change is_closing state.
        if (!that._is_closing) {
            that._schedule_recv();
        }
    };
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',
                                           jsonPGenericReceiver, callback);
};

JsonPTransport.enabled = function() {
    return true;
};

JsonPTransport.need_body = true;


JsonPTransport.prototype.doCleanup = function() {
    var that = this;
    that._is_closing = true;
    if (that._recv_stop) {
        that._recv_stop();
    }
    that.ri = that._recv_stop = null;
    that.send_destructor();
};


// Abstract away code that handles global namespace pollution.
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {
    var id = 'a' + utils.random_string(6);
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);
    // Callback will be called exactly once.
    var callback = function(frame) {
        delete _window[WPrefix][id];
        user_callback(frame);
    };

    var close_script = constructReceiver(url_id, callback);
    _window[WPrefix][id] = close_script;
    var stop = function() {
        if (_window[WPrefix][id]) {
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));
        }
    };
    return stop;
};
//         [*] End of lib/trans-jsonp-polling.js


//         [*] Including lib/trans-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AjaxBasedTransport = function() {};
AjaxBasedTransport.prototype = new BufferedSender();

AjaxBasedTransport.prototype.run = function(ri, trans_url,
                                            url_suffix, Receiver, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(createAjaxSender(AjaxObject));
    that.poll = new Polling(ri, Receiver,
                            trans_url + url_suffix, AjaxObject);
};

AjaxBasedTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.poll) {
        that.poll.abort();
        that.poll = null;
    }
};

// xhr-streaming
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);
};

XhrStreamingTransport.prototype = new AjaxBasedTransport();

XhrStreamingTransport.enabled = function() {
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but
    // doesn't do streaming.
    return (_window.XMLHttpRequest &&
            'withCredentials' in new XMLHttpRequest() &&
            (!/opera/i.test(navigator.userAgent)));
};
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
XhrStreamingTransport.need_body = true;


// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/


// xdr-streaming
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);
};

XdrStreamingTransport.prototype = new AjaxBasedTransport();

XdrStreamingTransport.enabled = function() {
    return !!_window.XDomainRequest;
};
XdrStreamingTransport.roundTrips = 2; // preflight, ajax



// xhr-polling
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);
};

XhrPollingTransport.prototype = new AjaxBasedTransport();

XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
XhrPollingTransport.roundTrips = 2; // preflight, ajax


// xdr-polling
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);
};

XdrPollingTransport.prototype = new AjaxBasedTransport();

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.roundTrips = 2; // preflight, ajax
//         [*] End of lib/trans-xhr.js


//         [*] Including lib/trans-iframe.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Few cool transports do work only for same-origin. In order to make
// them working cross-domain we shall use iframe, served form the
// remote domain. New browsers, have capabilities to communicate with
// cross domain iframe, using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var IframeTransport = function() {};

IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {
    var that = this;
    that.ri = ri;
    that.origin = utils.getOrigin(base_url);
    that.base_url = base_url;
    that.trans_url = trans_url;

    var iframe_url = base_url + '/iframe.html';
    if (that.ri._options.devel) {
        iframe_url += '?t=' + (+new Date);
    }
    that.window_id = utils.random_string(8);
    iframe_url += '#' + that.window_id;

    that.iframeObj = utils.createIframe(iframe_url, function(r) {
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");
                                        });

    that.onmessage_cb = utils.bind(that.onmessage, that);
    utils.attachMessage(that.onmessage_cb);
};

IframeTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.iframeObj) {
        utils.detachMessage(that.onmessage_cb);
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (that.iframeObj.iframe.contentWindow) {
                that.postMessage('c');
            }
        } catch (x) {}
        that.iframeObj.cleanup();
        that.iframeObj = null;
        that.onmessage_cb = that.iframeObj = null;
    }
};

IframeTransport.prototype.onmessage = function(e) {
    var that = this;
    if (e.origin !== that.origin) return;
    var window_id = e.data.slice(0, 8);
    var type = e.data.slice(8, 9);
    var data = e.data.slice(9);

    if (window_id !== that.window_id) return;

    switch(type) {
    case 's':
        that.iframeObj.loaded();
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
        break;
    case 't':
        that.ri._didMessage(data);
        break;
    }
};

IframeTransport.prototype.postMessage = function(type, data) {
    var that = this;
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);
};

IframeTransport.prototype.doSend = function (message) {
    this.postMessage('m', message);
};

IframeTransport.enabled = function() {
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
    // huge delay, or not at all.
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;
    return ((typeof _window.postMessage === 'function' ||
            typeof _window.postMessage === 'object') && (!konqueror));
};
//         [*] End of lib/trans-iframe.js


//         [*] Including lib/trans-iframe-within.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var curr_window_id;

var postMessage = function (type, data) {
    if(parent !== _window) {
        parent.postMessage(curr_window_id + type + (data || ''), '*');
    } else {
        utils.log("Can't postMessage, no parent window.", type, data);
    }
};

var FacadeJS = function() {};
FacadeJS.prototype._didClose = function (code, reason) {
    postMessage('t', utils.closeFrame(code, reason));
};
FacadeJS.prototype._didMessage = function (frame) {
    postMessage('t', frame);
};
FacadeJS.prototype._doSend = function (data) {
    this._transport.doSend(data);
};
FacadeJS.prototype._doCleanup = function () {
    this._transport.doCleanup();
};

utils.parent_origin = undefined;

SockJS.bootstrap_iframe = function() {
    var facade;
    curr_window_id = _document.location.hash.slice(1);
    var onMessage = function(e) {
        if(e.source !== parent) return;
        if(typeof utils.parent_origin === 'undefined')
            utils.parent_origin = e.origin;
        if (e.origin !== utils.parent_origin) return;

        var window_id = e.data.slice(0, 8);
        var type = e.data.slice(8, 9);
        var data = e.data.slice(9);
        if (window_id !== curr_window_id) return;
        switch(type) {
        case 's':
            var p = JSON.parse(data);
            var version = p[0];
            var protocol = p[1];
            var trans_url = p[2];
            var base_url = p[3];
            if (version !== SockJS.version) {
                utils.log("Incompatibile SockJS! Main site uses:" +
                          " \"" + version + "\", the iframe:" +
                          " \"" + SockJS.version + "\".");
            }
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                utils.log("Only basic urls are supported in SockJS");
                return;
            }

            if (!utils.isSameOriginUrl(trans_url) ||
                !utils.isSameOriginUrl(base_url)) {
                utils.log("Can't connect to different domain from within an " +
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +
                          ")");
                return;
            }
            facade = new FacadeJS();
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
            break;
        case 'm':
            facade._doSend(data);
            break;
        case 'c':
            if (facade)
                facade._doCleanup();
            facade = null;
            break;
        }
    };

    // alert('test ticker');
    // facade = new FacadeJS();
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');

    utils.attachMessage(onMessage);

    // Start
    postMessage('s');
};
//         [*] End of lib/trans-iframe-within.js


//         [*] Including lib/info.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var InfoReceiver = function(base_url, AjaxObject) {
    var that = this;
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});
};

InfoReceiver.prototype = new EventEmitter(['finish']);

InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {
    var that = this;
    var t0 = (new Date()).getTime();
    var xo = new AjaxObject('GET', base_url + '/info');

    var tref = utils.delay(8000,
                           function(){xo.ontimeout();});

    xo.onfinish = function(status, text) {
        clearTimeout(tref);
        tref = null;
        if (status === 200) {
            var rtt = (new Date()).getTime() - t0;
            var info = JSON.parse(text);
            if (typeof info !== 'object') info = {};
            that.emit('finish', info, rtt);
        } else {
            that.emit('finish');
        }
    };
    xo.ontimeout = function() {
        xo.close();
        that.emit('finish');
    };
};

var InfoReceiverIframe = function(base_url) {
    var that = this;
    var go = function() {
        var ifr = new IframeTransport();
        ifr.protocol = 'w-iframe-info-receiver';
        var fun = function(r) {
            if (typeof r === 'string' && r.substr(0,1) === 'm') {
                var d = JSON.parse(r.substr(1));
                var info = d[0], rtt = d[1];
                that.emit('finish', info, rtt);
            } else {
                that.emit('finish');
            }
            ifr.doCleanup();
            ifr = null;
        };
        var mock_ri = {
            _options: {},
            _didClose: fun,
            _didMessage: fun
        };
        ifr.i_constructor(mock_ri, base_url, base_url);
    }
    if(!_document.body) {
        utils.attachEvent('load', go);
    } else {
        go();
    }
};
InfoReceiverIframe.prototype = new EventEmitter(['finish']);


var InfoReceiverFake = function() {
    // It may not be possible to do cross domain AJAX to get the info
    // data, for example for IE7. But we want to run JSONP, so let's
    // fake the response, with rtt=2s (rto=6s).
    var that = this;
    utils.delay(function() {
        that.emit('finish', {}, 2000);
    });
};
InfoReceiverFake.prototype = new EventEmitter(['finish']);

var createInfoReceiver = function(base_url) {
    if (utils.isSameOriginUrl(base_url)) {
        // If, for some reason, we have SockJS locally - there's no
        // need to start up the complex machinery. Just use ajax.
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    }
    switch (utils.isXHRCorsCapable()) {
    case 1:
        return new InfoReceiver(base_url, utils.XHRCorsObject);
    case 2:
        return new InfoReceiver(base_url, utils.XDRObject);
    case 3:
        // Opera
        return new InfoReceiverIframe(base_url);
    default:
        // IE 7
        return new InfoReceiverFake();
    };
};


var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
    ir.onfinish = function(info, rtt) {
        ri._didMessage('m'+JSON.stringify([info, rtt]));
        ri._didClose();
    }
};
WInfoReceiverIframe.prototype.doCleanup = function() {};
//         [*] End of lib/info.js


//         [*] Including lib/trans-iframe-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {
    var that = this;
    that.protocol = 'w-iframe-eventsource';
    that.i_constructor.apply(that, arguments);
};

EventSourceIframeTransport.prototype = new IframeTransport();

EventSourceIframeTransport.enabled = function () {
    return ('EventSource' in _window) && IframeTransport.enabled();
};

EventSourceIframeTransport.need_body = true;
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource


// w-iframe-eventsource
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);
}
EventSourceTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-eventsource.js


//         [*] Including lib/trans-iframe-xhr-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {
    var that = this;
    that.protocol = 'w-iframe-xhr-polling';
    that.i_constructor.apply(that, arguments);
};

XhrPollingIframeTransport.prototype = new IframeTransport();

XhrPollingIframeTransport.enabled = function () {
    return _window.XMLHttpRequest && IframeTransport.enabled();
};

XhrPollingIframeTransport.need_body = true;
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr


// w-iframe-xhr-polling
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);
};

XhrPollingITransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-xhr-polling.js


//         [*] Including lib/trans-iframe-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// This transport generally works in any browser, but will cause a
// spinning cursor to appear in any browser other than IE.
// We may test this transport in all browsers - why not, but in
// production it should be only run in IE.

var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {
    var that = this;
    that.protocol = 'w-iframe-htmlfile';
    that.i_constructor.apply(that, arguments);
};

// Inheritance.
HtmlFileIframeTransport.prototype = new IframeTransport();

HtmlFileIframeTransport.enabled = function() {
    return IframeTransport.enabled();
};

HtmlFileIframeTransport.need_body = true;
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile


// w-iframe-htmlfile
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);
};
HtmlFileTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-htmlfile.js


//         [*] Including lib/trans-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var Polling = function(ri, Receiver, recv_url, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.Receiver = Receiver;
    that.recv_url = recv_url;
    that.AjaxObject = AjaxObject;
    that._scheduleRecv();
};

Polling.prototype._scheduleRecv = function() {
    var that = this;
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
    var msg_counter = 0;
    poll.onmessage = function(e) {
        msg_counter += 1;
        that.ri._didMessage(e.data);
    };
    poll.onclose = function(e) {
        that.poll = poll = poll.onmessage = poll.onclose = null;
        if (!that.poll_is_closing) {
            if (e.reason === 'permanent') {
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');
            } else {
                that._scheduleRecv();
            }
        }
    };
};

Polling.prototype.abort = function() {
    var that = this;
    that.poll_is_closing = true;
    if (that.poll) {
        that.poll.abort();
    }
};
//         [*] End of lib/trans-polling.js


//         [*] Including lib/trans-receiver-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceReceiver = function(url) {
    var that = this;
    var es = new EventSource(url);
    es.onmessage = function(e) {
        that.dispatchEvent(new SimpleEvent('message',
                                           {'data': unescape(e.data)}));
    };
    that.es_close = es.onerror = function(e, abort_reason) {
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = abort_reason ? 'user' :
            (es.readyState !== 2 ? 'network' : 'permanent');
        that.es_close = es.onmessage = es.onerror = null;
        // EventSource reconnects automatically.
        es.close();
        es = null;
        // Safari and chrome < 15 crash if we close window before
        // waiting for ES cleanup. See:
        //   https://code.google.com/p/chromium/issues/detail?id=89155
        utils.delay(200, function() {
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
                    });
    };
};

EventSourceReceiver.prototype = new REventTarget();

EventSourceReceiver.prototype.abort = function() {
    var that = this;
    if (that.es_close) {
        that.es_close({}, true);
    }
};
//         [*] End of lib/trans-receiver-eventsource.js


//         [*] Including lib/trans-receiver-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var _is_ie_htmlfile_capable;
var isIeHtmlfileCapable = function() {
    if (_is_ie_htmlfile_capable === undefined) {
        if ('ActiveXObject' in _window) {
            try {
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');
            } catch (x) {}
        } else {
            _is_ie_htmlfile_capable = false;
        }
    }
    return _is_ie_htmlfile_capable;
};


var HtmlfileReceiver = function(url) {
    var that = this;
    utils.polluteGlobalNamespace();

    that.id = 'a' + utils.random_string(6, 26);
    url += ((url.indexOf('?') === -1) ? '?' : '&') +
        'c=' + escape(WPrefix + '.' + that.id);

    var constructor = isIeHtmlfileCapable() ?
        utils.createHtmlfile : utils.createIframe;

    var iframeObj;
    _window[WPrefix][that.id] = {
        start: function () {
            iframeObj.loaded();
        },
        message: function (data) {
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));
        },
        stop: function () {
            that.iframe_close({}, 'network');
        }
    };
    that.iframe_close = function(e, abort_reason) {
        iframeObj.cleanup();
        that.iframe_close = iframeObj = null;
        delete _window[WPrefix][that.id];
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));
    };
    iframeObj = constructor(url, function(e) {
                                that.iframe_close({}, 'permanent');
                            });
};

HtmlfileReceiver.prototype = new REventTarget();

HtmlfileReceiver.prototype.abort = function() {
    var that = this;
    if (that.iframe_close) {
        that.iframe_close({}, 'user');
    }
};
//         [*] End of lib/trans-receiver-htmlfile.js


//         [*] Including lib/trans-receiver-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrReceiver = function(url, AjaxObject) {
    var that = this;
    var buf_pos = 0;

    that.xo = new AjaxObject('POST', url, null);
    that.xo.onchunk = function(status, text) {
        if (status !== 200) return;
        while (1) {
            var buf = text.slice(buf_pos);
            var p = buf.indexOf('\n');
            if (p === -1) break;
            buf_pos += p+1;
            var msg = buf.slice(0, p);
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));
        }
    };
    that.xo.onfinish = function(status, text) {
        that.xo.onchunk(status, text);
        that.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
    }
};

XhrReceiver.prototype = new REventTarget();

XhrReceiver.prototype.abort = function() {
    var that = this;
    if (that.xo) {
        that.xo.close();
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));
        that.xo = null;
    }
};
//         [*] End of lib/trans-receiver-xhr.js


//         [*] Including lib/test-hooks.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// For testing
SockJS.getUtils = function(){
    return utils;
};

SockJS.getIframeTransport = function(){
    return IframeTransport;
};
//         [*] End of lib/test-hooks.js

                  return SockJS;
          })();
if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);

// AMD compliance
if (typeof define === 'function' && define.amd) {
    define('sockjs', [], function(){return SockJS;});
}

if (typeof module === 'object' && module && module.exports) {
    module.exports = SockJS;
}
//     [*] End of lib/index.js

// [*] End of lib/all.js


},{}],141:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
module.exports = {
        StorageLRU: require('./src/StorageLRU'),
        asyncify: require('./src/asyncify')
    }

},{"./src/StorageLRU":142,"./src/asyncify":143}],142:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var ERR_DISABLED = {code: 1, message: 'disabled'};
var ERR_DESERIALIZE = {code: 2, message: 'cannot deserialize'};
var ERR_SERIALIZE = {code: 3, message: 'cannot serialize'};
var ERR_CACHECONTROL = {code: 4, message: 'bad cacheControl'};
var ERR_INVALIDKEY = {code: 5, message: 'invalid key'};
var ERR_NOTENOUGHSPACE = {code: 6, message: 'not enough space'};
var ERR_REVALIDATE = {code: 7, message: 'revalidate failed'};
    // cache control fields
var MAX_AGE = 'max-age';
var STALE_WHILE_REVALIDATE = 'stale-while-revalidate';
var DEFAULT_KEY_PREFIX = '';
var DEFAULT_PRIORITY = 3;
var DEFAULT_PURGE_LOAD_INCREASE = 500;
var DEFAULT_PURGE_ATTEMPTS = 2;
var CUR_VERSION = '1';

var asyncEachSeries = require('async-each-series');
require('setimmediate');

 
function isDefined (x) { return x !== undefined; }

function getIntegerOrDefault (x, defaultVal) {
    if ((typeof x !== 'number') || (x % 1 !== 0)) {
        return defaultVal;
    }
    return x;
}

function cloneError (err, moreInfo) {
    var message = err.message;
    if (moreInfo) {
        message += ': ' + moreInfo;
    }
    return {code: err.code, message: message};
}

function merge () {
    var merged = {};
    for (var i = 0, len = arguments.length; i < len; i++) {
        var obj = arguments[i];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                merged[key] = obj[key];
            }
        }
    }
    return merged;
}

function nowInSec () {
    return Math.floor(new Date().getTime() / 1000);
}

/*
 * Use this to sort meta records array.  Item to be purged first
 * should be the first in the array after sort.
 */
function defaultPurgeComparator (meta1, meta2) {
    // purge bad entries first
    if (meta1.bad !== meta2.bad) {
        return meta1.bad ? -1 : 1;
    }
    // purge truly stale one first
    var now = nowInSec();
    var stale1 = now >= (meta1.expires + meta1.stale);
    var stale2 = now >= (meta2.expires + meta2.stale);
    if (stale1 !== stale2) {
        return stale1 ? -1 : 1;
    }

    // both fetchable (not truly staled); purge lowest priority one first
    if (meta1.priority !== meta2.priority) {
        return (meta1.priority > meta2.priority) ? -1 : 1;
    }

    // same priority; purge least access one first
    if (meta1.access !== meta2.access) {
        return (meta1.access < meta2.access) ? -1 : 1;
    }
    // compare size. big ones go first.
    if (meta1.size > meta2.size) {
        return -1;
    } else if (meta1.size === meta2.size) {
        return 0;
    } else {
        return 1;
    }
}

function Meta (storageInterface, parser, options) {
    this.storage = storageInterface;
    this.parser = parser;
    this.options = options || {};
    this.records = [];
}

Meta.prototype.getMetaFromItem = function (key, item) {
    var meta;
    try {
        meta = this.parser.parse(item).meta;
        meta.key = key;
    } catch (ignore) {
        // ignore
        meta = {key: key, bad: true, size: item.length};
    }
    return meta;
};

Meta.prototype.updateMetaRecord = function (key, callback) {
    var self = this;

    self.storage.getItem(key, function getItemCallback (err, item) {
        if (!err) {
            self.records.push(self.getMetaFromItem(key, item));
        }
        callback && callback();
    });
};

Meta.prototype.generateRecordsHash = function () {
    var self = this;
    var retval = {};
    self.records.forEach(function recordsIterator (record) {
        retval[record.key] = true;
    });
    return retval;
};

Meta.prototype.init = function (scanSize, callback) {
    // expensive operation
    // go through all items in storage, get meta data
    var self = this;
    var storage = self.storage;
    var keyPrefix = self.options.keyPrefix;
    var doneInserting = 0;
    if (scanSize <= 0) {
        callback && callback();
        return;
    }

    storage.keys(scanSize, function getKeysCallback (err, keys) {
        var numKeys = keys.length;
        if (numKeys <= 0) {
            callback && callback();
            return;
        }
        // generate the records hash
        var recordsHash = self.generateRecordsHash();
        keys.forEach(function keyIterator (key) {
            // if the keyPrefix is different from the current options or we already have a record, ignore this key
            if (!recordsHash[key] && (!keyPrefix || key.indexOf(keyPrefix) === 0)) {
                self.updateMetaRecord(key, function updateMetaRecordCallback () {
                    doneInserting += 1;
                    recordsHash[key] = true;
                    if (doneInserting === numKeys) {
                       callback && callback();
                    }
                });
            } else {
                doneInserting += 1;
                if (doneInserting === numKeys) {
                    callback && callback();
                }
            }
        });
    });
};

Meta.prototype.sort = function (comparator) {
    this.records.sort(comparator);
};
Meta.prototype.update = function (key, meta) {
    for (var i = 0, len = this.records.length; i < len; i++) {
        var record = this.records[i];
        if (record.key === key) {
            record.bad = false; // in case it was a bad record before
            this.records[i] = merge(record, meta);
            return this.records[i];
        }
    }
    // record does not exist. create a new one.
    meta = merge(meta, {key: key});
    this.records.push(meta);
    return meta;
};
Meta.prototype.remove = function (key) {
    for (var i = 0, len = this.records.length; i < len; i++) {
        if (this.records[i].key === key) {
            this.records.splice(i, 1);
            return;
        }
    }
};
Meta.prototype.numRecords = function () {
    return this.records.length;
};

function Parser () {}
Parser.prototype.format = function (meta, value) {
    if (meta && meta.access > 0 && meta.expires > 0 && meta.stale >= 0 && meta.priority > 0 && meta.maxAge > 0) {
        return '[' + [CUR_VERSION, meta.access, meta.expires, meta.maxAge, meta.stale, meta.priority].join(':') + ']' + value;
    }
    throw new Error('invalid meta');
};
Parser.prototype.parse = function (item) {
    // format is:
    // [<version>:<access_time_in_sec>:<expires_time_in_sec>:<max_age_in_sec>:<stale_time_in_sec>:<priority>]<value_string_can_be_very_long>
    // in the future, parse version out first; then fields depending on version
    var pos = item && item.indexOf(']');
    if (!pos) {
        throw new Error('missing meta');
    }
    var meta = item.substring(1, pos).split(':');
    if (meta.length !== 6) {
        throw new Error('invalid number of meta fields');
    }
    meta = {
        version: meta[0],
        access: parseInt(meta[1], 10),
        expires: parseInt(meta[2], 10),
        maxAge: parseInt(meta[3], 10),
        stale: parseInt(meta[4], 10),
        priority: parseInt(meta[5], 10),
        size: item.length
    };
    if (isNaN(meta.access) || isNaN(meta.expires) || isNaN(meta.maxAge) || isNaN(meta.stale) || meta.access <= 0 || meta.expires <= 0 || meta.maxAge <= 0 || meta.stale < 0 || meta.priority <= 0) {
        throw new Error('invalid meta fields');
    }
    return {
        meta: meta,
        value: item.substring(pos + 1)
    };
};

function Stats (meta) {
    this.hit = 0;
    this.miss = 0;
    this.stale = 0;
    this.error = 0;
    this.revalidateSuccess = 0;
    this.revalidateFailure = 0;
}
Stats.prototype.toJSON = function () {
    var stats = {
        hit: this.hit,
        miss: this.miss,
        stale: this.stale,
        error: this.error,
        revalidateSuccess: this.revalidateSuccess,
        revalidateFailure: this.revalidateFailure
    };
    return stats;
};

/**
 * @class StorageLRU
 * @constructor
 * @param {Object} storageInterface  A storage object (such as window.localStorage, but not limited to localStorage)
 *                   that conforms to the localStorage API.
 * @param {Object} [options]
 * @param {Number} [options.recheckDelay=-1]  If the underline storage is disabled, this option defines the delay time interval
 *                   for re-checking whether the underline storage is re-enabled.  Default value is -1, which
 *                   means no re-checking.
 * @param {String} [options.keyPrefix=''] Storage key prefix.
 * @param {Number} [options.purgeFactor=1]  Extra space to purge. E.g. if space needed for a new item is 1000 characters, LRU will actually
 *                   try to purge (1000 + 1000 * purgeFactor) characters.
 * @param {Number} [options.maxPurgeAttempts=2] The number of times to load 'purgeLoadIncrease' more keys if purge cannot initially
 *                    find enough space.
 * @param {Number} [options.purgeLoadIncrease=500] The number of extra keys to load with each purgeLoadAttempt when purge cannot initially
 *                    find enough space.
 * @param {Function} [options.purgedFn] The callback function to be executed, if an item is purged.  *Note* This function will be
 *                   asynchronously called, meaning, you won't be able to cancel the purge.
 * @param {Function} [options.purgeComparator] If you really want to, you can customize the comparator used to determine items'
 *                   purge order.  The default comparator purges in this precendence order (from high to low):
 *                      bad entry (invalid meta info),
 *                      truly stale (passed stale-while-revaliate window),
 *                      lowest priority,
 *                      least recently accessed,
 *                      bigger byte size
 * @param {Function} [options.revalidateFn] The function to be executed to refetch the item if it becomes expired but still
 *                   in the stale-while-revalidate window.
 */
function StorageLRU (storageInterface, options) {
    var self = this;
    options = options || {};
    var callback = options.onInit;
    self.options = {};
    self.options.recheckDelay = isDefined(options.recheckDelay) ? options.recheckDelay : -1;
    self.options.keyPrefix = options.keyPrefix || DEFAULT_KEY_PREFIX;
    self.options.purgeLoadIncrease = getIntegerOrDefault(options.purgeLoadIncrease, DEFAULT_PURGE_LOAD_INCREASE);
    self.options.maxPurgeAttempts = getIntegerOrDefault(options.maxPurgeAttempts, DEFAULT_PURGE_ATTEMPTS);
    self.options.purgedFn = options.purgedFn;
    var metaOptions = {
        keyPrefix: self.options.keyPrefix
    };
    self._storage = storageInterface;
    self._purgeComparator = options.purgeComparator || defaultPurgeComparator;
    self._revalidateFn = options.revalidateFn;
    self._parser = new Parser();
    self._meta = new Meta(self._storage, self._parser, metaOptions);
    self._stats = new Stats();
    self._enabled = true;
}

/**
 * Reports statistics information.
 * @method stats
 * @return {Object} statistics information, including:
 *   - hit: Number of cache hits
 *   - miss: Number of cache misses
 *   - error: Number of errors occurred during getItem
 *   - stale: Number of occurrances where stale items were returned (cache hit with data that
 *            expired but still within stale-while-revalidate window)
 */
StorageLRU.prototype.stats = function () {
    return this._stats.toJSON();
};

/**
 * Gets a number of the keys of the items in the underline storage
 * @method keys
 * @param {Number} the number of keys to return
 * @param {Funtion} callback
 */
StorageLRU.prototype.keys = function (num, callback) {
    return this._storage.keys(num, callback);
};

/**
 * Gets the item with the given key in the underline storage.  Note that if the item has exipired but
 * is still in stale-while-revalidate window, its value will be revalidated if revalidateFn is provided
 * when the StorageLRU instance was created.
 * @method getItem
 * @param {String} key  The key string
 * @param {Object} options
 * @param {Boolean} [options.json=false]  Whether the value should be deserialized to a JSON object.
 * @param {Function} callback The callback function.
 * @param {Object} callback.error The error object (an object with code, message fields) if get failed.
 * @param {String|Object} callback.value The value.
 * @param {Object} callback.meta Meta information. Containing isStale field.  isStale=true means this
 *                    item has expired (max-age reached), but still within stale-while-revalidate window.
 *                    isStale=false means this item has not reached its max-age.
 */
StorageLRU.prototype.getItem = function (key, options, callback) {
    if (!key) {
        callback && callback(cloneError(ERR_INVALIDKEY, key));
        return;
    }
    var self = this;
    var prefixedKey = self._prefix(key);
    self._storage.getItem(prefixedKey, function getItemCallback (err, value) {
        if (err || value === null || value === undefined) {
            self._stats.miss++;
            self._meta.remove(prefixedKey);
            callback(cloneError(ERR_INVALIDKEY, key));
            return;
        }

        var deserialized;
        try {
            deserialized = self._deserialize(value, options);
        } catch (e) {
            self._stats.error++;
            callback(cloneError(ERR_DESERIALIZE, e.message));
            return;
        }
        var meta = deserialized.meta,
            now = nowInSec();

        if ((meta.expires + meta.stale) < now) {
            // item exists, but expired and passed stale-while-revalidate window.
            // count as hit miss.
            self._stats.miss++;
            self.removeItem(key);
            callback();
            return;
        }

        // this is a cache hit
        self._stats.hit++;

        // update the access timestamp in the underline storage
        try {
            meta.access = now;
            var serializedValue = self._serialize(deserialized.value, meta, options);
            self._storage.setItem(prefixedKey, serializedValue, function setItemCallback (err) {
                if (!err) {
                    meta = self._meta.update(prefixedKey, meta);
                }
            });
        } catch (ignore) {}

        // is the item already expired but still in the stale-while-revalidate window?
        var isStale = meta.expires < now;
        if (isStale) {
            self._stats.stale++;
            try {
                self._revalidate(key, meta, {json: !!(options && options.json)});
            } catch (ignore) {}
        }
        callback(null, deserialized.value, {isStale: isStale});
    });
};

/**
 * Calls the revalidateFn to fetch a fresh copy of a stale item.
 * @method _revalidate
 * @param {String} key The item key
 * @param {Object} meta  The meta record for this item
 * @param {Object} options
 * @param {Boolean} [options.json=false]  Whether the value is a JSON object.
 * @param {Function} [callback]
 * @param {Object} callback.error The error object (an object with code, message fields) if revalidateFn failed to fetch the item.
 * @private
 */
StorageLRU.prototype._revalidate = function (key, meta, options, callback) {
    var self = this;

    // if revalidateFn is defined, refetch item and save it to storage
    if ('function' !== typeof self._revalidateFn) {
        callback && callback();
        return;
    }

    self._revalidateFn(key, function revalidated (err, value) {
        if (err) {
            self._stats.revalidateFailure++;
            callback && callback(cloneError(ERR_REVALIDATE, err.message));
            return;
        }
        try {
            var now = nowInSec();

            // update the size and expires fields, and inherit other fields.
            // Especially, do not update access timestamp.
            var newMeta = {
                access: meta.access,
                maxAge: meta.maxAge,
                expires: now + meta.maxAge,
                stale: meta.stale,
                priority: meta.priority
            };

            // save into the underline storage and update meta record
            var serializedValue = self._serialize(value, newMeta, options);
            var prefixedKey = self._prefix(key);
            self._storage.setItem(prefixedKey, serializedValue, function setItemCallback (err) {
                if (!err) {
                    newMeta.size = serializedValue.length;
                    self._meta.update(prefixedKey, newMeta);

                    self._stats.revalidateSuccess++;
                } else {
                    self._stats.revalidateFailure++;
                }
            });
        } catch (e) {
            self._stats.revalidateFailure++;
            callback && callback(cloneError(ERR_REVALIDATE, e.message));
            return;
        }
        callback && callback();
    });
};

/**
 * Saves the item with the given key in the underline storage
 * @method setItem
 * @param {String} key  The key string
 * @param {String|Object} value  The value string or JSON object
 * @param {Object} options
 * @param {Boolean} options.cacheControl  Required.  Use the syntax as HTTP Cache-Control header.  To be
 *                   able to use LRU, you need to have a positive "max-age" value (in seconds), e.g. "max-age=300".
 *                   Another very useful field is "stale-while-revalidate", e.g. "max-age=300,stale-while-revalidate=6000".
 *                   If an item has expired (max-age reached), but still within stale-while-revalidate window,
 *                   LRU will allow retrieval the item, but tag it with isStale=true in the callback.
 *                   **Note**:
 *                    - LRU does not try to refetch the item when it is stale-while-revaliate.
 *                    - Having "no-cache" or "no-store" will abort the operation with invalid cache control error. 
 * @param {Boolean} [options.json=false]  Whether the value should be serialized to a string before saving.
 * @param {Number} [options.priority=3]  The priority of the item.  Items with lower priority will be purged before
 *                    items with higher priority, assuming other conditions are the same.
 * @param {Function} [callback] The callback function.
 * @param {Object} callback.error The error object (an object with code, message fields) if setItem failed.
 */
StorageLRU.prototype.setItem = function (key, value, options, callback) {
    if (!key) {
        callback && callback(cloneError(ERR_INVALIDKEY, key));
        return;
    }

    var self = this;
    if (!self._enabled) {
        callback && callback(cloneError(ERR_DISABLED));
        return;
    }

    // parse cache control
    var cacheControl = self._parseCacheControl(options && options.cacheControl);
    if (cacheControl['no-cache'] || cacheControl['no-store'] || !cacheControl[MAX_AGE] || cacheControl[MAX_AGE] <= 0) {
        callback && callback(cloneError(ERR_CACHECONTROL));
        return;
    }

    // serialize value (along with meta data)
    var now = nowInSec();
    var priority = (options && options.priority) || DEFAULT_PRIORITY;
    var meta = {
        expires: now + cacheControl[MAX_AGE],
        maxAge: cacheControl[MAX_AGE],
        stale: cacheControl[STALE_WHILE_REVALIDATE] || 0,
        priority: priority,
        access: now
    };
    var serializedValue;
    try {
        serializedValue = self._serialize(value, meta, options);
    } catch (serializeError) {
        callback && callback(cloneError(ERR_SERIALIZE));
        return;
    }

    // save into the underline storage and update meta record
    var prefixedKey = self._prefix(key);
    self._storage.setItem(prefixedKey, serializedValue, function setItemCallback (err) {
        if (!err) {
            meta.size = serializedValue.length;
            self._meta.update(prefixedKey, meta);
            callback && callback();
            return;
        } else {
            //check to see if there is at least 1 valid key
            self.keys(1, function getKeysCallback (err, keysArr) {
                if (keysArr.length === 0) {
                    // if numItems is 0, private mode is on or storage is disabled.
                    // callback with error and return
                    self._markAsDisabled();
                    callback && callback(cloneError(ERR_DISABLED));
                    return;
                }
                // purge and save again
                var spaceNeeded = serializedValue.length;
                self.purge(spaceNeeded, function purgeCallback (err) {
                    if (err) {
                        // not enough space purged
                        callback && callback(cloneError(ERR_NOTENOUGHSPACE));
                        return;
                    }
                    // purged enough space, now try to save again
                    self._storage.setItem(prefixedKey, serializedValue, function setItemCallback (err) {
                        if (err) {
                            callback && callback(cloneError(ERR_NOTENOUGHSPACE));
                        } else {
                            self._meta.update(prefixedKey, meta);
                            // setItem succeeded after the purge
                            callback && callback();
                        }
                    });
                });
            });
        }
    });
};

/**
 * @method removeItem
 * @param {String} key  The key string
 * @param {Function} [callback] The callback function.
 * @param {Object} callback.error The error object (an object with code, message fields) if removeItem failed.
 */
StorageLRU.prototype.removeItem = function (key, callback) {
    if (!key) {
        callback && callback(cloneError(ERR_INVALIDKEY, key));
        return;
    }
    var self = this;
    key = self._prefix(key);
    self._storage.removeItem(key, function removeItemCallback (err) {
        if (err) {
            callback && callback(cloneError(ERR_INVALIDKEY, key));
            return;
        }
        self._meta.remove(key);
        callback && callback();
    });
};

/**
 * @method _parseCacheControl
 * @param {String} str  The cache control string, following HTTP Cache-Control header syntax.
 * @return {Object} 
 * @private
 */
StorageLRU.prototype._parseCacheControl = function (str) {
    var cacheControl = {};
    if (str) {
        var parts = str.toLowerCase().split(',');
        for (var i = 0, len = parts.length; i < len; i++) {
            var kv = parts[i].split('=');
            if (kv.length === 2) {
                cacheControl[kv[0]] = kv[1];
            } else if (kv.length === 1) {
                cacheControl[kv[0]] = true;
            }
        }
        if (cacheControl[MAX_AGE]) {
            cacheControl[MAX_AGE] = parseInt(cacheControl[MAX_AGE], 10) || 0;
        }
        if (cacheControl[STALE_WHILE_REVALIDATE]) {
            cacheControl[STALE_WHILE_REVALIDATE] = parseInt(cacheControl[STALE_WHILE_REVALIDATE], 10) || 0;
        }
    }
    return cacheControl;
};

/**
 * Prefix the item key with the keyPrefix defined in "options" when LRU instance was created.
 * @method _prefix
 * @param {String} key  The item key.
 * @return {String} The prefixed key.
 * @private
 */
StorageLRU.prototype._prefix = function (key) {
    return this.options.keyPrefix + key;
};

/**
 * Remove the prefix from the prefixed item key.
 * The keyPrefix is defined in "options" when LRU instance was created.
 * @method _deprefix
 * @param {String} prefixedKey  The prefixed item key.
 * @return {String} The item key.
 * @private
 */
StorageLRU.prototype._deprefix = function (prefixedKey) {
    var prefix = this.options.keyPrefix;
    return prefix ? prefixedKey.substring(prefix.length) : prefixedKey;
};

/**
 * Mark the storage as disabled.  For example, when in Safari private mode, localStorage
 * is disabled.  During setItem(), LRU will check whether the underline storage
 * is disabled.
 * If the LRU was created with a recheckDelay option, LRU will re-check whether the underline
 * storage is disabled. after the specified delay time.
 * @method _markAsDisabled
 * @private
 */
StorageLRU.prototype._markAsDisabled = function () {
    var self = this;
    self._enabled = false;
    // set a timeout to mark the cache back to enabled so that status can be checked again
    var recheckDelay = self.options.recheckDelay;
    if (recheckDelay > 0) {
        setTimeout(function reEnable() {
            self._enabled = true;
        }, recheckDelay);
    }
};

/**
 * Serializes the item value and meta info into a string.
 * @method _serialize
 * @param {String|Object} value
 * @param {Object} meta  Meta info for this item, such as access ts, expire ts, stale-while-revalidate window size
 * @param {Object} options
 * @param {Boolean} [options.json=false]
 * @return {String} the serialized string to store in underline storage
 * @private
 * @throw Error
 */
StorageLRU.prototype._serialize = function (value, meta, options) {
    var v = (options && options.json) ? JSON.stringify(value) : value;
    return this._parser.format(meta, v);
};

/**
 * De-serializes the stored string into item value and meta info.
 * @method _deserialize
 * @param {String} str The stored string
 * @param {Object} options
 * @param {Boolean} [options.json=false]
 * @return {Object} An object containing "value" (for item value) and "meta" (Meta data object for this item, such as access ts, expire ts, stale-while-revalidate window size).
 * @private
 * @throw Error
 */
StorageLRU.prototype._deserialize = function (str, options) {
    var parsed = this._parser.parse(str);
    return {
        meta: parsed.meta,
        value: options.json? JSON.parse(parsed.value) : parsed.value
    };
};

/**
 * Purge the underline storage to make room for new data.  If options.purgedFn is defined
 * when LRU instance was created, this function will invoke it with the array if purged keys asynchronously.
 * If the meta data for all objects has not yet been built, then it will occur in this function.
 * @method purge
 * @param {Number} spaceNeeded The char count of space needed for the new data.  Note that
 *                   if options.purgeFactor is defined when LRU instance was created, extra space
 *                   will be purged. E.g. if spaceNeeded is 1000 characters, LRU will actually
 *                   try to purge (1000 + 1000 * purgeFactor) characters.
 * @param {Boolean} forcePurge True if we want to ignore un-initialized records, else false;
 * @param {Function} callback  
 * @param {Error} callback.error  if the space that we were able to purge was less than spaceNeeded.
 */
StorageLRU.prototype.purge = function (spaceNeeded, callback) {
    var self = this;
    var factor = Math.max(0, self.options.purgeFactor) || 1;
    var padding = Math.round(spaceNeeded * factor);

    var removeData = {
        purged: [],
        recordsToRemove: [],
        size: spaceNeeded + padding
    };

    var attempts = [];
    for (var i = 0; i < self.options.maxPurgeAttempts; i++) {
        attempts.push((i + 1) * self.options.purgeLoadIncrease);
    }

    asyncEachSeries(attempts, function purgeAttempt(loadSize, attemptDone) {
        removeData.recordsToRemove = [];
        removeData.purged = [];

        self._meta.init(loadSize, function doneInit() {
            self._meta.sort(self._purgeComparator);
            asyncEachSeries(self._meta.records, function removeItem(record, cb) {
                // mark record to remove, to remove in batch later for performance
                record.remove = true;
                removeData.purged.push(self._deprefix(record.key)); // record purged key
                self._storage.removeItem(record.key, function removeItemCallback (err) {
                    // if there was an error removing, remove the record but assume we still need some space
                    if (!err) {
                        removeData.size = removeData.size - record.size;
                    }
                    if (removeData.size > 0) {
                        cb(); // keep removing
                    } else {
                        cb(true); // done removing
                    }
                });
            }, function itemsRemoved(ignore) {
                // remove records that were marked to remove
                self._meta.records = self._meta.records.filter(function shouldKeepRecord(record) {
                    return record.remove !== true;
                });

                // invoke purgedFn if it is defined
                var purgedCallback = self.options.purgedFn;
                var purged = removeData.purged;
                if (purgedCallback && purged.length > 0) {
                    // execute the purged callback asynchronously to prevent library users
                    // from potentially slow down the purge process by executing long tasks
                    // in this callback.
                    setImmediate(function purgeTimeout() {
                        purgedCallback(purged);
                    });
                }

                if (removeData.size <= padding) {
                    // removed enough space, stop subsequent purge attempts
                    attemptDone(true);
                } else {
                    attemptDone();
                }
            });
        });
    }, function attemptsDone() {
        // async series reached the end, either because all attempts were tried,
        // or enough space was already freed.

        // if enough space was made for spaceNeeded, consider purge as success
        if (callback) {
            if (removeData.size <= padding) {
                callback();
            } else {
                callback(new Error('still need ' + (removeData.size - padding)));
            }
        }
    });
};

module.exports = StorageLRU;
},{"async-each-series":61,"setimmediate":138}],143:[function(require,module,exports){
/**
 * 
 * A simple mixin to go around syncronous storage interfaces (such as html5 local storage).
 * 
 * @param {Object} syncObject The syncronous storage object.
 */
function asyncify (syncObject) {
    var retval = {
        getItem: function (key, callback) {
            callback(null, syncObject.getItem(key));
        },
        setItem: function (key, value, callback) {
            try {
                syncObject.setItem(key, value);
            } catch (e) {
                callback(e);
                return;
            }
            callback(null, value);
        },
        removeItem: function (key, callback) {
            syncObject.removeItem(key);
            callback();
        }
    };
     // be smart about wrapping local storage
    if (!syncObject.keys && (typeof syncObject.length === 'number')) {
        retval.keys = function getKeylistFromIndices (num, callback) {
            var arr = [];
            var limit = (num > syncObject.length) ? syncObject.length : num;
            for (var i = 0, len = limit; i < len; i++) {
                arr.push(syncObject.key(i));
            }
            callback(null, arr);
        };
    }
    return retval;
}

module.exports = asyncify;
},{}],144:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],145:[function(require,module,exports){
//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],146:[function(require,module,exports){
/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.URI = global.URI || {})));
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map

},{}],147:[function(require,module,exports){
'use strict'
module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}

},{}],148:[function(require,module,exports){
'use strict'
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  require('./iterator.js')(Yallist)
} catch (er) {}

},{"./iterator.js":147}],149:[function(require,module,exports){

var Cluster = function (psshEntry) {
	this.members = null;
	this.seq_start = psshEntry.seq_start;
	this.seq_end = psshEntry.seq_end;
	this.psshEntry = psshEntry;
	this.alignment_identity_score = [ psshEntry.alignment_identity_score ];
	this.memberMap = {};
};


Cluster.prototype.addMember = function(member) {
  var ret = false;
  if (this.isUnique(member)) {
    this.members.push(member);
    this.memberMap[member.pdb_id + member.pdb_chain] = [member];
    ret = true;
  }
  return ret;
};

Cluster.prototype.clean = function() {
  this.memberMap = null;
  this.psshEntry = null;
  delete this.memberMap;
  delete this.psshEntry;
};


//Cluster.prototype.sort = function() {
// 
//  this.members.sort(function (a, b) {
//    var diff = b.alignment_identity_score - a.alignment_identity_score;
//    if (diff === 0) {
//      diff = b.match_length - a.match_length;
//    }
////    if (diff === 0) {
////      
////      // identical residues
////    }
//    if (diff === 0) {
//      diff = a.
//      // resolution
//    }
//    if (diff === 0) {
////      NMR, cyro last
//    }
//    if (diff === 0) {
////      by date
//    }
//
//  });
//}

function arraysIdentical(a, b) {
  var i = a.length;
  if (i != b.length) return false;
  while (i--) {
      if (a[i] !== b[i]) return false;
  }
  return true;
};

Cluster.prototype.isUnique = function(entry) {
  var key = entry.pdb_id + entry.pdb_chain;
  children = this.memberMap[key];
//  if (key === '4h34A') {
//    console.log(' key :' + key + ', children : ' + JSON.stringify(children));
//  }
  if (children) {
    return !children.some(function (child) {
      var ret =  arraysIdentical(child.viewer_format, entry.viewer_format);
      if (ret ){
//        console.log('found sameo:');
        
      }
      //  PTPN11
      if (key === '4h34A') {
//        console.log(' key :' + key + ', children : ' + JSON.stringify(children) + " ret: " + ret + ", child.viewer_format, entry.viewer_format: " + [child.viewer_format, entry.viewer_format].join('***'));
      }
      return ret;
    });
  }
  else {
    return true;
  }
}



Cluster.prototype.initialise = function(member) {
	this.members = [member];
	this.cluster_size = this.members.length;
	this.pdb_id = this.members[0].pdb_id;
	this.pdb_chain = this.members[0].pdb_chain
			.slice(0);
  this.model = this.members[0].model;
//  console.log('member for cluster is: ' + JSON.stringify(member));
	this.Repeat_domains = this.members[0].Repeat_domains
			.slice(0);
//	this.biounits = this.members[0].biounits;

};

Cluster.prototype.update = function() {
	this.cluster_size = this.members.length;
};

Cluster.prototype.getPSSHID = function () {
	return  [this.pdb_id , '-', this.pdb_chain[0] , '-', this.Repeat_domains[0]].join('');
};



module.exports = Cluster;





},{}],150:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],151:[function(require,module,exports){

},{}],152:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":150,"ieee754":156,"isarray":153}],153:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],154:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":158}],155:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],156:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],157:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],158:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],159:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],160:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],161:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],162:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],163:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],164:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":162,"./encode":163}],165:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":166}],166:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":168,"./_stream_writable":170,"_process":160,"core-util-is":154,"inherits":157}],167:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":169,"core-util-is":154,"inherits":157}],168:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"./_stream_duplex":166,"_process":160,"buffer":152,"core-util-is":154,"events":155,"inherits":157,"isarray":159,"stream":175,"string_decoder/":176,"util":151}],169:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":166,"core-util-is":154,"inherits":157}],170:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":166,"_process":160,"buffer":152,"core-util-is":154,"inherits":157,"stream":175}],171:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":167}],172:[function(require,module,exports){
(function (process){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
if (!process.browser && process.env.READABLE_STREAM === 'disable') {
  module.exports = require('stream');
}

}).call(this,require('_process'))
},{"./lib/_stream_duplex.js":166,"./lib/_stream_passthrough.js":167,"./lib/_stream_readable.js":168,"./lib/_stream_transform.js":169,"./lib/_stream_writable.js":170,"_process":160,"stream":175}],173:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":169}],174:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":170}],175:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":155,"inherits":157,"readable-stream/duplex.js":165,"readable-stream/passthrough.js":171,"readable-stream/readable.js":172,"readable-stream/transform.js":173,"readable-stream/writable.js":174}],176:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":152}],177:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":161,"querystring":164}]},{},[1,2,3,4,5,6,7,8,9,10,11,14,15,16,17,12]);
